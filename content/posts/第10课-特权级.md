+++
author = "FanHe"
title = "第10课 中断和特权级"
date = 2022-04-20T14:45:01+08:00
description = ""
categories = [
 "从零打造操作系统"
]
draft = false
+++

## 

## 1. 概述

本来想将特权级单独来讲解，但是考虑到特权级和中断的关系，因此将二者结合起来讲解，因为中断很大一个原因是我们想通过中断门来实现调用操作系统提供的功能，这样自然就涉及到了特权级的提升，因此二者之间有着莫大的联系

## 2. 中断的分类

中断可以分为内部中断和外部中断，

- 内部中断
  
  - 可屏蔽的内部中断
  
  - 不可屏蔽的内部中断

- 外部中断
  
  - 可屏蔽的外部中断
  
  - 不可屏蔽的外部中断

可以这样说，操作系统之所以可以提供如此强大的功能就是有赖于中断，操作系统是正常运转都是由中断驱动的

## 3. 中断描述符

中断描述符是一种描述符，大小是8个字节，它记录了中断处理程序的入口地址，这样当硬件接收到中断号时，可以使用这个中断号去中断描述符表中获取中断描述符，然后根据这个中断描述符查找到中断处理程序，最终完成对中断的处理

## 4. 中断的处理过程

整的中断过程分为CPU外和CPU内两部分。
CPU外：外部设备的中断由中断代理芯片接收，处理后将该中断的中断向量号发送到CPU。
CPU内：CPU执行该中断向量号对应的中断处理程序。

中断外的处理一般是使用代理芯片进行处理（比如8259A）我们暂不关心，重点关注CPU内部的处理，因为这是我们真正需要编码的地方，整个过程如下：

（1）处理器根据中断向量号定位中断门描述符

     中断向量号 * 8 + IDT的基地址 = 中断描述符

（2）处理器进行特权级检查

当前特权级CPL必须在门描述符DPL和门中目标代码段DPL之间。这是为了防止位于3特权级下的用户程序主动调用某些只为内核服务的例程

（3）通过检查后，在中断描述符中拿到段描述符的基址和偏移地址，获取到最终运行代码的位置，并将其装载到CS和EIP中，执行相应的中断处理程序

<img src="/img/osdev/idt-process.png" title="" alt="中断图示" data-align="center">

## 5. 中断处理过程中的压栈操作

中断在发生时，处理器收到一个中断向量号，根据此中断向量号在中断描述符表中找到相应的中断门描述符，门描述符中保存的是中断处理程序所在代码段的选择子及在段内偏移量，处理器从该描述符中加载目标代码段选择子到代码段寄存器CS及偏移量到指令指针寄存器EIP。注意，由于CS加载了新的目标代码段选择子，处理器不管新的选择子和任何段寄存器（包括CS）中当前的选择子是否相同，也不管这两个选择子是否指向当前相同的段，只要段寄存器被加载，段描述符缓冲寄存器就会被刷新，处理器都认为是换了一个段，属于段间转移，也就是远转移。所以，当前进程被中断打断后，为了从中断返回后能继续运行该进程，处理器自动把CS和EIP的当前值保存到中断处理程序使用的栈中。不同特权级别下处理器使用不同的栈，至于中断处理程序使用的是哪个栈，要视它当时所在的特权级别，因为中断是可以在任何特权级别下发生的。除了要保存CS、EIP外，还需要保存标志寄存器EFLAGS，如果涉及到特权级变化，还要压入SS和ESP寄存器。

## 6. 中断处理结束后的出栈操作

处理器进入中断执行完中断处理程序后，还要返回到被中断的进程，这是进入中断的逆过程。中断返回是用iret指令实现的。Iret，即interrupt ret，此指令专用于从中断处理程序返回，假设在32位模式下，它从当前栈顶处依次弹出32位数据分别到寄存器EIP、CS、EFLAGS。iret指令并不清楚栈中数据的正确性，它只负责把栈顶处往上的数据，每次4字节，对号入座弹出到相关寄存器，所以在使用iret之前，一定要保证栈顶往上的数据是正确的，且从栈顶往上的顺序是EIP、CS、EFLAGS，根据特权级是否有变化，还有ESP、SS。
