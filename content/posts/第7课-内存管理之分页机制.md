+++
author = "FanHe"
title = "第7课 内存管理之分页机制"
date = 2022-04-19T09:30:01+08:00
description = ""
categories = [
 "从零打造操作系统"
]
draft = false
+++

## 

## 1. 概述

本文主要讲解一下在x86 32位下的分页内存管理，分页机制使得我们不再直接使用和操作物理内存，而是为每一个任务（进程）分配一个独立4G空间的内存，在透过CPU提供的段页式内存管理机制，实现将我们使用的虚拟内存地址转换到实际的物理内存，这一课相对来说难度较大



## 2. 分页管理的过程



### 2.1 内存地址转换方式

- 分页管理之前的内存处理

在分页管理之前我们使用的是段式内存管理，这其中也分为两种：

1. 实模式下的内存寻址：段地址左移4位 + 偏移地址 = 最终的物理地址

2. 保护模式下的寻址：段选择子-->获取到段基址 + 偏移地址 = 最终的物理地址

我们可以看到：所有获取到的最终都是**物理地址**



- 开启分页之后的内存处理

在开启分页机制之后，我们在代码中给出的内存地址都是虚拟地址，虚拟地址也是采用段式的管理方式，我们通过段选择子-->获取到段基址 + 偏移地址 = 线性地址。开启分页之后获取到的地址是线性地址，还需要将线性地址通过分页机制才能真正转换成最终的物理地址



### 2.2 分页机制

我们首先拿到的是线性地址，它的结构如下：

      31                 22 21                 12 11                 0
     +---------------------+---------------------+--------------------+
     |                     |                     |                    |
     |         DIR         |        PAGE         |       OFFSET       |
     |                     |                     |                    |
     +---------------------+---------------------+--------------------+

我们把线性地址划分为3部分：高10位 + 中间10位 + 低12位，它们各有用处，总的转换过程如下图所示：

<img src="file:///D:/workspace/fanhestyle.github.io/static/img/osdev/page-trans.png" title="" alt="页表转换" data-align="center">

![转换示例](D:\workspace\fanhestyle.github.io\static\img\osdev\page-trans-example.png)

需要注意的是：

（1）CR3控制寄存器中存储的是页目录的物理地址（得到这个地址不需要进行页转换，否则会陷入死循环，一定要用一个地址直接可以直接拿到物理地址方式）

（2）在页目录表中的页目录项里面存储的也是页表的物理地址（也是直接拿到物理地址，不需要进行页转换）



### 2.3 页目录项和页表项

我们知道页目录项中存储的是页表的**物理地址**，页表项中存储的是**物理页框的物理地址** ，那么页目录项和页表项的实际结构是什么样的呢？下图给出

<img src="file:///D:/workspace/fanhestyle.github.io/static/img/osdev/page-entry-and-page-dir-entry.png" title="" alt="页表项和页目录项" data-align="center">

可以看到页目录项和页表项都是4个字节大小（4Byte = 32位），于是我们可以有下面的结论：

1. 页目录包含有1024个页目录项，每一个页目录项指向一个页表，一个页目录项的大小是4Byte，一个页目录项指向的页表可以申请的内存是4MB，也就是说一个页目录项对应的真实物理内存是4MB，由于有1024个页目录项，所以二级页目录项对应的物理内存大小是4GB

2. 每一个页表可以有1024个页表项，一个页表项是4Byte，于是一个页表占据的空间大小就是4x1024 = 4KB，同时一个页表项对应的物理内存大小是4K，于是一个页表对应的物理内存大小就是 4K * 1024 = 4M



## 3. 页目录和页表的组织

页目录和页表可以在内存中的任意位置，为了简单我们将页目录和页表放在一起（一个页目录需要4K的空间，所有的页表需要4M的空间），因此我们放在的位置是紧邻 1MB内存的位置

```
需要注意的是：页表项并不是所有的都一次性要申请，页目录项也是1个页目录项
可以管理4MB的内存，引入二级页表的原因就是用多少申请多少，上面所说的4K+4M是
极限的情况，也就是分配所有4GB空间的情形，一般来说基本不可能达到
```

内存中组织的方式如下图所示：

<img src="file:///D:/workspace/fanhestyle.github.io/static/img/osdev/page-mm-layout.png" title="" alt="页表和页目录内存分配图" data-align="center">

整个安排是上面的图示，但是具体有一些细节需要注意：

- 页目录表最多只有1个，页表可以最多可以有1024个，我们需要合理规划一下；

- 我们想把低3GB的地址留给用户进程未来使用，把3G-4G这高1GB的地址留给操作系统使用（注意我们目前正在编写的就是操作系统），也就是说我们会把目前编码的地址映射到虚拟地址的3G-4G上，如何做到这一点呢？

结合我们上面的页转换有以下的一些规则：

1. 线性地址的高10位会作为页目录项索引在页目录表中查找；

2. 线性地址的中10位会作为页表项索引在页表中查找

3. 线性地址的低10位作为真正的偏移在物理地址中查找

为了映射3GB开始的内存区域，我们把3GB转换成二进制是：0xC0000000，高10位转换成十进制是 768，也就是说我们只需要在第768项中的页目录中写入页表的物理地址，那么那个页表所对应的线性地址就是3GB以上的，有了这个理论，我们这样去做：



（1）页目录表的第0项（索引为0）写入页表物理地址

（2）页目录表的第768项写入页表物理地址，并且我们让写入的值和第0项相同，这样它们就都映射到相同的页表了，由于我们想把这个相同的页表都映射到低1MB内存区域，这样做的好处是：我们可以继续之前未开启分页机制的代码正确运作，也可以未来都使用3GB以上的虚拟地址来访问1MB的物理内存



**<u>小更正：上图中绘制的内存组织方式，实际上在代码中并没有采用这种方式，代码中的页表项只有255项（都是内核占用的，低0-3GB的虚拟地址我们并没有映射页目录项到页表），正确的图示如下：【和代码一致】</u>**



<img src="file:///D:/workspace/fanhestyle.github.io/static/img/osdev/VirtualMMtoPysicalMM.png" title="" alt="虚拟地址到物理地址" data-align="center">

代码部分

```asm6502

.type setup_page, @function
setup_page:

//清空页目录表中所有1024项
    movl $4096, %ecx
    movl $0, %esi
clear_page_dir_table:
    movb $0, PAGE_DIR_TABLE_POS(,%esi)
    incl %esi
    loop clear_page_dir_table

//创建PDE
movl $PAGE_DIR_TABLE_POS, %eax
addl $0x1000, %eax
//ebx指向索引为0的页表的物理地址
movl %eax, %ebx

//页目录项中的第0项和第768项指向索引为0的页表
//也就是第0项和第768项的页目录项指向了索引为0的页表
orl $PDE_PTE_FLAG, %eax
movl %eax, (PAGE_DIR_TABLE_POS)
movl %eax, (PAGE_DIR_TABLE_POS + 0xc00)

//页目录项的最后一项(1023索引项)指向页目录表自身
subl $0x1000, %eax
movl %eax, (PAGE_DIR_TABLE_POS+4092)

//创建PTE
//把低1MB的内存物理地址映射到虚拟地址上
//由于每一个页表项可以对应4KB的物理内存，那么1MB的物理内存
//需要的页表项数量 = 1MB / 4k = 1024 / 4 = 256项
movl $256, %ecx 
movl $0, %esi
movl $PDE_PTE_FLAG, %edx

create_pte:
    movl %edx, (%ebx,%esi,4)
    addl $4096, %edx
    incl %esi
    loop create_pte

//把剩下的操作系统页目录项填充满
    movl $PAGE_DIR_TABLE_POS, %eax
    addl $0x2000, %eax
    or $PDE_PTE_FLAG, %eax
    movl PAGE_DIR_TABLE_POS, %ebx
    movl $254, %ecx
    movl $769, %esi

create_kernel_pde:
    movl %eax, (%ebx,%esi,4)
    inc %esi
    addl $0x1000, %eax
    loop create_kernel_pde

    ret
```



## 4. 开启分页

开启分页机制在我们设置页目录表和页表之后，还有一些工作要做，包括

（1）把页目录表的地址加载到CR3寄存器中（注意是物理地址）

（2）寄存器CR0的分页位打开（第31位）

（3）必要的一些段描述符和栈指针的修改【比如映射到3G以上内存中，需要在原来的基础上加上0xC0000000】

代码如下：

```asm6502

//读取gdt
sgdt gdt_ptr

//把基地址读入到%ebx
movl (gdt_ptr+2), %ebx

orl $0xc0000000, 0x1c(%ebx)

addl $0xc0000000, (gdt_ptr+2)
addl $0xc0000000, %esp

//把页目录表的基地址写入到CR3控制寄存器
movl $PAGE_DIR_TABLE_POS, %eax
movl %eax, %cr3

movl %cr0, %eax
//打开cr0的pg位（第31位）
orl $0x80000000, %eax
movl %eax, %cr0

lgdt gdt_ptr

```



# 
