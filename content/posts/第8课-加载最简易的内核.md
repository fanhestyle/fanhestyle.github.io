+++
author = "FanHe"
title = "第8课 加载最简易的内核和ELF文件"
date = 2022-04-20T09:00:01+08:00
description = ""
categories = [
 "从零打造操作系统"
]
draft = false
+++

## 

## 1. 概述

本文即将开始加载最简易的内核代码，我们将控制权从Bootloader继续转交给下一棒的操作系统。

我们的操作系统大部分使用C语言来开发，通过C语言开发生成的是可执行的ELF文件，由此带来一个问题是：我们需要解析我们生成的ELF文件，并把程序的代码和数据拷贝到内存中的指定位置，也就是说：

（1）编译生成的操作系统是一个ELF的文件，我们需要解析它，也就是需要熟悉ELF格式

（2）我们把ELF文件读入到内存中，我们需要指定一个保存这个映像的位置

（3）在读入操作系统映像后，我们最终可执行的操作系统指令和数据与读取进来的映像是有差别的，我们还需要把这个映像进行“解压”，得到真正的操作系统指令和数据

## 2. ELF文件

ELF（Executable and Linkable Format）是一种广泛使用在类Unix操作系统中的文件，它的文件结构分为ELF头，Programmable部分以及Sector部分，关于ELF更详细的介绍可以参考网络上专门讲ELF的内容

## 3. 系统内核代码

我们最简单的系统内核代码只有一行代码

```c
//文件名main.c
int main(void)
{
    while(1);
    return 0;
}
```

首先我们需要将其编译成可执行文件，由于我们是在编写操作系统，因此肯定是不可以使用C运行时库的，于是我们不能这样做：

```
gcc main.c -o kernel.bin
```

因为这样去生成kernel.bin的过程中GCC会帮我们链接到C runtime库，我们正确的做法是使用AS和LD工具自行编译链接

## 4. 内核的加载

在概述部分我们已经讲述了加载操作系统的过程，根据代码中的描述，加载之后的内存布局如下：

<img src="/img/osdev/kernel-os-1.png" title="" alt="内核MM" data-align="center">
