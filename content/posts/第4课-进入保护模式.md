+++
author = "FanHe"
title = "第4课 进入保护模式"
date = 2022-04-18T16:00:21+08:00
description = ""
categories = [
 "从零打造操作系统"
]
draft = false
+++

## 

## 1. 概述

本文开始从实模式进入到保护模式，实模式是指老式的兼容8086的模式，在实模式下各种寄存器的宽度是16位的，程序寻址内存的时候采用的是段地址偏移4位+偏移地址，而进入到保护模式之后，寄存器的宽度大部分都是32位的，并且内存的寻址方式采用 段选择子 + 偏移地址的模式

- 实模式寻址方式

![实模式寻址](/img/osdev/realmode-address.png)

- 保护模式寻址方式

![保护模式寻址](/img/osdev/protectedmode-address.png)

除了上述提到的变化，保护模式还引入了更多的内容，包括任务切换、特权级管理等非常多的内容

## 2. 进入保护模式步骤

CPU从刚开始加电运行到加载MBR以及后续的Bootloader都是在实模式下运行的，为了切换到保护模式下，需要以下步骤：

（1）打开A20

（2）加载GDT

（3）CR0寄存器的PE位置为1

以下一一进行解释：

### 2.1 打开A20

为什么要打开A20呢？我们知道在8086模式下CPU可寻址的内存只有1MB，地址总线是20条，于是为了扩展寻址的范围，我们需要突破这个限制，这就是需要打开A20的原因，打开的方式比较简单，只需要读写0x92端口即可

```
inb $0x92, %al
orb $0x2, %al
outb %al, $0x92
```

### 2.2 加载GDT

在保护模式下所有内存的访问不再是实模式下的段地址+偏移地址直接进行访问，而是引入了段描述符，段描述符都是8个字节，段描述符是一个总称，保护模式中涉及到的所有和内存相关的概念都与它相关，分类为：

- 系统段描述符
  
  - 各种门描述符（中断门、陷阱门、调用门、任务门）
  
  - TSS
  
  - LDT

- 用户段描述符
  
  - 代码段（一致性和非一致性代码段）
  
  - 数据段

段描述符的8个字节（一般划分为高4字节和低4字节）内容如下：

![段描述符](/img/osdev/segment-descriptor.png)

我们需要按照我们想访问的内存设置几个段描述符（自行组装），然后把段描述符通过 lgdt 指令加载到 GDTR寄存器中

### 2.3 CR0中的PE位置为1

CR0是CPU中的一个控制寄存器，它的某些位具有特殊的作用，我们启用保护模式需要打开它的最低位（最低位设置为1），CR0寄存器的结构如下：

![CR0寄存器](/img/osdev/CR0-register.png)

开启方式如下

```asm6502
movl %cr0, %eax
or $0x1, %eax
movl %eax, %cr0
```

## 3. 清空流水线

当我们执行完进入保护模式的各种步骤之后，实际上还需要刷新一下流水线，由于CPU的预加载机制，因此导致可能在执行到保护模式下32位指令之前，已经有一部分16位的实模式指令在缓存中，为了让程序可以正确执行之后的语句，可以使用一条远跳转语句来达到刷新流水线的效果，指令如下

```asm6502
ljmp $SELECTOR_CODE, $p_mode_start
```

至此之后CPU就进入到保护模式下愉快的执行了！

# 
