+++
author = "FanHe"
title = "第9课 函数调用"
date = 2022-04-20T11:07:01+08:00
description = ""
categories = [
 "从零打造操作系统"
]
draft = false
+++

## 

## 1. 概述

本文介绍在汇编语言中的函数调用以及汇编和C的函数调用互操作的一些内容，我们假设C语言和汇编进行相互操作，那么情况有如下几种：

1. C语言调用C语言所写的函数

2. C语言调用汇编语言所写的函数

3. 汇编语言调用C语言所写的函数

4. 汇编语言调用汇编语言所写的函数

对于1，C语言调用C语言都是编译器替我们处理好的，我们不用关心

对于2，本文重点讨论

对于3， 也是编译器帮助我们处理好，我们只需要让C的函数是导出的(extern)，那么汇编调用即可

对于4， 编写方式可以任意，因为都是汇编语句，不需要遵循任何规则，当然我们也可以把被调用的汇编函数仿造C语言的风格来写，不过这都无所谓

## 2. 调用约定

在汇编和C语言互操作的过程中，我们需要了解到调用底层ABI的一些知识。首先汇编和C语言互操作，它们的参数传递是采用栈的方式进行的。也就是说传递的参数调用方需要把参数入栈，被调用方得从栈中取出参数，这就涉及到一个问题了，栈中参数的形态是怎样的？

另外在函数调用过程中寄存器会发生变化，我们是否要备份寄存器呢？这些都是问题

实际上在x86的架构中有多种处理方式，这些处理方式被称为调用约定，我们主要讲一下C语言的调用约定，一般称为 cdel，约定如下：

```
1. 参数使用栈传递
2. EAX，ECX，EDX由被调用者保存
3. 其余寄存器由被调用者保存
4，函数返回值存储在EAX中
5. 栈清理工作由调用者清理
6. 参数的传递方式是从右往左进行入栈
```

## 3.  cdecl 函数调用过程

### 3.1 主调函数调用

- （1）将所有调用参数压栈
- （2）调用call指令

> 在被调函数执行中，被调函数可能会修改一些寄存器的值，导致我们主调函数当前的寄存器值会被覆盖（%ebp除外），因此如果我们在调用函数前有需要保存的寄存器值，那么我们必须在push参数之前，对这些寄存器进行压栈操作

在被调函数开始执行前，当前进程中的栈如下图所示：

```bash
参数N
参数N-1
...
参数2
参数1
主调函数的返回地址  <----- (%esp) # 返回地址是我们主调函数call func的下一条指令
```

### 3.2 被调函数执行

这一过程分为3步：

（1）运行代码前准备阶段

（2）运行代码阶段

（3）运行代码后的清理阶段

其中（1）（3）对于所有函数调用都是一样的，只有（2）根据每个函数不同的功能而有差别（毕竟每个函数执行的作用是我们自己写的，各不相同）

- （1） 运行前准备阶段

设置阶段以下两条指令会被立刻执行

```bash
pushl %ebp       
movl %esp %ebp
```

第一条指令用来备份当前的base pointer（也就是栈帧指针 frame pointer）%ebp，然后通过esp把当前被调函数的栈顶指针赋值给它。

> ebp的作用非常关键，它起到了两个重要的作用：在其上是被调函数要使用的参数，而在其下是被调函数在函数体内声明的一些局部变量，而在ebp当口指向的就是上一个主调函数的ebp的备份值，于是ebp起到一个承上启下的作用，既可以获取函数传入的实参（高地址），又可以获取函数内部声明的局部变量（低地址），而它自己指向的地址是主调函数的ebp，并且 ebp也标识着当前被调函数的最高的地址（也就是当前栈帧的栈帧底部，esp指向当前栈帧的最高顶部） 那么ebp最原始的值是什么呢？也就是第一个启动整个进程的ebp的初始值，在参考资料2中给出的回答是：它的初值是0，在程序被装入内存的时候（elf文件的入口点被加载时，指向了一条指令 xor ebp, ebp

准备阶段结束时的栈如下图所示：

```bash
参数N                     <---------N*4+4(%ebp)
参数N-1
...
参数2
参数1                       <---------8(%ebp)
主调函数的返回地址            <---------4(%ebp)
主调函数的ebp值 %ebp          <-------- (%ebp) = (%esp)
```

- （2）运行代码阶段

代码运行阶段就是开始实质性的执行我们所写的功能了，这个过程会涉及到几个事情：

《1》保存寄存器的值

一般我们会把寄存器分为几类，比如

(a) eax, edx, ecx被称之为caller-save寄存器

(b) ebx, esi, edi 称之为callee-save寄存器

我们在开始执行代码的时候，第一步需要保存这些callee-save寄存器的值，在执行完函数返回之前恢复这些寄存器的值，而caller-save寄存器我们被调函数不需要保存，直接覆盖也可以（原因是caller-save寄存器在caller主调函数中有保存）

> Caller-save和callee-save是一种主调函数和被调函数之间的约定，哪些由谁来保存

<aside>
⚠️ 寄存器的保存不是一个一定要做的事情，如果主调函数没有使用任何被调函数中使用的寄存器，那么可以跳过这一步

</aside>

《2》局部变量的内存分配

函数体内使用的局部变量是分配在栈上的，如果我们要使用栈上的空间来保存局部变量，只需要移动栈顶的指针即可（增加就是分配空间，减少就是回收空间）

```bash
subl $8 %esp ；在栈上分配了8个字节大小的空间
```

如果在函数运行一开始就可以把所有局部变量都分配好当然是最好的，这就是为什么C语言在之前的版本要求所有的变量都必须在函数体开始进行声明，这样的话我们就不用担心栈会被破坏（比如在被调函数体内再次调用其他函数，新的被调函数可以直接安排在我们分配完变量之后的空间上）

假设我们保存了Callee-save的寄存器 %ebx，并且在函数中使用了8个字节的变量空间，那么此时栈的内容如下所示：

```bash
参数N                     <---------N*4+4(%ebp)
参数N-1
...
参数2
参数1                       <---------8(%ebp)
主调函数的返回地址            <---------4(%ebp)
主调函数的ebp值 %ebp          <-------- (%ebp)
%ebx                        <----------4(%ebp)
局部变量1                    <--------8(%ebp)
局部变量2                    <--------12(%ebp) (%esp)
```

- （3）运行后清理阶段

被调函数执行完成后，它会做以下事情：

1. 把函数的返回结果保存在%eax之中
2. 回收它自己使用的栈空间（给 esp加上一个值）
3. 恢复之前保存的callee-save的值（如：popl %ebx）
4. 恢复 %esp和%ebp的值
5. 调用 ret 把 eip的值恢复到主调函数接下去要执行的指令（类似于 pop eip）

4，5步的代码如下图所示

```bash
movl %ebp, %esp  #把栈顶的指针设置成原来被调函数还未开始前的位置
popl %ebp        #恢复主调函数的base pointer
ret              #恢复eip指针，跳转到主调函数中待执行的下一条语句继续执行
```

> 第2和3步并不是必须的，如果我们没有保存任何callee-save寄存器变量的话，按照我们上面的示例，如果没有保存%ebx，那么我们第4步当用%ebp给%esp赋值的时候，实际上已经起到了%esp增加一个值的效果了（也就是第2步不需要了）

## 4. 为什么需要ebp

ebp标识着一个栈帧的最低地址，通过ebp的偏移（由于ebp是固定的），我们往小地址方向可以拿到函数的参数，往大地址方向可以拿到被调函数的内部变量，使用ebp是一种惯常的做法，但是在x64程序中没有再使用ebp，因此可以说这是一种约定俗成的做法。更多关于ebp的讨论参考：[汇编中为什么需要帧指针%ebp?]([汇编中为什么需要帧指针%ebp? - 知乎 (zhihu.com)](https://www.zhihu.com/question/284579060)

## 5. 参考资料

1. 栈和函数调用 [](https://www.cnblogs.com/tsiangleo/p/4921707.html)[栈和函数调用 - 凝静志远 - 博客园](https://www.cnblogs.com/tsiangleo/p/4921707.html)
2. Is the value of EBP before the main function important? [](https://reverseengineering.stackexchange.com/questions/19571/is-the-value-of-ebp-before-the-main-function-important)https://reverseengineering.stackexchange.com/questions/19571/is-the-value-of-ebp-before-the-main-function-important
3. 【主要参考资料】 Understanding how function call works [](https://zhu45.org/posts/2017/Jul/30/understanding-how-function-call-works/)https://zhu45.org/posts/2017/Jul/30/understanding-how-function-call-works/栈和函数调用 [](https://www.cnblogs.com/tsiangleo/p/4921707.html)[栈和函数调用 - 凝静志远 - 博客园](https://www.cnblogs.com/tsiangleo/p/4921707.html)
4. 
