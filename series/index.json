[{"content":"1. 概述 项目的组织结构是一个工程项目中在设计之初就需要决定的内容，在Go语言中有一些列关于工程代码组织的良好实践，本文列举一些相关的内容，方便在实际开发中使用\n2. 最小标准布局 这个是一个经典的最小化的布局方式，如下图所示：\n//Go项目根目录 - go.mod - LICENSE - xx.go - yy.go - ... 或者\n- go.mod - LICENSE - package1 - package1.go - package2 - package2.go 3. 构建可执行程序为目的的Go结构 4. 以库为目的的Go项目结构 ","description":"","id":0,"section":"posts","tags":null,"title":"Go语言项目结构","uri":"https://fanhestyle.github.io/posts/go%E9%A1%B9%E7%9B%AE%E7%9A%84%E7%BB%84%E7%BB%87/"},{"content":"1. 概述 在阅读Go编程语言开发时，发现文中提及一个筛质数的程序，初看感觉很难理解，经过一些分析之后，记录于此\n整段代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 // send 2,3,4, ... to channel \u0026#39;ch\u0026#39; func Generate(ch chan\u0026lt;- int) { for i := 2; ; i++ { ch \u0026lt;- i //send \u0026#39;i\u0026#39; to channel \u0026#39;ch\u0026#39; } } // copy values from channel \u0026#39;in\u0026#39; to channel \u0026#39;out\u0026#39; // remove those divisible by \u0026#39;prime\u0026#39; func Filter(in \u0026lt;-chan int, out chan\u0026lt;- int, prime int) { for { i := \u0026lt;-in //receive from \u0026#39;in\u0026#39; if i%prime != 0 { out \u0026lt;- i //send \u0026#39;i\u0026#39; to \u0026#39;out\u0026#39; } } } func main() { ch := make(chan int) go Generate(ch) for i := 0; i \u0026lt; 10; i++ { prime := \u0026lt;-ch fmt.Print(prime, \u0026#34;\\n\u0026#34;) ch1 := make(chan int) go Filter(ch, ch1, prime) ch = ch1 } } 算法的思想如下：\n假设有一个数n,已知小于n的所有质数的集合是arr,如果arr中的每个质数都不能够整除n，则n就是质数。这是因为任意一个合数都可以分解成质数的乘积。\n例如，\n因为 2 是质数，初始化 arr=[2]；\n当n=3，3 % 2 != 0, 则 n=3是质数, arr=[2,3]；\n当n=4，4 % 2 == 0, 不满足要求，则4不是质数， arr不变；\n当n=5,，5 % 2 != 0, 5 % 3 != 0, 则 n=5是质数， arr=[2,3,5];\n\u0026hellip; 依此类推\n2. 程序运行逻辑 初始情况下启动Generate协程，这个协程会一直产生自然数，从2开始，依次是2,3,4,5\u0026hellip;\nFilter是一个死循环的函数，它用来将可以被自身整除的数过滤掉，转到下一个Filter去处理\n我们可以把Filter中的参数prime想象成是Filter这个”对象“的属性，这个属性是一个质数，Filter就是用来过滤可以被这个prime整除的数值\n我们需要搞清楚，在Filter函数中的in是由谁传入的，out传出之后又是由谁来取得的\n看代码逻辑\nfor i := 0; i \u0026lt; 10; i++ { prime := \u0026lt;-ch //[1] fmt.Print(prime, \u0026#34;\\n\u0026#34;) ch1 := make(chan int) //[2] go Filter(ch, ch1, prime) //[3] ch = ch1 //[4] } 代码从[1]开始，首先从ch中取出的数是2，由于2是质数，因此会新建一个Filer过滤器协程，并且把prime=2传入进去，那么in是怎么传入的呢？第一个协程Filter的ch是由Generate传入的，它的值是 ch=3\n之后再Prime=2的Fileter协程中，它会产生一个out参数（也就是ch1），这个ch1的第一个值一定是3，（因为3不能被2整除，于是会传出一个ch1=3的值），并且这个3一定是质数【原因我们上面提到的算法思想中已经描述过了】，于是3被赋值给prime，程序进行下一轮的循环，接着3被打印出来\n然后我们再启动下一个Fileter，传入prime=3，也就是这个新的Filter协程是 prime=3的协程，之后这个协程传入的ch从何而来呢？我们发现这个新的ch是来自于上一个协程的ch1，也就是prime=3的Filter协程待处理的ch元素来自于上一个协程prime=2的Filter协程，由于第一个值已经被prime读取了，因此prime=3的协程等待的是下一个值\n但是这下一个值又是从源头Generate过来的ch=4，这个值会首先经过prime=2的Filter过滤一下，然后再经过prime=3的Filter，由于4可以被2整除，于是再prime=2的Filter中就已经被剔除了4，因此Generate会产生下一个值5，在这段时间内，prime=3的Filter是出于阻塞状态的，它的协程由于channel获取不到值而处于阻塞状态。当5经过prime=2的Filter之后，会传入到prime=3的Filter，又会从prime=3的Filter被传出去到out，此时程序进入到下一轮的循环之中，于是会产生新的prime=5的Filter，以此类推\u0026hellip;\n我们发现整个程序运行过程中，产生了一个从源头Generate的数，经过每一个质数Filter协程的过滤，最终如果成功通过，那么又会产生一个新的已这个通过的值作为prime的Fitler，依次进行，知道程序循环终止\n3. 总结 ch=ch1的时候，原先的ch并没有消失，还被之前启动的fliter协程保存着。 巧妙使用通道的性质，将多个协程进行串联。 最开始以为是一个并行的筛选质数的代码，结果并不是，其实是串行执行 参考资料 一个有趣的求解质数的golang代码 - 简书 (jianshu.com)\ngolang并发素数筛-并发真的会快吗？ - 张小凯的博客 (jasonkayzk.github.io)\n","description":"","id":1,"section":"posts","tags":null,"title":"Go筛质数","uri":"https://fanhestyle.github.io/posts/go%E6%99%92%E8%B4%A8%E6%95%B0/"},{"content":"1. 概述 本文主要介绍Redis中的事件处理机制，使用的源码是Redis 0.07，也就是Redis第一个提交的版本\nRedis中的事件处理在最初版本的时候比较粗糙，比如它使用的IO多路复用的机制是select，相对于之后Redis在Linux平台改进使用epoll的方式，select由于需要在用户态和内核态交互次数太多，效率比较低，另外select可以同时支持的监听事件也有上限。尽管如此，作为第一个实现，我们可以从中一窥redis事件处理的机制\n2. 事件处理原理 在Redis中事件处理是在 void aeMain(aeEventLoop *eventLoop); 函数中实现的，它的代码比较简单\n1 2 3 4 5 6 void aeMain(aeEventLoop *eventLoop) { eventLoop-\u0026gt;stop = 0; while (!eventLoop-\u0026gt;stop) aeProcessEvents(eventLoop, AE_ALL_EVENTS); } 真正的代码在 aeProcessEvents 之中，并且传入的标签是 AE_ALL_EVENTS\n2.1 Redis File事件 在Redis中的事件处理机制支持2种类型的事件：文件事件（File Event）和 时间事件（Time Event），文件事件说白了就是 套接字Socket事件，基本上是套接字的几种类型事件：\n连接到达（监听listen套接字，等待客户端连接）\n读取客户端请求\n写入客户端回复\n2.2 Redis Time事件 Time事件是真正的驱动事件循环一直进行下去的关键，通过不断的修改时间事件发生的时刻，驱动循环不停的进行下去\n3. Redis事件的流转过程 Redis的事件的初始化是在redis.c 文件中，这个是redis服务端的可执行程序，redis维护着一个全局的 server变量（代表着redis服务端），这个server结构体中包含一个时间循环的 aeEventLoop 对象（就是事件队列），aeEventLoop中包含有File事件队列和Time事件队列\n1 2 3 4 5 6 typedef struct aeEventLoop { long long timeEventNextId; aeFileEvent *fileEventHead; aeTimeEvent *timeEventHead; int stop; } aeEventLoop; 在Redis中的事件对象同样类似于Reactor中的方式，有一个处理函数和事件绑定，在发送事件之后会调用这个处理函数\n3.1 初始化 初始化的过程在 redis.c 文件中的main函数中（也就是redis服务端可执行程序的入口点），初始化会加入两个事件对象（添加到aeEventLoop的链表中），这两个事件很显然一个是服务端的Listen套接字，另一个是时间事件对象\nListen套接字的处理函数是：acceptHandler （很显然是阻塞在套接字accept调用）\nTime事件的处理函数是：serverCron（一个定时循环的事件处理函数，会进行内存统计、RDB文件的保存、同步主从节点等各种后台操作，定时1000ms执行一次，也就是1秒钟执行一次）\n3.2 执行 事件的执行流转是在 ae.c 文件中的 aeProcessEvents 函数中进行的， 函数代码较多，贴一部分过来分析\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 int aeProcessEvents(aeEventLoop *eventLoop, int flags) { int maxfd = 0, numfd = 0, processed = 0; fd_set rfds, wfds, efds; aeFileEvent *fileEventHead = eventLoop-\u0026gt;fileEventHead; aeTimeEvent *timeEventHead; long long maxId; AE_NOTUSED(flags); /* Nothing to do? return ASAP */ if (!(flags \u0026amp; AE_TIME_EVENTS) \u0026amp;\u0026amp; !(flags \u0026amp; AE_FILE_EVENTS)) return 0; FD_ZERO(\u0026amp;rfds); FD_ZERO(\u0026amp;wfds); FD_ZERO(\u0026amp;efds); /* Check file events */ if (flags \u0026amp; AE_FILE_EVENTS) { while (fileEventHead != NULL) { if (fileEventHead-\u0026gt;mask \u0026amp; AE_READABLE) FD_SET(fileEventHead-\u0026gt;fd, \u0026amp;rfds); if (fileEventHead-\u0026gt;mask \u0026amp; AE_WRITABLE) FD_SET(fileEventHead-\u0026gt;fd, \u0026amp;wfds); if (fileEventHead-\u0026gt;mask \u0026amp; AE_EXCEPTION) FD_SET(fileEventHead-\u0026gt;fd, \u0026amp;efds); if (maxfd \u0026lt; fileEventHead-\u0026gt;fd) maxfd = fileEventHead-\u0026gt;fd; numfd++; fileEventHead = fileEventHead-\u0026gt;next; } } /* Note that we want call select() even if there are no * file events to process as long as we want to process time * events, in order to sleep until the next time event is ready * to fire. */ if (numfd || ((flags \u0026amp; AE_TIME_EVENTS) \u0026amp;\u0026amp; !(flags \u0026amp; AE_DONT_WAIT))) { int retval; aeTimeEvent *shortest = NULL; struct timeval tv, *tvp; if (flags \u0026amp; AE_TIME_EVENTS \u0026amp;\u0026amp; !(flags \u0026amp; AE_DONT_WAIT)) shortest = aeSearchNearestTimer(eventLoop); if (shortest) { long now_sec, now_ms; /* Calculate the time missing for the nearest * timer to fire. */ aeGetTime(\u0026amp;now_sec, \u0026amp;now_ms); tvp = \u0026amp;tv; tvp-\u0026gt;tv_sec = shortest-\u0026gt;when_sec - now_sec; if (shortest-\u0026gt;when_ms \u0026lt; now_ms) { tvp-\u0026gt;tv_usec = ((shortest-\u0026gt;when_ms+1000) - now_ms)*1000; tvp-\u0026gt;tv_sec --; } else { tvp-\u0026gt;tv_usec = (shortest-\u0026gt;when_ms - now_ms)*1000; } } else { /* If we have to check for events but need to return * ASAP because of AE_DONT_WAIT we need to se the timeout * to zero */ if (flags \u0026amp; AE_DONT_WAIT) { tv.tv_sec = tv.tv_usec = 0; tvp = \u0026amp;tv; } else { /* Otherwise we can block */ tvp = NULL; /* wait forever */ } } retval = select(maxfd+1, \u0026amp;rfds, \u0026amp;wfds, \u0026amp;efds, tvp); if (retval \u0026gt; 0) { fileEventHead = eventLoop-\u0026gt;fileEventHead; while(fileEventHead != NULL) { int fd = (int) fileEventHead-\u0026gt;fd; if ((fileEventHead-\u0026gt;mask \u0026amp; AE_READABLE \u0026amp;\u0026amp; FD_ISSET(fd, \u0026amp;rfds)) || (fileEventHead-\u0026gt;mask \u0026amp; AE_WRITABLE \u0026amp;\u0026amp; FD_ISSET(fd, \u0026amp;wfds)) || (fileEventHead-\u0026gt;mask \u0026amp; AE_EXCEPTION \u0026amp;\u0026amp; FD_ISSET(fd, \u0026amp;efds))) { int mask = 0; if (fileEventHead-\u0026gt;mask \u0026amp; AE_READABLE \u0026amp;\u0026amp; FD_ISSET(fd, \u0026amp;rfds)) mask |= AE_READABLE; if (fileEventHead-\u0026gt;mask \u0026amp; AE_WRITABLE \u0026amp;\u0026amp; FD_ISSET(fd, \u0026amp;wfds)) mask |= AE_WRITABLE; if (fileEventHead-\u0026gt;mask \u0026amp; AE_EXCEPTION \u0026amp;\u0026amp; FD_ISSET(fd, \u0026amp;efds)) mask |= AE_EXCEPTION; fileEventHead-\u0026gt;fileProc(eventLoop, fileEventHead-\u0026gt;fd, fileEventHead-\u0026gt;clientData, mask); processed++; /* After an event is processed our file event list * may no longer be the same, so what we do * is to clear the bit for this file descriptor and * restart again from the head. */ fileEventHead = eventLoop-\u0026gt;fileEventHead; FD_CLR(fd, \u0026amp;rfds); FD_CLR(fd, \u0026amp;wfds); FD_CLR(fd, \u0026amp;efds); } else { fileEventHead = fileEventHead-\u0026gt;next; } } } } /* Check time events */ if (flags \u0026amp; AE_TIME_EVENTS) { timeEventHead = eventLoop-\u0026gt;timeEventHead; maxId = eventLoop-\u0026gt;timeEventNextId-1; while(timeEventHead) { long now_sec, now_ms; long long id; //跳过无效事件（理论上无法产生） if (timeEventHead-\u0026gt;id \u0026gt; maxId) { timeEventHead = timeEventHead-\u0026gt;next; continue; } //如果当前事件大于或等于事件的事件，那么执行这些事件 aeGetTime(\u0026amp;now_sec, \u0026amp;now_ms); if (now_sec \u0026gt; timeEventHead-\u0026gt;when_sec || (now_sec == timeEventHead-\u0026gt;when_sec \u0026amp;\u0026amp; now_ms \u0026gt;= timeEventHead-\u0026gt;when_ms)) { int retval; id = timeEventHead-\u0026gt;id; retval = timeEventHead-\u0026gt;timeProc(eventLoop, id, timeEventHead-\u0026gt;clientData); /* After an event is processed our time event list may * no longer be the same, so we restart from head. * Still we make sure to don\u0026#39;t process events registered * by event handlers itself in order to don\u0026#39;t loop forever. * To do so we saved the max ID we want to handle. */ if (retval != AE_NOMORE) { aeAddMillisecondsToNow(retval,\u0026amp;timeEventHead-\u0026gt;when_sec,\u0026amp;timeEventHead-\u0026gt;when_ms); } else { aeDeleteTimeEvent(eventLoop, id); } timeEventHead = eventLoop-\u0026gt;timeEventHead; } else { timeEventHead = timeEventHead-\u0026gt;next; } } } return processed; /* return the number of processed file/time events */ } 整个过程是这样的：\n（1）首先需要搜集一下文件队列中是不是存在需要select的事件\n（2）如果存在的话，我们需要找一个合适的阻塞时间，这里就涉及到select函数的参数中最后一个timeval，它的含义如下：\nselect最后一个参数timeout的设置情况：\n永远等待，设置 NULL 等待一个固定的时长，正常设置值即可 完全不等待，只是轮询一遍（timeval的两个成员都必须设置为0） 这里的做法是：寻找距离当前时间最近的下一个时间事件之间的空隙，依次作为我们想阻塞的时长，这样就避免了我们干扰后续是时间事件的执行（但是实际上是会干扰的，因为我们的文件事件的处理不可能不耗时），但是如果阻塞期间一直没有事件过来，那么我们在到时间后也会继续往下执行，这样正好下一个时间事件也可以被执行了（相当于我们没有阻塞时间事件）\n（3）如果我们监听到了文件事件（socket事件）一般是有新的连接到达，新的客户端连接的请求过来，这样我们会调用之前注册的函数处理客户端socket事件\n（4）处理之后我们会进入到时间处理部分\n时间处理中我们会查看已经超过当前时间是事件，并处理它们\n（5）如果处理函数返回的是-1（NO_MORE），那么我们删除该时间事件（表明只有一次）\n事实上在0.07的代码中这种类型的事件不存在\n（6）如果处理函数返回一个值，那么我们把这个值加到处理过的事件上，生成一个新的“未来”的事件，于是保证了时间事件队列中永远有事件存在，因此程序会一直被驱动无限循环下去\n那么时间事件循环是如何跳出的呢？如果我们检测到当前事件小于时间事件队列中的值，说明时间事件还未到来，此时我们跳出了时间事件循环部分，进入到外层的循环 mainLoop中，只要stop != 0，会继续开始事件循环\n","description":"","id":2,"section":"posts","tags":null,"title":"Redis事件处理","uri":"https://fanhestyle.github.io/posts/redis%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%860.07/"},{"content":"1. 概述 本文继续解析源码，解析的源码是 cipher.go文件\nInitial commit 443dd019075b8367fd6db8a07d2967ecacbb855a cipher.go cipher.go主要提供一个函数 pickCipher，简单来说就是选择一个加密算法用于通信。关于加密算法这一块又是一个比较大的话题\n密码学是现代网络应用的基石，我们在如今的网络世界中几乎无时无刻不在使用者加密，比较常见的是日常上网使用的https协议就是典型的密码学的应用，本文不打算大篇幅的从头开始论述整个加密/解密的理论，网络上有一篇非常完成的文章可以阅读(常用密码技术 | 爱编程的大丙) ，这篇文章对整个我们目前能够用到的密码学方面的知识进行了完整系统的介绍，相信比我在这里引用论述一遍更好\n我们先看一下这个函数的原型\n1 func pickCipher(name string, key []byte) (core.StreamConnCipher, core.PacketConnCipher, error) 可以看到这个函数的参数是：\nname：指定一种解密算法的名称，我们日常使用的加密名称列表：\nxchacha20-ietf-poly1305 chacha20-ietf-poly1305 aes-256-gcm aes-192-gcm aes-128-gcm key：指定一个密钥\n由于算法都需要密钥这个参数，因此我们需要指定一下（其实类似于我们平常登录网站的密码）\n由于后续代码中都设计到core模块中的加解密部分，因此我们先跳转到去剖析 core包中的加解密模块\n2. 解析core包 Initial commit 443dd019075b8367fd6db8a07d2967ecacbb855a 对应文件： core/doc.go core/packet.go core/stream.go 2.1 doc.go 该文件就一行代码，package core\n应该是作者想写注释来着\n2.2 packet.go 这个包提供一个定义，把PacketConnCipher定义成一个函数，这个函数的作用是对参数中的net.PacketConn进行一次封装\n1 type PacketConnCipher func(net.PacketConn) net.PacketConn 我们可以看看这个文件中的另一个函数\n1 2 3 4 func ListenPacket(network, address string, ciph PacketConnCipher) (net.PacketConn, error) { c, err := net.ListenPacket(network, address) return ciph(c), err } 可以看到它的作用是将一个标准的UDP的连接，加上了一层封装，从字面值的意思来看应该是将一个标准的UDP的连接转换成加密的UDP连接。目前这里面涉及的都是抽象接口层的操作，具体使用的时候我们需要传入具体的加密算法构建的PacketConnCipher函数\n2.3 stream.go 既然有报式套接字的UDP加密，那么怎么能少的了流式套接字TCP呢，就在stream.go这个文件中\n该文件中定义了一个类型，类似于packet.go文件中定义的 PacketConnCipher，都是为标准的TCP或者UDP提供一层薄薄的加密加密封装\n1 type StreamConnCipher func(net.Conn) net.Conn 接着这个类实现了TCP进行通信的3个常用函数\nListen\nAccept\nDial\n3. 网络编程基础知识环节 在看到上面的core包之后，如果初学者可能对此一头雾水，完全不知道如何下手了。事实上这是由于缺失网络知识这一环节，如果是作为100%的新手，那么需要恶补的知识可就多了，首先建议去找一本《计算机网络》的知识去学习，本文就不赘述这部分内容了。先打好基础\n如果对网络有所了解，那么需要了解TCP-UDP编程的内容，特别是针对golang中如何进行tcp/udp编程，其实golang中的tcp-udp编程基本上就是 一个标准库 net 库，如果需要加强了解这方面的内容，可以去阅读 《Network Programming with go》Introduction | Network Programming with Go (golang)\n关于TCP-UDP这部分编程的内容我就不讲了，因为讲解也是从网络上搬运一些内容到这里，意义不大，我写这一系列文章是引导读者去一步步了解自己完成整个项目需要哪些知识点，以及如何获取这些知识点，我不可能把所有内容都聚集于此，这样一方面内容太繁杂，脱离了本项目的中心，另一方面还是引导读者去自己发现学习。 建议不熟悉的读者一定要恶补这一块知识点，才能接着往下学\n4. shadowaead包解析 Initial commit 443dd019075b8367fd6db8a07d2967ecacbb855a 对应文件： shadowaead/doc.go shadowaead/packet.go shadowaead/stream.go 4.1 doc.go 在doc.go中作者给出了一大段的关于这个包中是如何封装TCP和UDP的，简单论述一下。首先本包实现了对TCP-UDP协议中数据的AEAD保护，关于AEAD是什么，可以在网络上搜索一下，也可以查看下面的视频了解一下 What Are AEAD Ciphers? - YouTube\nAEAD 对TCP报文的封装 （1）TCP报文以一个随机数开始，随机数每发送一次自增1\n（2）每一个记录都是加密的，一个报文中可以包含多个记录\n（3）记录中的长度是加密的，记录也是加密的\nAEAD对UDP报文的封装 （1）UDP是一个报文一个报文独立加密，和TCP不同，这些报文之间没有任何关系\n（2）一个TCP报文加密以一个随机数开头\n（3）接下来就是加密的载荷体\n整体的加密格式如下图所示\nTCP UDP 4.2 stream.go 这个文件主要是用来对流式套接字进行封装，将未加密的流按照4.1中给出的设置方法进行封装，主要的两个方法是reader提供的Read和writer提供的Write\n1 2 3 4 func (r *reader) Read(b []byte) (int, error) func (w *writer) Write(b []byte) (int, error) 4.3 packet.go 这个文件主要是用来对报式套接字进行封装，主要定义了一个结构体，该结构体仅仅对读写的套接字和加密方法进行简单的封装\n1 2 3 4 type packetConn struct { net.PacketConn cipher.AEAD } 之后使用Pack和Unpack对于即将发送和接收到的报文进行加密和解密，加密和解密的方法在4.1 doc.go 中有详细的说明\n1 2 3 func Pack(dst, plaintext []byte, aead cipher.AEAD) ([]byte, error) func Unpack(dst, pkt []byte, aead cipher.AEAD) ([]byte, error) ","description":"","id":3,"section":"posts","tags":null,"title":"Go-Shadowsocks源码解析2","uri":"https://fanhestyle.github.io/posts/goshadowsocks_003/"},{"content":"1. 简介 git提交版本号 443dd019075b8367fd6db8a07d2967ecacbb855a Initial commit 解析文件：main.go 本文件的主要作用是应用程序的入口地址main函数，代码主要是解析用户传入的命令行参数，基于这些参数来构建客户端/服务端\n本课主要内容：\ngolang标准库 flag\ngolang标准库 time\ngolang标准库 os/signal\ngolang标准库 encoding/hex\ngolang标准库strings\n2. 标准库之flag 标准库flag是用来解析命令行参数的，这个库对于绝大多数不那么复杂的项目来说足矣，如果需要更加强大的命令行解析库，可以使用以下这些golang的三方库\nCobra\nKingpin\ngo-flags\n等等，本文仅仅论述标准库中flag的用法\n2.1 flag命令行语法 golang标准flag库支持的命令行比较简单，支持以下几种：\n-flag --flag // double dashes are also permitted -flag=x -flag x // non-boolean flags only 也就是说golang支持的 -和\u0026ndash;（单划线和双划线）的一样的效果，这一点可能和Linux中一般短命令和长命令不同有所区别，另外golang的flag也不支持非中划线的命令（比如 iproute2中类似子命令等方式的命令 ：如ip route）\n另外对于命令的参数：\n布尔类型支持：1, 0, t, f, T, F, true, false, TRUE, FALSE, True, False（也就是指定bool类型的时候用 -flag=1 -flag=true等都是同样的效果）\n日期类型支持所有time.ParseDuration可以解析的类型\n2.2 flag库的使用 一般来说我们可以有两种捕获变量设值的方式：\n方式一：返回类型的指针（比如示例中返回int*）\n1 var nFlag = flag.Int(\u0026#34;n\u0026#34;, 1234, \u0026#34;help message for flag n\u0026#34;) 方式二：直接传入指针\n1 2 var flagvar int flag.IntVar(\u0026amp;flagvar, \u0026#34;n\u0026#34;, 1234, \u0026#34;help message for flag n\u0026#34;) 建议用方式二去处理，相对来说比较简单，并且我们可以把结构体内的变量传过去，方便我们将多个命令行参数组织成一个结构体去管理\n2.3 flag库的实例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 var config struct { A string B int C float64 D time.Duration } func main() { flag.StringVar(\u0026amp;config.A, \u0026#34;a\u0026#34;, \u0026#34;hello\u0026#34;, \u0026#34;param A using -a and default value hello\u0026#34;) flag.IntVar(\u0026amp;config.B, \u0026#34;b\u0026#34;, 10, \u0026#34;param B using -b and default value 10\u0026#34;) flag.Float64Var(\u0026amp;config.C, \u0026#34;c\u0026#34;, 3.5, \u0026#34;param C using -c and default value 3.5\u0026#34;) flag.DurationVar(\u0026amp;config.D, \u0026#34;d\u0026#34;, time.Duration(time.Second*5), \u0026#34;param A using -d and default value 30s\u0026#34;) //我们可以在用户给出错误参数的时候使用flag.Usage打印出用法提示 //flag.Usage() flag.Parse() fmt.Println(\u0026#34;Your Input:\u0026#34;) fmt.Printf(\u0026#34;A = %v\\n\u0026#34;, config.A) fmt.Printf(\u0026#34;B = %v\\n\u0026#34;, config.B) fmt.Printf(\u0026#34;C = %v\\n\u0026#34;, config.C) fmt.Printf(\u0026#34;D = %v\\n\u0026#34;, config.D) } 3. 标准库之time time库是用来处理时间的库，时间包含有“时钟时间和单调时间”两类，在golang中当需要打印输出时间的时候，会使用时钟时间，但是当需要做计时时，使用的是单调时间。在golang中的time里面一般会包含有两种计时类型（时钟时间+单调时间），但是某些time包中的函数调用会导致这两种类型中的单调时钟被隐式的丢弃，这一点需要注意。time.Time结构体的定义如下：\n1 2 3 4 5 type Time struct { wall uint64 //挂钟 ext int64 //单调时钟 loc *Location //时区 } 在内部实现中，wall的64位的最高位是标识是否存在单调时钟，如果最高bit位是1，那么表示存在单调时钟，否则表示不存在单调时钟（当不存在单调时钟时，字段ext的含义会发生变化，不再表示单调时钟，而是作为挂钟从公元0年开始的秒数）\n3.1 时间库的使用 获取当前时间 1 t := time.Now() 使用Now()函数获取的时间包含有挂钟+单调时钟2部分，但是使用time.Unix、time.Parse、time.Date获取的时钟是没有单调时钟的\n获取特定时区的当前时间 方法一：设置TZ环境变量为某个时区比如（America/New_York）之后再运行 time.Now\n就可以获得当前设置了环境变量TZ是时区时间\n方法二：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 func main() { t := time.Now() fmt.Println(t) loc, err := time.LoadLocation(\u0026#34;America/New_York\u0026#34;) if err != nil { fmt.Println(\u0026#34;load time location failed:\u0026#34;, err) return } t1 := t.In(loc) fmt.Println(t1) } 可以使用这种方式完成任意时区时间的转换\n时间的比较 由于时间的 == 和 != 会比较结构体成员，因此可能会出现两个地球上相同的时间，却由于处于不同的时区导致结果不相等的情况（这有违于人们的直觉），因此时间不适合作为map的键值存在\n在time包中提供了比较两个时间的方法 time.Equal 以及 time.Before time.After这几个方法，比较逻辑如下：\n（1）如果两个时间都包含单调时间，那么直接比较单调时间，返回\n（2）如果不都包含单调时间，那么比较挂钟的秒和纳秒的部分\n另外计算时间间隔的函数Sub也是同样的逻辑\n定时器的使用 time包中最有价值的内容是提供了定时器，golang中提供2种定时器：\n（1）timer：只触发一次\n（2）ticker：周期性触发\n定时器创建有3种方式：\n（1）使用AfterFunc\n1 2 3 4 5 func create_timer_by_afterfunc() { _ = time.AfterFunc(1*time.Second, func() { fmt.Println(\u0026#34;timer created by after func fired\u0026#34;) }) } （2）使用NewTimer\n1 2 3 4 5 6 7 func create_timer_by_newtimer() { timer := time.NewTimer(2 * time.Second) select { case \u0026lt;-timer.C: fmt.Println(\u0026#34;timer created by newtimer fired\u0026#34;) } } （3）使用After\n1 2 3 4 5 6 func create_timer_by_after() { select { case \u0026lt;-time.After(2 * time.Second): fmt.Println(\u0026#34;timer created by after fired\u0026#34;) } } 4. 标准库之Signal 4.1 信号分类 无法捕获的信号 SIGKILL和SIGSTOP\n同步信号：SIGBUS, SIGFPE, SIGSEGV，golang处理方式runtime panic\n异步信号：\n丢失控制终端：SIGHUP\nSIGINT：用户在控制终端按下 Ctrl+C\nSIGQUIT： 用户按下 Ctrl + \\ （反斜杠）\n4.2 go信号默认行为 一般遇到的大部分信号都是转换为run-time panic，进而导致程序直接退出。我们为什么要处理信号呢？\n原因大体是因为我们大部分时间用go都是编写后台程序，后台程序一般来说是Daemon程序，因此有许多通信都是通过系统发送过来的信号来完成的，比如我们的后台程序在捕获到系统给的信号之后（比如用户键入Ctrl+C等操作），如果我们使用系统默认对于信号的处理，那么很可能导致我们程序正常结束需要的一些清理工作没能完成，从而造成数据的不一致等问题。\n因此在实际生产环境中，不要忽略对于系统信号的处理，采用捕捉信号后退出的方式执行自定义的收尾工作\n4.3 Go的信号包 os/signal （1）Go会将异步信号捕获之后，将信号写入到channel，然后我们应用程序就可以拿到这个channel对信号进行处理\n（2）Go会将同步信号捕获之后，触发panic，然后我们应用程序决定如何处理这个panic\n一般来说同步信号是非常严重的硬件/总线等错误，go就无法简单的通过channel传递，而是直接panic，如果用户层没有recovery的代码，那么GO程序默认就会异常退出\n我们尝试通过一个实例来展示同步、异步、无法捕获信号的运行机制\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 func catchAsyncSignal(c chan os.Signal) { for { s := \u0026lt;-c fmt.Println(\u0026#34;收到异步信号\u0026#34;, s) } } func triggerSyncSignal() { time.Sleep(3 * time.Second) defer func() { if e := recover(); e != nil { fmt.Println(\u0026#34;恢复panic: \u0026#34;, e) return } }() var a, b = 1, 0 fmt.Println(a / b) } func main() { var wg sync.WaitGroup c := make(chan os.Signal, 1) signal.Notify(c, syscall.SIGFPE, syscall.SIGINT, syscall.SIGKILL) wg.Add(2) go func() { catchAsyncSignal(c) wg.Done() }() go func() { triggerSyncSignal() wg.Done() }() wg.Wait() } 如果我们的应用程序在收到信号之后，没来得及处理，那么是否可以之后接收到所有的信号呢？（也就是问：信号是否会排队）\n事实上我们由于使用了channel，如果channel是没有缓冲的，那么信号就只能够发送一次，否则信号回去填满缓冲区，之后我们从channel中也可以读到所有写入到缓冲区的信号\n4.4 使用信号让程序优雅退出 主要是使用Notify来捕获我们最常见的几个信号\nSIGINT\nSIGTERM\nSIGQUIT\nSIGHUP\n1 2 3 4 5 6 7 8 9 func main() { quit := make(chan os.Signal, 1) signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM, syscall.SIGQUIT, syscall.SIGHUP) \u0026lt;-quit } 这里仅仅给出一个例子，我们可以基于这个quit的channel，通过读取它来在我们自定义的函数内做更多的工作\n5. 标准库之encoding/hex encoding/hex是go提供的用来进行十六进制编码/解码的工具包，首先我们了解一下十六进制如何进行编码：\n比如以下字符串： 1fg*\n（1）字符串用它的ASCII表示，因为每一个字符都是8位，必定在0-255之间，于是肯定可以写成两个16进制的数，比如 1在ASCII中的值是49，转换成十六进制就是31，f是ASCII中的102，转换成十六进制就是66，因此以此类推，都可以转换\n1 2 3 4 5 func main() { someString := \u0026#34;1fg*\u0026#34; // input: [1 f g *] str := hex.EncodeToString([]byte(someString)) // 内部实现:AsciiDecimalToHexadecimal fmt.Println(str) // output: 3166672a } 反过来，我们可以反向的将一段文本转换成字符串\nfunc main() { someString := \u0026#34;0a\u0026#34; // input: 0a data, _ := hex.DecodeString(someString)// 内部核心实现核心代码AsciiHexadecimalToDecimal fmt.Println(data) // output: [10] } 小结 我们可以看出原始的字符串由于可打印的字符，其实它的取值范围更小（小于127），转码成十六进制之后里面的字符只有0-9+a-f这些数字和字母的组合\n反向的解码之后的字符串中就是包含有数字、字母、符号等可被打印的字符\n6. string包 由于string包就是字符串的包，这一个包在各种语言中几乎都有，并没有什么特别之处，因此不再这里详细论述\n至此本文件中涉及的所有golang依赖的知识点都已经讲解完成，后续我们看详细的代码！\n7. 整体分析 基础知识看完之后，我们分析源码main.go中的内容\n整个main文件用来解析命令行参数，并根据不同的参数有不同的调用，整个框架如下图所示：\n在程序的最后一段代码是监听用户按下的Ctrl+C等信号，方便我们结束程序\n1 2 3 sigCh := make(chan os.Signal, 1) signal.Notify(sigCh, syscall.SIGINT, syscall.SIGTERM) \u0026lt;-sigCh 参考资料 golang的hex包 ","description":"","id":4,"section":"posts","tags":null,"title":"Go-Shadowsocks源码解析1","uri":"https://fanhestyle.github.io/posts/goshadowsocks_002/"},{"content":" 0. 缘起 说起学习golang有一段经历简单聊一下，我平常有听podcast的习惯，之前一直对科技类podcast比较感兴趣，偶然间听到了由吴涛和Rio主持的KernelPanic的节目，之后一直跟着听过来，感觉节目非常的不错，自己作为一个从事IT相关的从业者也是从其他专业转过来的，在节目中了解到了非常多的工具、开发方法开阔了自己的视野。\n在节目中Rio经常会提到的一门语言就是golang，其实我自己很早就比较好奇。但是由于自己的开发工作大部分都是使用C++，并且平常的工作之余也有其他事务缠身，因此一直放下来没去了解。最近抽了些时间对golang整体上学了一遍，感觉大体上的语法和简单的使用是会了，不过缺少项目的历练。之后发现Rio自己有维护GoShadowSocks2的项目，加上我平常由于查阅资料等的需要，因此也接触了类似的工具。一直比较好奇这些底层是如何实现的，因此借此作为一个练手项目自己从头开始把整个项目走一遍，同时记录学习过程中的一些经历，如果有哪位朋友误打误撞访问到这个站点并且也对此感兴趣，并且碰巧也是一位小白的话，我希望自己的这点感悟对你有所帮助\n话说我自己使用vim编辑器也是受了二位的布道，O(∩_∩)O哈哈~\n1. 概述 这是一系列的Blog，从一个golang的初学者一步步跟着goshadowsocks2(https://github.com/shadowsocks/go-shadowsocks2) 这个项目来剖析它的源码，期间涉及到的标准库、其他第三方的知识，都会一一详细的给出解释，算是自己记录学些golang的历程\n","description":"","id":5,"section":"posts","tags":null,"title":"Go-Shadowsocks源码解析0","uri":"https://fanhestyle.github.io/posts/goshadowsocks_001/"},{"content":" 1. 概述 本节主要讲述操作系统中线程和进程的实现原理，以及如何进行线程与进程的切换，本节是操作系统中相对比较难的内容，也是操作系统的精髓之一，必须要掌握，否则操作系统学了等于白学。\n2. 内核级线程实现原理 线程在实现中通常使用一个PCB的结构体来标识，这个PCB结构体相当于线程的一个『身份证』，一个简单的定义如下：\n1 2 3 4 5 6 7 8 /* 进程或线程的pcb,程序控制块 */ struct task_struct { uint32_t* self_kstack; // 内核线程的0级栈顶指针 enum task_status status; //线程的状态：比如阻塞还是运行还是就绪 uint8_t priority; // 线程优先级 char name[16]; //线程名称 uint32_t stack_magic; // 用这串数字做栈的边界标记,用于检测栈的溢出 }; 关于这个self_kstack需要着重的说一下，它是线程在内核态时候使用的栈顶指针，一个线程可以包含有用户态和内核态的代码，类似下图\n当线程代码在用户态运行时，使用的是用户态的栈，当线程代码在内核态运行时，使用的是内核态的栈，这个self_kstack变量就是内核态的栈顶指针\n3. 内核线程实现细节 我们在进行代码分析时，最好能知道程序的流程走向，这样跟着流程顺藤摸瓜便于理解，否则如果流程不清楚，那么就会脑子里一片混乱，我们先看一下最终调用线程的代码（注意到目前为止我们还未实现用户进程，因此这时候实现的线程实际上是内核中的几个线程之前的切换，不涉及用户进程、用户线程等内容）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 int main(void) { init_all(); thread_start(\u0026#34;k_thread_a\u0026#34;, 31, k_thread_a, \u0026#34;argA \u0026#34;); thread_start(\u0026#34;k_thread_b\u0026#34;, 8, k_thread_b, \u0026#34;argB \u0026#34;); intr_enable(); // 打开中断,使时钟中断起作用 while(1) { put_str(\u0026#34;Main \u0026#34;); }; return 0; } void k_thread_a(void* arg) { char* para = arg; while(1) { put_str(para); } } void k_thread_b(void* arg) { char* para = arg; while(1) { put_str(para); } } 可以看到我们首先创建了两个线程k_thread_a和k_thread_b以及原有的Main主线程共3个线程，程序运行的效果是：乱序的是处Main、argA、argB这三个字符串。我们的程序为什么可以输出？是什么驱动着它运行的呢？\n事实上是intr_enable这一行代码驱动它运行的，这行代码打开了中断，是的时钟中断执行 整个运转流程如下：\n于是我们的三个进程开始轮流的切换打印输出了。\n3.1 进程切换细节1 关于切换还有更深的细节需要了解，我们需要理解清楚：假设我们当前执行的是主线程Main，那么它是怎么被切换成k_thread_a线程的呢？切换的细节如下：\n上图给出了进行线程切换的总体细节，其实时钟中断不断发生，在一个线程调度中一直在进行，当时间片未耗尽时，中断处理函数仅仅是将时间片减少1就退出了，但是一旦时间片耗尽，那么在耗尽之后的中断处理程序里就要切换线程了，切换的核心是schedule函数，它会调用switch_to汇编编写的代码，借助于栈上的一些内容进行骚操作，让线程返回的时候返回到k_thread_a（同时把Main线程插入到线程就绪队列的尾部，等待再次调度）\n3.2 深入前的思考 在3.1中提到的骚操作（对栈中元素的偷龙转凤），细节还需要明晰一下，实际上这里面包含有多个内容需要理解清楚：\n（1）假设从Main切换到k_thread_a，但是k_thread_a从来就没有被调度过（第一次被调度），那么会如何处理？\n（2）假设从Main切换到k_thread_a，并且k_thread_a已经被调度过了，那么会如何处理？\n我们分两种情况分别讨论一下，在讨论之前有一些前置的知识需要了解，这个前置的知识点就是：\n如何进行C语言和汇编的互相调用，互相调用有什么需要注意的地方？ 3.3 关于C语言和汇编的互相调用 我们需要理解什么是C调用约定，什么是x86中调用的ABI约定，简单来说就是在通过栈传递参数的时候有一套约定，比如参数入栈顺序，主调函数和被调函数对于寄存器中哪些寄存器需要进行保存和恢复，关于这些内容请参考书中的描述，这里不在赘述。\n3.4 进程切换细节2 我们这里先来讨论第一种情况：\n如果Main线程切换到 k_thread_a线程，并且k_thread_a线程是第一个被调度，那么如何处理？ 这里有一个误区需要特别提出来：在《操作系统真象还原》中关于线程切换的讲解中给出了2个结构体\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 struct intr_stack { uint32_t vec_no; //低地址，表示后入栈的元素 uint32_t edi; uint32_t esi; uint32_t ebp; uint32_t esp_dummy; // 虽然pushad把esp也压入,但esp是不断变化的,所以会被popad忽略 uint32_t ebx; uint32_t edx; uint32_t ecx; uint32_t eax; uint32_t gs; uint32_t fs; uint32_t es; uint32_t ds; uint32_t err_code; void (*eip)(void); uint32_t cs; uint32_t eflags; void *esp; uint32_t ss; }; 和另外一个结构体\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 struct thread_stack { //以下寄存器是由于ABI的约定，被调方必须备份 //因为主调方可能使用了这些寄存器 //主要包括寄存器：%ebx、%esi和%edi，以及%ebp和%esp uint32_t ebp; uint32_t ebx; uint32_t edi; uint32_t esi; /* 线程第一次执行时,eip指向待调用的函数kernel_thread 其它时候,eip是指向switch_to的返回地址*/ void (*eip)(thread_func *func, void *func_arg); /***** 以下仅供第一次被调度上cpu时使用 ****/ /* 参数unused_ret只为占位置充数为返回地址 */ void (*unused_retaddr); thread_func* function; void *func_arg }; 我在阅读这一段的时候非常的不解，因为我们了解到中断发生的时候，如果发生特权级的变化，那么中断入栈的内容中会包含ss和esp，但是如果中断是在内核中发生的，未发生特权级别的变化，那么就不会入栈ss和esp，那么声明intr_stack中的\nvoid *esp; uint32_t ss; 字段一直存在，这不会造成混乱吗？\n另外还有一个问题是关于 thread_stack ，注释中有一段\n/***** 以下仅供第一次被调度上cpu时使用 ****/ /* 参数unused_ret只为占位置充数为返回地址 */ 是什么意思，为什么只有第一次运行有效的内容会在结构体中，那后续运行这些内容会不会造成程序的问题呢？\n解答：经过我多次的阅读和分析，我大概知道是什么原因了，实际上这里有点误导的嫌疑： 我们在思考的时候常常使用C语言或者C++等高级语言的方式来思考，一般我们会认为一个结构体 定义出来它是有用的，会一直存在，我们在任何时候可以改变这个结构体的内容，但是新的改变 它的数据肯定也是和这个结构体一模一样的数据方式。但是这里显然不是这样的，这里定义的 结构体实际上仅仅是一个占位而已，我们要保证我们的栈指针范围够大，可以容纳所有我们存储 的寄存器就可以，我们下次运行的时候这个结构体就不存在了，仅仅第一次占位有用，之后当 我们再调度的时候就不需要了。 再举个例子，如下图：\n以上解释了这两个定义的结构体都是第一次有用，它们尽可能的列举了当前栈中需要开辟的空间，后续的线程切换压入栈中的内容和这两个结构体中定义的成员可能不一致（比如有些成员就没有了）\n下面我们根据函数调用的流程，结合C语言的函数调用和汇编的互相调用这些知识点夹杂在一起，捋一捋整个流程，是如何将线程进行切换的（注意：这里的线程切换还仅仅是内核之间线程的切换，没有涉及到进程的切换，没有涉及到用户线程（或进程）和系统级线程（进程）之间的切换，这些内容在后文中会讲解）\n由于图太大，我分成多幅图来绘制\n继续下图绘制栈的情况，前面所绘制的都是主线程Main的内容，当我们执行switch_to的汇编代码之后，栈被进行了切换\n3.5 进程切换细节3 我们上面在3.4中讨论的是k_thread_a第一次被Main线程调度的情况，当k_thread_a已经被调度起来后，那么当它再次和Main主线程相互调度时候是什么样子的呢？\n应该如下图所示：\n至此关于内核级线程的切换便讲清楚了！\n","description":"","id":6,"section":"posts","tags":null,"title":"第12课 线程的切换","uri":"https://fanhestyle.github.io/posts/%E7%AC%AC12%E8%AF%BE-%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A2/"},{"content":" 1. 概述 本文主要讲解操作系统中内存的管理方式，内存管理分为物理内存管理和虚拟内存管理，并且需要建立二者之间的关联。\n2. 管理框架 总的框架如下所示：\n3. 内存申请函数解析 在内存管理中，我们采用一种位图映射管理的方式，每一个位图的位标识一页内存块，位图类型声明如下：\n1 2 3 4 5 6 7 8 9 10 11 #define BITMAP_MASK 1 struct bitmap { uint32_t btmp_bytes_len; //位图的字节长度 uint8_t* bits; //位图的起始位置（单字节指针，类似于char*) }; void bitmap_init(struct bitmap* btmp); bool bitmap_scan_test(struct bitmap* btmp, uint32_t bit_idx); int bitmap_scan(struct bitmap* btmp, uint32_t cnt); void bitmap_set(struct bitmap* btmp, uint32_t bit_idx, int8_t value); 位图中有一个非常重要的函数，它用来返回是否存在连续的N个位（也就是我们是否可以申请连续的N块内存），实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 /* 判断bit_idx位是否为1,若为1则返回true，否则返回false */ bool bitmap_scan_test(struct bitmap* btmp, uint32_t bit_idx) { uint32_t byte_idx = bit_idx / 8; // 向下取整用于索引数组下标 uint32_t bit_odd = bit_idx % 8; // 取余用于索引数组内的位 return (btmp-\u0026gt;bits[byte_idx] \u0026amp; (BITMAP_MASK \u0026lt;\u0026lt; bit_odd)); } /* 在位图中申请连续cnt个位,成功则返回其起始位下标，失败返回-1 */ int bitmap_scan(struct bitmap* btmp, uint32_t cnt) { uint32_t idx_byte = 0; // 用于记录空闲位所在的字节 /* 先逐字节比较,蛮力法 */ while (( 0xff == btmp-\u0026gt;bits[idx_byte]) \u0026amp;\u0026amp; (idx_byte \u0026lt; btmp-\u0026gt;btmp_bytes_len)) { /* 1表示该位已分配,所以若为0xff,则表示该字节内已无空闲位,向下一字节继续找 */ idx_byte++; } ASSERT(idx_byte \u0026lt; btmp-\u0026gt;btmp_bytes_len); if (idx_byte == btmp-\u0026gt;btmp_bytes_len) { // 若该内存池找不到可用空间 return -1; } /* 若在位图数组范围内的某字节内找到了空闲位， * 在该字节内逐位比对,返回空闲位的索引。*/ int idx_bit = 0; /* 和btmp-\u0026gt;bits[idx_byte]这个字节逐位对比 */ while ((uint8_t)(BITMAP_MASK \u0026lt;\u0026lt; idx_bit) \u0026amp; btmp-\u0026gt;bits[idx_byte]) { idx_bit++; } int bit_idx_start = idx_byte * 8 + idx_bit; // 空闲位在位图内的下标 if (cnt == 1) { return bit_idx_start; } uint32_t bit_left = (btmp-\u0026gt;btmp_bytes_len * 8 - bit_idx_start); // 记录还有多少位可以判断 uint32_t next_bit = bit_idx_start + 1; uint32_t count = 1; // 用于记录找到的空闲位的个数 bit_idx_start = -1; // 先将其置为-1,若找不到连续的位就直接返回 while (bit_left-- \u0026gt; 0) { if (!(bitmap_scan_test(btmp, next_bit))) { // 若next_bit为0 count++; } else { count = 0; } if (count == cnt) { // 若找到连续的cnt个空位 bit_idx_start = next_bit - cnt + 1; break; } next_bit++; } return bit_idx_start; } 这个函数实现的效果如下图所示：\n4. 内存管理之虚拟内存管理 我们的虚拟内存需要被管理起来，管理虚拟内存的代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 /* 在pf表示的虚拟内存池中申请pg_cnt个虚拟页, * 成功则返回虚拟页的起始地址, 失败则返回NULL */ static void* vaddr_get(enum pool_flags pf, uint32_t pg_cnt) { int vaddr_start = 0, bit_idx_start = -1; uint32_t cnt = 0; if (pf == PF_KERNEL) { bit_idx_start = bitmap_scan(\u0026amp;kernel_vaddr.vaddr_bitmap, pg_cnt); if (bit_idx_start == -1) { return NULL; } while(cnt \u0026lt; pg_cnt) { bitmap_set(\u0026amp;kernel_vaddr.vaddr_bitmap, bit_idx_start + cnt++, 1); } vaddr_start = kernel_vaddr.vaddr_start + bit_idx_start * PG_SIZE; } else { // 用户内存池,将来实现用户进程再补充 } return (void*)vaddr_start; } 按照我们之前的分析，可以计算出分配的虚拟地址页的最小内存地址。\n5. 使用虚拟地址访问页目录和页表 我们在内存管理中进行操作时，不可避免的要访问到页表和页目录，由于我们在进入分页模式之后，代码中给出的地址都必须是虚拟的地址，这样就造成一种尴尬的情况：我们如何访问页目录和页表呢？实际上我们由两种方式：\n（1）我们将页表和页目录放在低1MB的内存中，由于我们分页页目录的第一项的页表和内存中的低1MB一一对应，因此我们如果把页目录和页表放在低1MB的内存中时，我们可以直接通过物理地址进行访问（因为这样设定之后低1MB的虚拟地址==物理地址）\n（2）由于我们之前的设计中没有采用（1）中的做法，而是把页目录和页表放在了1MB的上方。那么我们还可以怎么做呢？我们在页目录中的1023索引项(最高项也就是第1024项)中写入了页目录自身的物理地址，这样做带来的一个作用是：\n我们可以通过某些组合，让CPU的分页机制把页目录当成页表来处理，这样我们就可以索引到页目录和页表，达到我们可以操作它们的目的。具体做法如下：\n1 2 3 4 5 6 7 uint32_t* pte_ptr(uint32_t vaddr) { uint32_t* pte = (uint32_t*)(0xffc00000 + \\ ((vaddr \u0026amp; 0xffc00000) \u0026gt;\u0026gt; 10) + \\ PTE_IDX(vaddr) * 4); return pte; } 给我们一个地址vaddr（注意是虚拟地址），我们可以根据这个vaddr的地址，来生成一个新的虚拟地址，这个新生成的虚拟地址就是vaddr地址所在页表的虚拟地址，我们可以操作这个返回的虚拟地址，这样就相当于我们在操作页表一样\n以上代码是怎么做到的呢？\n我们需要特别注意：构造的新的new_vaddr地址的高10位是11111111，这样索引到自身，另外中间的10位也是 11111111，同样索引到自己，这两步实际上是利用页部件的转换，我们欺骗页部件，让它以为我们在找页表项的物理地址，实际上我们第一步和第二步都索引到了页目录自己，这样CPU任务我们的页目录是一个普通的页表，于是最后一步（注意啦）最后一步是拿到原始地址vaddr的中间10位，中间10位正好是在正常转换中索引页表的部分（最后一步并不是取vaddr的最低12位，以前我不知道为什么先入为主的认为是最低12位吗，这样就解释不同），最低端的12位我们是用vaddr的中间10位*4，正好模拟的是正常页部件转换中获取页表项地址的操作，于是我们得到了一个新的虚拟地址new_vaddr，通过这个地址访问到的是vaddr所在页表项的物理地址。\n另一个与之对应的函数时如何访问页目录项的物理地址（也就是页表的物理地址）\n1 2 3 4 5 6 /* 得到虚拟地址vaddr对应的pde的指针 */ uint32_t* pde_ptr(uint32_t vaddr) { /* 0xfffff是用来访问到页表本身所在的地址 */ uint32_t* pde = (uint32_t*)((0xfffff000) + PDE_IDX(vaddr) * 4); return pde; } 同样也是前两步欺骗页部件，最后的低12位是原始 vaddr的最高10位\n","description":"","id":7,"section":"posts","tags":null,"title":"第11课 内存管理","uri":"https://fanhestyle.github.io/posts/%E7%AC%AC11%E8%AF%BE-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"},{"content":" 1. 概述 本来想将特权级单独来讲解，但是考虑到特权级和中断的关系，因此将二者结合起来讲解，因为中断很大一个原因是我们想通过中断门来实现调用操作系统提供的功能，这样自然就涉及到了特权级的提升，因此二者之间有着莫大的联系\n2. 中断的分类 中断可以分为内部中断和外部中断，\n内部中断\n可屏蔽的内部中断\n不可屏蔽的内部中断\n外部中断\n可屏蔽的外部中断\n不可屏蔽的外部中断\n可以这样说，操作系统之所以可以提供如此强大的功能就是有赖于中断，操作系统是正常运转都是由中断驱动的\n3. 中断描述符 中断描述符是一种描述符，大小是8个字节，它记录了中断处理程序的入口地址，这样当硬件接收到中断号时，可以使用这个中断号去中断描述符表中获取中断描述符，然后根据这个中断描述符查找到中断处理程序，最终完成对中断的处理\n4. 中断的处理过程 整的中断过程分为CPU外和CPU内两部分。\nCPU外：外部设备的中断由中断代理芯片接收，处理后将该中断的中断向量号发送到CPU。\nCPU内：CPU执行该中断向量号对应的中断处理程序。\n中断外的处理一般是使用代理芯片进行处理（比如8259A）我们暂不关心，重点关注CPU内部的处理，因为这是我们真正需要编码的地方，整个过程如下：\n（1）处理器根据中断向量号定位中断门描述符\n中断向量号 * 8 + IDT的基地址 = 中断描述符\n（2）处理器进行特权级检查\n当前特权级CPL必须在门描述符DPL和门中目标代码段DPL之间。这是为了防止位于3特权级下的用户程序主动调用某些只为内核服务的例程\n（3）通过检查后，在中断描述符中拿到段描述符的基址和偏移地址，获取到最终运行代码的位置，并将其装载到CS和EIP中，执行相应的中断处理程序\n5. 中断处理过程中的压栈操作 中断在发生时，处理器收到一个中断向量号，根据此中断向量号在中断描述符表中找到相应的中断门描述符，门描述符中保存的是中断处理程序所在代码段的选择子及在段内偏移量，处理器从该描述符中加载目标代码段选择子到代码段寄存器CS及偏移量到指令指针寄存器EIP。注意，由于CS加载了新的目标代码段选择子，处理器不管新的选择子和任何段寄存器（包括CS）中当前的选择子是否相同，也不管这两个选择子是否指向当前相同的段，只要段寄存器被加载，段描述符缓冲寄存器就会被刷新，处理器都认为是换了一个段，属于段间转移，也就是远转移。所以，当前进程被中断打断后，为了从中断返回后能继续运行该进程，处理器自动把CS和EIP的当前值保存到中断处理程序使用的栈中。不同特权级别下处理器使用不同的栈，至于中断处理程序使用的是哪个栈，要视它当时所在的特权级别，因为中断是可以在任何特权级别下发生的。除了要保存CS、EIP外，还需要保存标志寄存器EFLAGS，如果涉及到特权级变化，还要压入SS和ESP寄存器。\n6. 中断处理结束后的出栈操作 处理器进入中断执行完中断处理程序后，还要返回到被中断的进程，这是进入中断的逆过程。中断返回是用iret指令实现的。Iret，即interrupt ret，此指令专用于从中断处理程序返回，假设在32位模式下，它从当前栈顶处依次弹出32位数据分别到寄存器EIP、CS、EFLAGS。iret指令并不清楚栈中数据的正确性，它只负责把栈顶处往上的数据，每次4字节，对号入座弹出到相关寄存器，所以在使用iret之前，一定要保证栈顶往上的数据是正确的，且从栈顶往上的顺序是EIP、CS、EFLAGS，根据特权级是否有变化，还有ESP、SS。\n","description":"","id":8,"section":"posts","tags":null,"title":"第10课 中断和特权级","uri":"https://fanhestyle.github.io/posts/%E7%AC%AC10%E8%AF%BE-%E7%89%B9%E6%9D%83%E7%BA%A7/"},{"content":" 1. 概述 本文介绍在汇编语言中的函数调用以及汇编和C的函数调用互操作的一些内容，我们假设C语言和汇编进行相互操作，那么情况有如下几种：\nC语言调用C语言所写的函数\nC语言调用汇编语言所写的函数\n汇编语言调用C语言所写的函数\n汇编语言调用汇编语言所写的函数\n对于1，C语言调用C语言都是编译器替我们处理好的，我们不用关心\n对于2，本文重点讨论\n对于3， 也是编译器帮助我们处理好，我们只需要让C的函数是导出的(extern)，那么汇编调用即可\n对于4， 编写方式可以任意，因为都是汇编语句，不需要遵循任何规则，当然我们也可以把被调用的汇编函数仿造C语言的风格来写，不过这都无所谓\n2. 调用约定 在汇编和C语言互操作的过程中，我们需要了解到调用底层ABI的一些知识。首先汇编和C语言互操作，它们的参数传递是采用栈的方式进行的。也就是说传递的参数调用方需要把参数入栈，被调用方得从栈中取出参数，这就涉及到一个问题了，栈中参数的形态是怎样的？\n另外在函数调用过程中寄存器会发生变化，我们是否要备份寄存器呢？这些都是问题\n实际上在x86的架构中有多种处理方式，这些处理方式被称为调用约定，我们主要讲一下C语言的调用约定，一般称为 cdel，约定如下：\n1. 参数使用栈传递 2. EAX，ECX，EDX由被调用者保存 3. 其余寄存器由被调用者保存 4，函数返回值存储在EAX中 5. 栈清理工作由调用者清理 6. 参数的传递方式是从右往左进行入栈 3. cdecl 函数调用过程 3.1 主调函数调用 （1）将所有调用参数压栈 （2）调用call指令 在被调函数执行中，被调函数可能会修改一些寄存器的值，导致我们主调函数当前的寄存器值会被覆盖（%ebp除外），因此如果我们在调用函数前有需要保存的寄存器值，那么我们必须在push参数之前，对这些寄存器进行压栈操作\n在被调函数开始执行前，当前进程中的栈如下图所示：\n1 2 3 4 5 6 参数N 参数N-1 ... 参数2 参数1 主调函数的返回地址 \u0026lt;----- (%esp) # 返回地址是我们主调函数call func的下一条指令 3.2 被调函数执行 这一过程分为3步：\n（1）运行代码前准备阶段\n（2）运行代码阶段\n（3）运行代码后的清理阶段\n其中（1）（3）对于所有函数调用都是一样的，只有（2）根据每个函数不同的功能而有差别（毕竟每个函数执行的作用是我们自己写的，各不相同）\n（1） 运行前准备阶段 设置阶段以下两条指令会被立刻执行\n1 2 pushl %ebp movl %esp %ebp 第一条指令用来备份当前的base pointer（也就是栈帧指针 frame pointer）%ebp，然后通过esp把当前被调函数的栈顶指针赋值给它。\nebp的作用非常关键，它起到了两个重要的作用：在其上是被调函数要使用的参数，而在其下是被调函数在函数体内声明的一些局部变量，而在ebp当口指向的就是上一个主调函数的ebp的备份值，于是ebp起到一个承上启下的作用，既可以获取函数传入的实参（高地址），又可以获取函数内部声明的局部变量（低地址），而它自己指向的地址是主调函数的ebp，并且 ebp也标识着当前被调函数的最高的地址（也就是当前栈帧的栈帧底部，esp指向当前栈帧的最高顶部） 那么ebp最原始的值是什么呢？也就是第一个启动整个进程的ebp的初始值，在参考资料2中给出的回答是：它的初值是0，在程序被装入内存的时候（elf文件的入口点被加载时，指向了一条指令 xor ebp, ebp\n准备阶段结束时的栈如下图所示：\n1 2 3 4 5 6 7 参数N \u0026lt;---------N*4+4(%ebp) 参数N-1 ... 参数2 参数1 \u0026lt;---------8(%ebp) 主调函数的返回地址 \u0026lt;---------4(%ebp) 主调函数的ebp值 %ebp \u0026lt;-------- (%ebp) = (%esp) （2）运行代码阶段 代码运行阶段就是开始实质性的执行我们所写的功能了，这个过程会涉及到几个事情：\n《1》保存寄存器的值\n一般我们会把寄存器分为几类，比如\n(a) eax, edx, ecx被称之为caller-save寄存器\n(b) ebx, esi, edi 称之为callee-save寄存器\n我们在开始执行代码的时候，第一步需要保存这些callee-save寄存器的值，在执行完函数返回之前恢复这些寄存器的值，而caller-save寄存器我们被调函数不需要保存，直接覆盖也可以（原因是caller-save寄存器在caller主调函数中有保存）\nCaller-save和callee-save是一种主调函数和被调函数之间的约定，哪些由谁来保存\n⚠️ 寄存器的保存不是一个一定要做的事情，如果主调函数没有使用任何被调函数中使用的寄存器，那么可以跳过这一步 《2》局部变量的内存分配\n函数体内使用的局部变量是分配在栈上的，如果我们要使用栈上的空间来保存局部变量，只需要移动栈顶的指针即可（增加就是分配空间，减少就是回收空间）\n1 subl $8 %esp ；在栈上分配了8个字节大小的空间 如果在函数运行一开始就可以把所有局部变量都分配好当然是最好的，这就是为什么C语言在之前的版本要求所有的变量都必须在函数体开始进行声明，这样的话我们就不用担心栈会被破坏（比如在被调函数体内再次调用其他函数，新的被调函数可以直接安排在我们分配完变量之后的空间上）\n假设我们保存了Callee-save的寄存器 %ebx，并且在函数中使用了8个字节的变量空间，那么此时栈的内容如下所示：\n1 2 3 4 5 6 7 8 9 10 参数N \u0026lt;---------N*4+4(%ebp) 参数N-1 ... 参数2 参数1 \u0026lt;---------8(%ebp) 主调函数的返回地址 \u0026lt;---------4(%ebp) 主调函数的ebp值 %ebp \u0026lt;-------- (%ebp) %ebx \u0026lt;----------4(%ebp) 局部变量1 \u0026lt;--------8(%ebp) 局部变量2 \u0026lt;--------12(%ebp) (%esp) （3）运行后清理阶段 被调函数执行完成后，它会做以下事情：\n把函数的返回结果保存在%eax之中 回收它自己使用的栈空间（给 esp加上一个值） 恢复之前保存的callee-save的值（如：popl %ebx） 恢复 %esp和%ebp的值 调用 ret 把 eip的值恢复到主调函数接下去要执行的指令（类似于 pop eip） 4，5步的代码如下图所示\n1 2 3 movl %ebp, %esp #把栈顶的指针设置成原来被调函数还未开始前的位置 popl %ebp #恢复主调函数的base pointer ret #恢复eip指针，跳转到主调函数中待执行的下一条语句继续执行 第2和3步并不是必须的，如果我们没有保存任何callee-save寄存器变量的话，按照我们上面的示例，如果没有保存%ebx，那么我们第4步当用%ebp给%esp赋值的时候，实际上已经起到了%esp增加一个值的效果了（也就是第2步不需要了）\n4. 为什么需要ebp ebp标识着一个栈帧的最低地址，通过ebp的偏移（由于ebp是固定的），我们往小地址方向可以拿到函数的参数，往大地址方向可以拿到被调函数的内部变量，使用ebp是一种惯常的做法，但是在x64程序中没有再使用ebp，因此可以说这是一种约定俗成的做法。更多关于ebp的讨论参考：[汇编中为什么需要帧指针%ebp?](汇编中为什么需要帧指针%ebp? - 知乎 (zhihu.com)\n5. 参考资料 栈和函数调用 栈和函数调用 - 凝静志远 - 博客园 Is the value of EBP before the main function important? https://reverseengineering.stackexchange.com/questions/19571/is-the-value-of-ebp-before-the-main-function-important 【主要参考资料】 Understanding how function call works https://zhu45.org/posts/2017/Jul/30/understanding-how-function-call-works/栈和函数调用 栈和函数调用 - 凝静志远 - 博客园 ","description":"","id":9,"section":"posts","tags":null,"title":"第9课 函数调用","uri":"https://fanhestyle.github.io/posts/%E7%AC%AC9%E8%AF%BE-%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/"},{"content":" 1. 概述 本文即将开始加载最简易的内核代码，我们将控制权从Bootloader继续转交给下一棒的操作系统。\n我们的操作系统大部分使用C语言来开发，通过C语言开发生成的是可执行的ELF文件，由此带来一个问题是：我们需要解析我们生成的ELF文件，并把程序的代码和数据拷贝到内存中的指定位置，也就是说：\n（1）编译生成的操作系统是一个ELF的文件，我们需要解析它，也就是需要熟悉ELF格式\n（2）我们把ELF文件读入到内存中，我们需要指定一个保存这个映像的位置\n（3）在读入操作系统映像后，我们最终可执行的操作系统指令和数据与读取进来的映像是有差别的，我们还需要把这个映像进行“解压”，得到真正的操作系统指令和数据\n2. ELF文件 ELF（Executable and Linkable Format）是一种广泛使用在类Unix操作系统中的文件，它的文件结构分为ELF头，Programmable部分以及Sector部分，关于ELF更详细的介绍可以参考网络上专门讲ELF的内容\n3. 系统内核代码 我们最简单的系统内核代码只有一行代码\n1 2 3 4 5 6 //文件名main.c int main(void) { while(1); return 0; } 首先我们需要将其编译成可执行文件，由于我们是在编写操作系统，因此肯定是不可以使用C运行时库的，于是我们不能这样做：\ngcc main.c -o kernel.bin 因为这样去生成kernel.bin的过程中GCC会帮我们链接到C runtime库，我们正确的做法是使用AS和LD工具自行编译链接\n4. 内核的加载 在概述部分我们已经讲述了加载操作系统的过程，根据代码中的描述，加载之后的内存布局如下：\n","description":"","id":10,"section":"posts","tags":null,"title":"第8课 加载最简易的内核和ELF文件","uri":"https://fanhestyle.github.io/posts/%E7%AC%AC8%E8%AF%BE-%E5%8A%A0%E8%BD%BD%E6%9C%80%E7%AE%80%E6%98%93%E7%9A%84%E5%86%85%E6%A0%B8/"},{"content":" 1. 概述 本文主要讲解一下在x86 32位下的分页内存管理，分页机制使得我们不再直接使用和操作物理内存，而是为每一个任务（进程）分配一个独立4G空间的内存，在透过CPU提供的段页式内存管理机制，实现将我们使用的虚拟内存地址转换到实际的物理内存，这一课相对来说难度较大\n2. 分页管理的过程 2.1 内存地址转换方式 分页管理之前的内存处理 在分页管理之前我们使用的是段式内存管理，这其中也分为两种：\n实模式下的内存寻址：段地址左移4位 + 偏移地址 = 最终的物理地址\n保护模式下的寻址：段选择子\u0026ndash;\u0026gt;获取到段基址 + 偏移地址 = 最终的物理地址\n我们可以看到：所有获取到的最终都是物理地址\n开启分页之后的内存处理 在开启分页机制之后，我们在代码中给出的内存地址都是虚拟地址，虚拟地址也是采用段式的管理方式，我们通过段选择子\u0026ndash;\u0026gt;获取到段基址 + 偏移地址 = 线性地址。开启分页之后获取到的地址是线性地址，还需要将线性地址通过分页机制才能真正转换成最终的物理地址\n2.2 分页机制 我们首先拿到的是线性地址，它的结构如下：\n31 22 21 12 11 0 +---------------------+---------------------+--------------------+ | | | | | DIR | PAGE | OFFSET | | | | | +---------------------+---------------------+--------------------+ 我们把线性地址划分为3部分：高10位 + 中间10位 + 低12位，它们各有用处，总的转换过程如下图所示：\n需要注意的是：\n（1）CR3控制寄存器中存储的是页目录的物理地址（得到这个地址不需要进行页转换，否则会陷入死循环，一定要用一个地址直接可以直接拿到物理地址方式）\n（2）在页目录表中的页目录项里面存储的也是页表的物理地址（也是直接拿到物理地址，不需要进行页转换）\n2.3 页目录项和页表项 我们知道页目录项中存储的是页表的物理地址，页表项中存储的是物理页框的物理地址 ，那么页目录项和页表项的实际结构是什么样的呢？下图给出\n可以看到页目录项和页表项都是4个字节大小（4Byte = 32位），于是我们可以有下面的结论：\n页目录包含有1024个页目录项，每一个页目录项指向一个页表，一个页目录项的大小是4Byte，一个页目录项指向的页表可以申请的内存是4MB，也就是说一个页目录项对应的真实物理内存是4MB，由于有1024个页目录项，所以二级页目录项对应的物理内存大小是4GB\n每一个页表可以有1024个页表项，一个页表项是4Byte，于是一个页表占据的空间大小就是4x1024 = 4KB，同时一个页表项对应的物理内存大小是4K，于是一个页表对应的物理内存大小就是 4K * 1024 = 4M\n3. 页目录和页表的组织 页目录和页表可以在内存中的任意位置，为了简单我们将页目录和页表放在一起（一个页目录需要4K的空间，所有的页表需要4M的空间），因此我们放在的位置是紧邻 1MB内存的位置\n需要注意的是：页表项并不是所有的都一次性要申请，页目录项也是1个页目录项 可以管理4MB的内存，引入二级页表的原因就是用多少申请多少，上面所说的4K+4M是 极限的情况，也就是分配所有4GB空间的情形，一般来说基本不可能达到 内存中组织的方式如下图所示：\n整个安排是上面的图示，但是具体有一些细节需要注意：\n页目录表最多只有1个，页表可以最多可以有1024个，我们需要合理规划一下；\n我们想把低3GB的地址留给用户进程未来使用，把3G-4G这高1GB的地址留给操作系统使用（注意我们目前正在编写的就是操作系统），也就是说我们会把目前编码的地址映射到虚拟地址的3G-4G上，如何做到这一点呢？\n结合我们上面的页转换有以下的一些规则：\n线性地址的高10位会作为页目录项索引在页目录表中查找；\n线性地址的中10位会作为页表项索引在页表中查找\n线性地址的低10位作为真正的偏移在物理地址中查找\n为了映射3GB开始的内存区域，我们把3GB转换成二进制是：0xC0000000，高10位转换成十进制是 768，也就是说我们只需要在第768项中的页目录中写入页表的物理地址，那么那个页表所对应的线性地址就是3GB以上的，有了这个理论，我们这样去做：\n（1）页目录表的第0项（索引为0）写入页表物理地址\n（2）页目录表的第768项写入页表物理地址，并且我们让写入的值和第0项相同，这样它们就都映射到相同的页表了，由于我们想把这个相同的页表都映射到低1MB内存区域，这样做的好处是：我们可以继续之前未开启分页机制的代码正确运作，也可以未来都使用3GB以上的虚拟地址来访问1MB的物理内存\n小更正：上图中绘制的内存组织方式，实际上在代码中并没有采用这种方式，代码中的页表项只有255项（都是内核占用的，低0-3GB的虚拟地址我们并没有映射页目录项到页表），正确的图示如下：【和代码一致】\n代码部分\n.type setup_page, @function setup_page: //清空页目录表中所有1024项 movl $4096, %ecx movl $0, %esi clear_page_dir_table: movb $0, PAGE_DIR_TABLE_POS(,%esi) incl %esi loop clear_page_dir_table //创建PDE movl $PAGE_DIR_TABLE_POS, %eax addl $0x1000, %eax //ebx指向索引为0的页表的物理地址 movl %eax, %ebx //页目录项中的第0项和第768项指向索引为0的页表 //也就是第0项和第768项的页目录项指向了索引为0的页表 orl $PDE_PTE_FLAG, %eax movl %eax, (PAGE_DIR_TABLE_POS) movl %eax, (PAGE_DIR_TABLE_POS + 0xc00) //页目录项的最后一项(1023索引项)指向页目录表自身 subl $0x1000, %eax movl %eax, (PAGE_DIR_TABLE_POS+4092) //创建PTE //把低1MB的内存物理地址映射到虚拟地址上 //由于每一个页表项可以对应4KB的物理内存，那么1MB的物理内存 //需要的页表项数量 = 1MB / 4k = 1024 / 4 = 256项 movl $256, %ecx movl $0, %esi movl $PDE_PTE_FLAG, %edx create_pte: movl %edx, (%ebx,%esi,4) addl $4096, %edx incl %esi loop create_pte //把剩下的操作系统页目录项填充满 movl $PAGE_DIR_TABLE_POS, %eax addl $0x2000, %eax or $PDE_PTE_FLAG, %eax movl PAGE_DIR_TABLE_POS, %ebx movl $254, %ecx movl $769, %esi create_kernel_pde: movl %eax, (%ebx,%esi,4) inc %esi addl $0x1000, %eax loop create_kernel_pde ret 4. 开启分页 开启分页机制在我们设置页目录表和页表之后，还有一些工作要做，包括\n（1）把页目录表的地址加载到CR3寄存器中（注意是物理地址）\n（2）寄存器CR0的分页位打开（第31位）\n（3）必要的一些段描述符和栈指针的修改【比如映射到3G以上内存中，需要在原来的基础上加上0xC0000000】\n代码如下：\n//读取gdt sgdt gdt_ptr //把基地址读入到%ebx movl (gdt_ptr+2), %ebx orl $0xc0000000, 0x1c(%ebx) addl $0xc0000000, (gdt_ptr+2) addl $0xc0000000, %esp //把页目录表的基地址写入到CR3控制寄存器 movl $PAGE_DIR_TABLE_POS, %eax movl %eax, %cr3 movl %cr0, %eax //打开cr0的pg位（第31位） orl $0x80000000, %eax movl %eax, %cr0 lgdt gdt_ptr ","description":"","id":11,"section":"posts","tags":null,"title":"第7课 内存管理之分页机制","uri":"https://fanhestyle.github.io/posts/%E7%AC%AC7%E8%AF%BE-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B9%8B%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6/"},{"content":" 1. 概述 在我们继续迈进内核编程之前，首先需要能获取到当前硬件的一些信息，首要的信息是物理内存的大小，一般来说可以用BIOS中断0x15实现，分别是BIOS中断0x15的3个子功能，子功能号要存放到寄存器EAX或AX中，这3个子功能分别是：\nEAX=0xE820：遍历主机上全部内存。\nAX=0xE801：分别检测低15MB和16MB～4GB的内存，最大支持4GB。\nAH=0x88：最多检测出64MB内存，实际内存超过此容量也按照64MB返回\n从1到3的功能依次减弱，但是编码难度也是递减的，有时候为了简单获取内存大小，在满足需要的前提下可以使用2或者3完成，编写代码相对容易（主要是1需要额外的类似结构体的方式来存储获取到的信息，相对繁琐）\n2. 代码实现 对于以上提到的这3个子功能的更多参数和使用方式，最好还是去查阅相关的文档，在此如果写下来也是一些技术文档的拷贝，下面给出最后获取物理内存的代码\ntotal_mem_bytes: .long 0 //获取到的结构体类似的块信息存储在ards_buf中 ards_buf: .fill 244 //保存0x15号中断E820号中断返回结构体的个数 ards_nr: .word 0 //代码开始： xorl %ebx, %ebx movl $0x534d4150, %edx movw $ards_buf, %di //调用中断0x15中e820号中断获取内存 e820_mem_get_loop: movl $0x0000e820, %eax movl $20, %ecx int $0x15 jc e820_failed_so_try_e801 addw %cx, %di incw ards_nr cmpl $0, %ebx jnz e820_mem_get_loop movw ards_nr, %cx movl $ards_buf, %ebx xorl %edx,%edx find_max_mem_area: movl (%ebx), %eax addl 8(%ebx), %eax addl $20, %ebx cmpl %eax, %edx jge next_ards movl %eax, %edx next_ards: loop find_max_mem_area jmp mem_get_ok e820_failed_so_try_e801: movw $0xe801, %ax int $0x15 jc e801_failed_so_try88 movw $0x400, %cx mulw %cx shll $16, %edx andl $0x0000FFFF, %eax orl %eax, %edx addl $0x100000, %edx movl %edx, %esi xorl %eax, %eax movw %bx, %ax movl $0x10000, %ecx mull %ecx addl %eax, %esi movl %esi, %edx jmp mem_get_ok e801_failed_so_try88: movb $0x88, %ah int $0x15 jc err_hlt andl $0x0000FFFF, %eax movw $0x400, %cx mulw %cx shll $16, %edx orl %eax, %edx addl $0x100000, %edx mem_get_ok: movl %edx, total_mem_bytes ","description":"","id":12,"section":"posts","tags":null,"title":"第6课 获取物理内存大小","uri":"https://fanhestyle.github.io/posts/%E7%AC%AC6%E8%AF%BE-%E8%8E%B7%E5%8F%96%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E5%A4%A7%E5%B0%8F/"},{"content":" 1. 概述 本文对保护模式代码进行简要的分析，并给出当前内存中的布局，首先给出保护模式加载的代码\n.code16 .include \u0026#34;boot.inc\u0026#34; .section .text LOADER_STACK_TOP = LOADER_BASE_ADDR jmp loader_start GDT_BASE: .long 0x0 .long 0x0 CODE_DESC: .long 0x0000FFFF .long DESC_CODE_HIGH4 DATA_STACK_DESC: .long 0x0000FFFF .long DESC_DATA_HIGH4 //显存段的段基址是0xb8000 //显存段的段界限是 0xbffff-0xb8000 = 0x7fff 粒度是4k //所以计算出的低位数字是 0x7fff/4k = 7 VIDEO_DESC: .long 0x80000007 .long DESC_VIDEO_HIGH4 GDT_SIZE = .-GDT_BASE GDT_LIMIT = GDT_SIZE - 1 .fill 60, 8, 0 //定义3个选择子 //相当于(CODE_DESC - GDT_BASE)/8 + TI_GDT + RPL0 .equ SELECTOR_CODE, (0x0001 \u0026lt;\u0026lt; 3) + TI_GDT + RPL0 .equ SELECTOR_DATA, (0x0002 \u0026lt;\u0026lt; 3) + TI_GDT + RPL0 .equ SELECTOR_VIDEO, (0x0003 \u0026lt;\u0026lt; 3) + TI_GDT + RPL0 gdt_ptr: .word GDT_LIMIT .long GDT_BASE loadermsg: .ascii \u0026#34;2 loader in real.\u0026#34; .equ MSG_SIZE, .-loadermsg loader_start: //调用BIOS打印字符串例程 INT 0x10, 功能号 0x13 movw $LOADER_BASE_ADDR, %sp movw $loadermsg, %bp movw $MSG_SIZE , %cx movw $0x1301, %ax movw $0x001f, %bx movw $0x1800, %dx int $0x10 //准备进入保护模式 //步骤： // 1. 打开A20 // 2. 加载gdt // 3. cr0寄存器第1位置为1 inb $0x92, %al orb $0x2, %al outb %al, $0x92 lgdt gdt_ptr movl %cr0, %eax or $0x1, %eax movl %eax, %cr0 ljmp $SELECTOR_CODE, $p_mode_start .code32 p_mode_start: movw $SELECTOR_DATA, %ax movw %ax, %ds movw %ax, %es movw %ax, %ss movl $LOADER_STACK_TOP, %esp movw $SELECTOR_VIDEO, %ax movw %ax, %gs movb $\u0026#39;P\u0026#39;, %gs:160 jmp . 2. 段描述符的构造 代码中一共构造了3个段描述符，分别是：\n（1）代码段描述符\n（2）数据段描述符\n（3）显存数据段描述符\n另外还有一项是0的描述符，在GDT中的第一项必须是空，这样设计的目的是：一旦我们没有初始化段描述符，会导致CPU访问第一个位置的段描述符，于是CPU可以给出异常中断，于是我们可以根据这个提示修改我们的代码，检查是否是哪个段描述符忘记初始化，避免之后导致严重的错误。\n构造段描述符的方式在之前的课程中有介绍，分别是对8个字节的每一位进行设置（关于段描述符每一位的含义简单介绍一下）\n段描述符 高32位 31--24 基址31-24位 23 G G位(段界限按4k/1B计算) 22 D/B 操作数大小（IP和SP是16位取址0还是32位取址1） 21 L 64位/32位处理器 20 AVL Avaliable保留给应用程序 19--16 段界限19-16位 15 P 存在段，可以置换到硬盘 14--13 DPL 描述符特权级(0-4) 12 S S位（标记是系统段0/非系统段1） 11--8 TYPE 段的属性描述 7--0 段基址23~16位 低32位 31---16 段基址 15~0位 15---0 段界限 15~0位 我们上面的代码构造出的段描述符的特征是：\n（1）第0索引位置：0 段描述符（按照GDT的要求设置一个空的描述符）\n（2）第1索引位置：代码段描述符（采用了平坦模型：也就是段的基址是0，段的偏移地址最大可以到4G）\n（3）第2索引位置：数据/栈段描述符（也采用了平坦模型，段的基址是0，段的偏移地址最大扩展到4G）\n（4）第3索引位置：显存文本显示描述符，它采用的不是平坦模型，它的基址的0xB8000，可以偏移的大小最大扩展到0x7fff（这就是为什么最低为是7，因为0x7fff/4k = 7)\n我们还定义了3个选择子，分别是\nSELECTOR_CODE值是8\nSELECTOR_DATA值是16\nSELECTOR_VIDEO值是24\n正好就是我们的三个描述符相对于GDTR的偏移位置（字节单位），于是我们可以直接使用这三个选择子加载到段寄存器中来操作对应的内存空间\n3. 代码执行后的内存布局 在执行上述代码之后的内存布局如下图所示：\n","description":"","id":13,"section":"posts","tags":null,"title":"第5课 保护模式代码分析","uri":"https://fanhestyle.github.io/posts/%E7%AC%AC5%E8%AF%BE-%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/"},{"content":" 1. 概述 本文开始从实模式进入到保护模式，实模式是指老式的兼容8086的模式，在实模式下各种寄存器的宽度是16位的，程序寻址内存的时候采用的是段地址偏移4位+偏移地址，而进入到保护模式之后，寄存器的宽度大部分都是32位的，并且内存的寻址方式采用 段选择子 + 偏移地址的模式\n实模式寻址方式 保护模式寻址方式 除了上述提到的变化，保护模式还引入了更多的内容，包括任务切换、特权级管理等非常多的内容\n2. 进入保护模式步骤 CPU从刚开始加电运行到加载MBR以及后续的Bootloader都是在实模式下运行的，为了切换到保护模式下，需要以下步骤：\n（1）打开A20\n（2）加载GDT\n（3）CR0寄存器的PE位置为1\n以下一一进行解释：\n2.1 打开A20 为什么要打开A20呢？我们知道在8086模式下CPU可寻址的内存只有1MB，地址总线是20条，于是为了扩展寻址的范围，我们需要突破这个限制，这就是需要打开A20的原因，打开的方式比较简单，只需要读写0x92端口即可\ninb $0x92, %al orb $0x2, %al outb %al, $0x92 2.2 加载GDT 在保护模式下所有内存的访问不再是实模式下的段地址+偏移地址直接进行访问，而是引入了段描述符，段描述符都是8个字节，段描述符是一个总称，保护模式中涉及到的所有和内存相关的概念都与它相关，分类为：\n系统段描述符\n各种门描述符（中断门、陷阱门、调用门、任务门）\nTSS\nLDT\n用户段描述符\n代码段（一致性和非一致性代码段）\n数据段\n段描述符的8个字节（一般划分为高4字节和低4字节）内容如下：\n我们需要按照我们想访问的内存设置几个段描述符（自行组装），然后把段描述符通过 lgdt 指令加载到 GDTR寄存器中\n2.3 CR0中的PE位置为1 CR0是CPU中的一个控制寄存器，它的某些位具有特殊的作用，我们启用保护模式需要打开它的最低位（最低位设置为1），CR0寄存器的结构如下：\n开启方式如下\nmovl %cr0, %eax or $0x1, %eax movl %eax, %cr0 3. 清空流水线 当我们执行完进入保护模式的各种步骤之后，实际上还需要刷新一下流水线，由于CPU的预加载机制，因此导致可能在执行到保护模式下32位指令之前，已经有一部分16位的实模式指令在缓存中，为了让程序可以正确执行之后的语句，可以使用一条远跳转语句来达到刷新流水线的效果，指令如下\nljmp $SELECTOR_CODE, $p_mode_start 至此之后CPU就进入到保护模式下愉快的执行了！\n","description":"","id":14,"section":"posts","tags":null,"title":"第4课 进入保护模式","uri":"https://fanhestyle.github.io/posts/%E7%AC%AC4%E8%AF%BE-%E8%BF%9B%E5%85%A5%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/"},{"content":" 1. 概述 本文开始从MBR进入到第二棒Bootloader，为操作系统的加载做准备\n2. Bootloader 操作系统开发中第一棒是从BIOS进入到MBR，在MBR中只有短短的512字节，并且里面真正的代码部分只有460字节，这对于一个操作系统的加载来说是远远不够的，于是我们需要从MBR中将控制权进一步转交给下一个新的步骤：也就是传递给Bootloader，之后Bootloader可以做一些设置和执行必要的代码，最终真正的将操作系统装载到内存中\n那么Bootloader在什么地方呢？很显然Bootloader应该是存在于磁盘中的，然后通过MBR将Bootloader读取内存中\n3. 磁盘操作 在准备磁盘操作时，需要简要的认识一下磁盘，磁盘（主要是老式的机械硬盘）的结构图如下\n磁盘通过主轴的旋转带动盘片旋转，加上磁头臂的来回移动（带动磁头运动），可以实现让磁头在磁道上移动，从而实现读写数据\n磁盘读写的细节非常繁多，在此就不进行赘述了。（其实我们完全可以利用IVT中提供的中断例程来读写磁盘）\n4. 选择加载位置 通过观察之前的1MB内存的布局，我们决定把bootloader的文件读取后存放在 0x900内存开始处（此值是随意选的，只要满足有足够的空间即可），经过设置之后的内存布局如下图所示：\n整个过程可以描述如下：\n（1）BIOS读取磁盘第1个扇区内容并将512字节的MBR拷贝到内存0x7C00处\n（2）MBR代码读取磁盘第2个扇区内容，并将loader拷贝到内存0x900处\n（3）拷贝完成之后，MBR调用jmp指令跳转到0x900处继续执行loader中的代码\n","description":"","id":15,"section":"posts","tags":null,"title":"第3课 接力第二棒Bootloader","uri":"https://fanhestyle.github.io/posts/%E7%AC%AC3%E8%AF%BE-%E6%8E%A5%E5%8A%9B%E7%AC%AC%E4%BA%8C%E6%A3%92bootloader/"},{"content":" 1. 概述 本文完善之前编写的MBR，使用操作显存的方式来输出字符\n2. 实模式下的内存布局 实模式下我们使用的内存是1MB的内存空间，这是从8086继承下来的遗产，基本上我们最后使用的是80386上的特性，由于需要使用这1MB的内存，介绍以下这1MB内存的布局\n3. 操作显存 通过上面的内存布局，我们可以在显存中写入一些数据，这样显存中写入的数据最终会在屏幕上被打印出来，由于我们编写一个简易的操作系统，因此只关心显存中的文本显示区域，也就是内存地址在(0xB8000\u0026ndash;0xBFFF)这段区域\n在显存中写入数据的时候，我们一般是以2个字节为单位。低字节是字符的ASCII码，高字节是字符属性元信息。在高字节中，低4位是字符前景色，高4位是字符的背景色。颜色用RGB红绿蓝三种基色调和，第4位用来控制亮度，若置1则呈高亮，若为0则为一般正常亮度值。第7位用来控制字符是否闪烁（不是背景闪烁）\n4. 编码 有了上述基础，那么就可以不用借助BIOS中断提供的功能来打印字符，而是直接操作显存来打印，代码如下\n.code16 .section .text movw %cs, %ax movw %ax, %ds movw %ax, %es movw %ax, %fs movw $0x7c00, %sp movw $0xb800, %ax movw %ax, %gs //清屏 movw $0x600, %ax movw $0x700, %bx movw $0x0, %cx movw $0x184f, %dx int $0x10 //显存中写入数据 movb $\u0026#39;1\u0026#39;, %gs:0x0 movb $0xA4, %gs:0x1 movb $\u0026#39; \u0026#39;, %gs:0x2 movb $0xA4, %gs:0x3 movb $\u0026#39;M\u0026#39;, %gs:0x4 movb $0xA4, %gs:0x5 movb $\u0026#39;B\u0026#39;, %gs:0x6 movb $0xA4, %gs:0x7 movb $\u0026#39;R\u0026#39;, %gs:0x8 movb $0xA4, %gs:0x9 jmp . .org 510 .word 0xaa55 ","description":"","id":16,"section":"posts","tags":null,"title":"第2课 完善MBR并使用显存","uri":"https://fanhestyle.github.io/posts/%E7%AC%AC2%E8%AF%BE-%E5%AE%8C%E5%96%84mbr%E4%BD%BF%E7%94%A8%E6%98%BE%E5%AD%98/"},{"content":" 1. 概述 从本文开始我们正式开始编码的工作，首先是所有学习语言的第一个程序”Hello,World\u0026quot;\n2. MBR简介 主引导记录（Master Boot Record）存放在磁盘的于0盘0道1扇区（扇区从1开始计数，这种标记磁盘的方式称为CHS(即柱面Cylinder磁头Header扇区Sector)表示法，另外还有一种称为LBA逻辑区块地址(Logical Block Address表示法)则是从0开始计数的）\n计算机开机上电之后会进行开机自检，自检的过程实际上是运行BIOS里面程序（BIOS程序是写死在ROM之中的代码），BIOS运行的最后一步是读取磁盘中的MBR扇区内容，并将其拷贝到内存0x7C00的位置，以上过程都是固化写死的，不用我们关心\n操作系统的启动类似于一场接力赛，BIOS选手把第一棒将给我们的MBR，从MBR开始之后就是我们需要关心的内容，于是我们需要首先编写MBR，MBR中的内容是固定的，如下图所示：\n目前我们关心的只有第一项：启动代码，后续在进行磁盘管理方面功能开发的时候需要了解第二项\n3. 编写程序 完整的代码如下\n.code16 .section .text movw %cs, %ax movw %ax, %ds movw %ax, %es movw %ax, %fs movw %ax, %gs movw $0x7c00, %sp /* 清屏利用0x06号功能,上卷全部行,则可清屏 中断号：INT x10　功能号:0x06　功能描述:上卷窗口 输入: AH 功能号= 0x06 AL 上卷行数(如果为0，表示全部) BH 上卷行属性 (CL,CH) = 窗口左上角的(X,Y)位置 (DL,DH) = 窗口右下角的(X,Y)位置 无返回值: */ movw $0x600, %ax movw $0x700, %bx movw $0x0, %cx /*VGA文本模式中,一行只能容纳80个字符,共25行， 下标从0开始,所以0x18=24,0x4f=79,DX=0x184f 左上角(0,0)，右下角(80,25) */ movw $0x184f, %dx int $0x10 //以下3行获取光标位置 movb $0x3, %ah movb $0x0, %bh int $0x10 //以下6行打印字符串 movw $message, %ax movw %ax, %bp movw $MSG_LEN, %cx movw $0x1301, %ax movw $0x2, %bx int $0x10 jmp . message: .ascii \u0026#34;Hello,World!\u0026#34; MSG_LEN = . - message .org 510 .word 0xaa55 代码基本上就是清屏和打印字符串的操作，需要注意的是：\n（1）代码中使用的功能来自于BIOS自带的一些中断处理例程（类似于我们使用的一些库函数调用）\n（2）我们生成的文件必须是纯二进制的文件，并且文件的大小固定是512个字节，这样才能满足MBR的要求\n生成文件的可以使用as和ld两个工具编译和链接，使用ld需要编写ld的脚本，由于本系列使用的链接脚本内容不是关注的重点，在此一笔带过。链接是一个庞大的主题，如果深究下去也可以写一个系列，本系列关注操作系统的编写，链接使用的仅仅是最简单的脚本，如下\nSECTIONS { . = 0x7c00; .text : {*(.text)} } OUTPUT_FORMAT(binary) 脚本的作用是让连接器把文件中的符号起始地址设置在0x7c00处，这样我们在使用BIOS把我们的代码加载到0x7C00处运行时就不会出现错误\n4. 编译并运行 编译我们使用了Makefile的脚本，随着工程的逐步壮大，有必要使用Makefile来组织整个项目，代码如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 mbr.bin: mbr.o @ld -T mbr.lds -m elf_i386 mbr.o -o mbr.bin mbr.o: mbr.s @as --32 mbr.s -o mbr.o .PHONY:run,clean run: make clean \u0026amp;\u0026amp; make \u0026amp;\u0026amp; make disk \u0026amp;\u0026amp; bochs disk: @bximage -mode=\u0026#34;create\u0026#34; -hd=60M -imgmode=\u0026#34;flat\u0026#34; -q hd60M.img @dd if=mbr.bin of=hd60M.img conv=notrunc clean: @$(RM) -r *.txt *.o *.bin hd60M.img 运行效果如下：\n","description":"","id":17,"section":"posts","tags":null,"title":"第1课 初识MBR程序HelloWorld","uri":"https://fanhestyle.github.io/posts/%E7%AC%AC1%E8%AF%BE-%E5%88%9D%E8%AF%86mbr%E7%A8%8B%E5%BA%8Fhelloworld/"},{"content":"1. 概述 本文主要介绍任何搭建开发环境，个人使用的开发环境如下：\nmacOS 12.3.1 Monterey Bochs 2.7 Apple clang version 13.0.0 (clang-1300.0.27.3) 2. 搭建开发环境 安装必要的开发工具集\n在MacOS中打开终端，终端中键入gcc，弹出提示框让我们安装开发组件，直接点下载安装即可\n安装Homebrew\n我个人直接使用brew来安装Bochs，因此需要首先安装Homebrew，直接去Homebrew的官网贴一行代码到终端即可安装完成\n安装bochs\n一个命令搞定\nbrew install bochs 3. Bochs环境配置 Bochs安装好之后类似于一台虚拟的电脑已经组装好，但是要启动它还需要进行一些配置（相当于给电脑设置一些硬件参数），Bochs读取这个配置文件的顺序如下：\n1. .bochsrc in the current directory 2. bochsrc in the current directory 3. bochsrc.txt in the current directory 4. (win32 only) bochsrc.bxrc in the current directory 5. (Unix only) .bochsrc in the user\u0026#39;s home directory 6. (Unix only) bochsrc in the /etc directory 首先查看brew将bochs安装的目录\nbrew list bochs 输出如下：\n/usr/local/Cellar/bochs/2.7/bin/bochs /usr/local/Cellar/bochs/2.7/bin/bximage /usr/local/Cellar/bochs/2.7/lib/bochs/ (117 files) /usr/local/Cellar/bochs/2.7/share/bochs/ (30 files) /usr/local/Cellar/bochs/2.7/share/doc/ (8 files) /usr/local/Cellar/bochs/2.7/share/man/ (4 files) 我们可以直接在运行目录下面添加一个bochsrc的文件，文件内容如下：\n第一步，首先设置 Bochs 在运行过程中能够使用的内存，本例为 32MB megs: 32 #第二步，设置对应真实机器的 BIOS 和 VGA BIOS romimage: file=/usr/local/Cellar/bochs/2.7/share/bochs/BIOS-bochs-latest vgaromimage: file=/usr/local/Cellar/bochs/2.7/share/bochs/VGABIOS-lgpl-latest #第三步，设置 Bochs 所使用的磁盘，软盘的关键字为 floppy。 #若只有一个软盘，则使用 floppya 即可，若有多个，则为 floppya，floppyb… #floppya: 1_44=a.img, status=inserted #第四步，选择启动盘符 #boot: floppy #默认从软盘启动，将其注释 boot: disk #改为从硬盘启动。我们的任何代码都将直接写在硬盘上，所以不会再有读写软盘的操作 #第五步，设置日志文件的输出 log: bochsout.txt #第六步，开启或关闭某些功能 #下面是关闭鼠标，并打开键盘 mouse: enabled=0 #keyboard_mapping: enabled=1, map=/usr/share/bochs/keymaps/x11-pc-us.map keyboard: keymap=/usr/local/Cellar/bochs/2.7/share/bochs/keymaps/sdl2-pc-us.map # 硬盘设置 ata0: enabled=1, ioaddr1=0x1f0, ioaddr2=0x3f0, irq=14 ata0-master: type=disk, path=\u0026#34;hd60M.img\u0026#34;, mode=flat, cylinders=121, heads=16, spt=63 # 如果编译bochs的时候带了-gdbstub选项才能开启，这样就可以使用gdb联合bochs调试 # 在bochs中支持2种调试方式：(1)bochs自己带的调试器 (2)gdb远程调试bochs #gdbstub: enabled=1, port=1234, text_base=0, data_base=0, bss_base=0 display_library: sdl2 相比Linux下的配置有两个地方有差异：\n（1）display_library: sdl2 在Linux下使用的是x11的显示库\n（2）keyboard: keymap的配置使用的是sdl2-pc-us.map，而不是x11的map\n4. 编写Makefile 为了测试环境编写一个简单的Makefile文件，目前暂时没有生成目标，运行只需要输入\nmake run 即可启动\nMakefile文件如下：\n1 2 3 4 5 6 7 8 9 10 .PHONY:run,clean run: make clean \u0026amp;\u0026amp; make disk \u0026amp;\u0026amp; bochs disk: @bximage -func=\u0026#34;create\u0026#34; -hd=60M -imgmode=\u0026#34;flat\u0026#34; -sectsize=512 -q hd60M.img clean: @$(RM) -r *.txt *.o *.bin hd60M.img 备注：不同版本的bochs提供的bximage工具的参数有比较大的差异，具体使用方式请man bximage 查阅\n","description":"","id":18,"section":"posts","tags":null,"title":"第0课 开发环境搭建","uri":"https://fanhestyle.github.io/posts/%E7%AC%AC0%E8%AF%BE-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"content":"辗转几次还是回到这里，开始安心写作吧！\n","description":"","id":19,"section":"posts","tags":null,"title":"转圈圈","uri":"https://fanhestyle.github.io/posts/my-first-post/"}]