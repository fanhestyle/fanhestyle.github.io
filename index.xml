<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:sy="http://purl.org/rss/1.0/modules/syndication/" xmlns:media="http://search.yahoo.com/mrss/"><channel><title>FanHe的博客</title><link>https://blog.healex.xyz/</link><description>Recent content on FanHe的博客</description><generator>Hugo -- gohugo.io</generator><language>cn</language><managingEditor>hzxaaron@gmail.com (FanHe)</managingEditor><webMaster>hzxaaron@gmail.com (FanHe)</webMaster><copyright>©2022, All Rights Reserved</copyright><lastBuildDate>Fri, 22 Apr 2022 09:28:01 +0800</lastBuildDate><atom:link href="https://blog.healex.xyz/index.xml" rel="self" type="application/rss+xml"/><item><title>第11课 内存管理</title><link>https://blog.healex.xyz/posts/%E7%AC%AC11%E8%AF%BE-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</link><pubDate>Fri, 22 Apr 2022 09:28:01 +0800</pubDate><author>hzxaaron@gmail.com (FanHe)</author><atom:modified>Fri, 22 Apr 2022 09:28:01 +0800</atom:modified><guid>https://blog.healex.xyz/posts/%E7%AC%AC11%E8%AF%BE-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</guid><description>1. 概述 本文主要讲解操作系统中内存的管理方式，内存管理分为物理内存管理和虚拟内存管理，并且需要建立二者之间的关联。 2. 管理框架 总的框架如下所示：</description><dc:creator>FanHe</dc:creator><category>从零打造操作系统</category></item><item><title>第10课 中断和特权级</title><link>https://blog.healex.xyz/posts/%E7%AC%AC10%E8%AF%BE-%E7%89%B9%E6%9D%83%E7%BA%A7/</link><pubDate>Wed, 20 Apr 2022 14:45:01 +0800</pubDate><author>hzxaaron@gmail.com (FanHe)</author><atom:modified>Wed, 20 Apr 2022 14:45:01 +0800</atom:modified><guid>https://blog.healex.xyz/posts/%E7%AC%AC10%E8%AF%BE-%E7%89%B9%E6%9D%83%E7%BA%A7/</guid><description>1. 概述 本来想将特权级单独来讲解，但是考虑到特权级和中断的关系，因此将二者结合起来讲解，因为中断很大一个原因是我们想通过中断门来实现调用操作系</description><dc:creator>FanHe</dc:creator><category>从零打造操作系统</category></item><item><title>第9课 函数调用</title><link>https://blog.healex.xyz/posts/%E7%AC%AC9%E8%AF%BE-%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/</link><pubDate>Wed, 20 Apr 2022 11:07:01 +0800</pubDate><author>hzxaaron@gmail.com (FanHe)</author><atom:modified>Wed, 20 Apr 2022 11:07:01 +0800</atom:modified><guid>https://blog.healex.xyz/posts/%E7%AC%AC9%E8%AF%BE-%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/</guid><description>1. 概述 本文介绍在汇编语言中的函数调用以及汇编和C的函数调用互操作的一些内容，我们假设C语言和汇编进行相互操作，那么情况有如下几种： C语言调用</description><dc:creator>FanHe</dc:creator><category>从零打造操作系统</category></item><item><title>第8课 加载最简易的内核和ELF文件</title><link>https://blog.healex.xyz/posts/%E7%AC%AC8%E8%AF%BE-%E5%8A%A0%E8%BD%BD%E6%9C%80%E7%AE%80%E6%98%93%E7%9A%84%E5%86%85%E6%A0%B8/</link><pubDate>Wed, 20 Apr 2022 09:00:01 +0800</pubDate><author>hzxaaron@gmail.com (FanHe)</author><atom:modified>Wed, 20 Apr 2022 09:00:01 +0800</atom:modified><guid>https://blog.healex.xyz/posts/%E7%AC%AC8%E8%AF%BE-%E5%8A%A0%E8%BD%BD%E6%9C%80%E7%AE%80%E6%98%93%E7%9A%84%E5%86%85%E6%A0%B8/</guid><description>1. 概述 本文即将开始加载最简易的内核代码，我们将控制权从Bootloader继续转交给下一棒的操作系统。 我们的操作系统大部分使用C语言来开发，</description><dc:creator>FanHe</dc:creator><category>从零打造操作系统</category></item><item><title>第7课 内存管理之分页机制</title><link>https://blog.healex.xyz/posts/%E7%AC%AC7%E8%AF%BE-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B9%8B%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6/</link><pubDate>Tue, 19 Apr 2022 09:30:01 +0800</pubDate><author>hzxaaron@gmail.com (FanHe)</author><atom:modified>Tue, 19 Apr 2022 09:30:01 +0800</atom:modified><guid>https://blog.healex.xyz/posts/%E7%AC%AC7%E8%AF%BE-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B9%8B%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6/</guid><description>1. 概述 本文主要讲解一下在x86 32位下的分页内存管理，分页机制使得我们不再直接使用和操作物理内存，而是为每一个任务（进程）分配一个独立4G空</description><dc:creator>FanHe</dc:creator><category>从零打造操作系统</category></item><item><title>第6课 获取物理内存大小</title><link>https://blog.healex.xyz/posts/%E7%AC%AC6%E8%AF%BE-%E8%8E%B7%E5%8F%96%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E5%A4%A7%E5%B0%8F/</link><pubDate>Tue, 19 Apr 2022 08:38:01 +0800</pubDate><author>hzxaaron@gmail.com (FanHe)</author><atom:modified>Tue, 19 Apr 2022 08:38:01 +0800</atom:modified><guid>https://blog.healex.xyz/posts/%E7%AC%AC6%E8%AF%BE-%E8%8E%B7%E5%8F%96%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E5%A4%A7%E5%B0%8F/</guid><description>1. 概述 在我们继续迈进内核编程之前，首先需要能获取到当前硬件的一些信息，首要的信息是物理内存的大小，一般来说可以用BIOS中断0x15实现，分</description><dc:creator>FanHe</dc:creator><category>从零打造操作系统</category></item><item><title>第5课 保护模式代码分析</title><link>https://blog.healex.xyz/posts/%E7%AC%AC5%E8%AF%BE-%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/</link><pubDate>Mon, 18 Apr 2022 16:50:01 +0800</pubDate><author>hzxaaron@gmail.com (FanHe)</author><atom:modified>Mon, 18 Apr 2022 16:50:01 +0800</atom:modified><guid>https://blog.healex.xyz/posts/%E7%AC%AC5%E8%AF%BE-%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/</guid><description>1. 概述 本文对保护模式代码进行简要的分析，并给出当前内存中的布局，首先给出保护模式加载的代码 .code16 .include &amp;#34;boot.inc&amp;#34; .section .text LOADER_STACK_TOP = LOADER_BASE_ADDR jmp loader_start GDT_BASE: .long 0x0 .long 0x0 CODE_DESC: .long 0x0000FFFF .long DESC_CODE_HIGH4 DATA_STACK_DESC: .long 0x0000FFFF .long DESC_DATA_HIGH4</description><dc:creator>FanHe</dc:creator><category>从零打造操作系统</category></item><item><title>第4课 进入保护模式</title><link>https://blog.healex.xyz/posts/%E7%AC%AC4%E8%AF%BE-%E8%BF%9B%E5%85%A5%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/</link><pubDate>Mon, 18 Apr 2022 16:00:21 +0800</pubDate><author>hzxaaron@gmail.com (FanHe)</author><atom:modified>Mon, 18 Apr 2022 16:00:21 +0800</atom:modified><guid>https://blog.healex.xyz/posts/%E7%AC%AC4%E8%AF%BE-%E8%BF%9B%E5%85%A5%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/</guid><description>1. 概述 本文开始从实模式进入到保护模式，实模式是指老式的兼容8086的模式，在实模式下各种寄存器的宽度是16位的，程序寻址内存的时候采用的是段</description><dc:creator>FanHe</dc:creator><category>从零打造操作系统</category></item><item><title>第3课 接力第二棒Bootloader</title><link>https://blog.healex.xyz/posts/%E7%AC%AC3%E8%AF%BE-%E6%8E%A5%E5%8A%9B%E7%AC%AC%E4%BA%8C%E6%A3%92bootloader/</link><pubDate>Mon, 18 Apr 2022 13:53:28 +0800</pubDate><author>hzxaaron@gmail.com (FanHe)</author><atom:modified>Mon, 18 Apr 2022 13:53:28 +0800</atom:modified><guid>https://blog.healex.xyz/posts/%E7%AC%AC3%E8%AF%BE-%E6%8E%A5%E5%8A%9B%E7%AC%AC%E4%BA%8C%E6%A3%92bootloader/</guid><description>1. 概述 本文开始从MBR进入到第二棒Bootloader，为操作系统的加载做准备 2. Bootloader 操作系统开发中第一棒是从BIOS进入到MBR，在MBR中只</description><dc:creator>FanHe</dc:creator><category>从零打造操作系统</category></item><item><title>第2课 完善MBR并使用显存</title><link>https://blog.healex.xyz/posts/%E7%AC%AC2%E8%AF%BE-%E5%AE%8C%E5%96%84mbr%E4%BD%BF%E7%94%A8%E6%98%BE%E5%AD%98/</link><pubDate>Mon, 18 Apr 2022 11:09:28 +0800</pubDate><author>hzxaaron@gmail.com (FanHe)</author><atom:modified>Mon, 18 Apr 2022 11:09:28 +0800</atom:modified><guid>https://blog.healex.xyz/posts/%E7%AC%AC2%E8%AF%BE-%E5%AE%8C%E5%96%84mbr%E4%BD%BF%E7%94%A8%E6%98%BE%E5%AD%98/</guid><description>1. 概述 本文完善之前编写的MBR，使用操作显存的方式来输出字符 2. 实模式下的内存布局 实模式下我们使用的内存是1MB的内存空间，这是从8086继承</description><dc:creator>FanHe</dc:creator><category>从零打造操作系统</category></item><item><title>第1课 初识MBR程序HelloWorld</title><link>https://blog.healex.xyz/posts/%E7%AC%AC1%E8%AF%BE-%E5%88%9D%E8%AF%86mbr%E7%A8%8B%E5%BA%8Fhelloworld/</link><pubDate>Mon, 18 Apr 2022 09:50:25 +0800</pubDate><author>hzxaaron@gmail.com (FanHe)</author><atom:modified>Mon, 18 Apr 2022 09:50:25 +0800</atom:modified><guid>https://blog.healex.xyz/posts/%E7%AC%AC1%E8%AF%BE-%E5%88%9D%E8%AF%86mbr%E7%A8%8B%E5%BA%8Fhelloworld/</guid><description>1. 概述 从本文开始我们正式开始编码的工作，首先是所有学习语言的第一个程序”Hello,World&amp;quot; 2. MBR简介 主引导记录（Maste</description><dc:creator>FanHe</dc:creator><category>从零打造操作系统</category></item><item><title>第0课 开发环境搭建</title><link>https://blog.healex.xyz/posts/%E7%AC%AC0%E8%AF%BE-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</link><pubDate>Mon, 18 Apr 2022 09:12:25 +0800</pubDate><author>hzxaaron@gmail.com (FanHe)</author><atom:modified>Mon, 18 Apr 2022 09:12:25 +0800</atom:modified><guid>https://blog.healex.xyz/posts/%E7%AC%AC0%E8%AF%BE-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</guid><description>1. 概述 本文主要介绍任何搭建开发环境，个人使用的开发环境如下： macOS 12.3.1 Monterey Bochs 2.7 Apple clang version 13.0.0 (clang-1300.0.27.3) 2. 搭建开发环境 安装必要的开发工具集 在MacOS中打开终端，终</description><dc:creator>FanHe</dc:creator><category>从零打造操作系统</category></item><item><title>排序算法之快速排序(QuickSort)</title><link>https://blog.healex.xyz/posts/quick_sort/</link><pubDate>Wed, 02 Jun 2021 09:02:42 +0800</pubDate><author>hzxaaron@gmail.com (FanHe)</author><atom:modified>Wed, 02 Jun 2021 09:02:42 +0800</atom:modified><guid>https://blog.healex.xyz/posts/quick_sort/</guid><description>1. 简介 快速排序是一种使用非常广泛并且高效的排序算法，它和归并排序（Merge Sort）类似，一般也是采用递归的方式来实现，它们都是分治算法(</description><dc:creator>FanHe</dc:creator></item><item><title>排序算法之堆排序</title><link>https://blog.healex.xyz/posts/heap_sort/</link><pubDate>Tue, 01 Jun 2021 10:22:41 +0800</pubDate><author>hzxaaron@gmail.com (FanHe)</author><atom:modified>Tue, 01 Jun 2021 10:22:41 +0800</atom:modified><guid>https://blog.healex.xyz/posts/heap_sort/</guid><description>1. 简介 堆排序使用到了堆（优先队列）的性质，假设一个堆是小顶堆，那么最大的元素在堆顶的位置，堆排序的步骤包括两个： 创建堆结构 依次移除堆顶的元素</description><dc:creator>FanHe</dc:creator></item><item><title>排序算法之希尔排序(ShellSort)</title><link>https://blog.healex.xyz/posts/shell_sort/</link><pubDate>Tue, 01 Jun 2021 08:17:59 +0800</pubDate><author>hzxaaron@gmail.com (FanHe)</author><atom:modified>Tue, 01 Jun 2021 08:17:59 +0800</atom:modified><guid>https://blog.healex.xyz/posts/shell_sort/</guid><description>1. 简介 希尔排序是希尔(Donald Shell)于1959年提出的一种排序算法，它是插入排序的一种改进算法，在插入排序中，我们每一次比较的是待</description><dc:creator>FanHe</dc:creator></item><item><title>排序算法之插入排序</title><link>https://blog.healex.xyz/posts/insertion_sort/</link><pubDate>Mon, 31 May 2021 15:52:20 +0800</pubDate><author>hzxaaron@gmail.com (FanHe)</author><atom:modified>Mon, 31 May 2021 15:52:20 +0800</atom:modified><guid>https://blog.healex.xyz/posts/insertion_sort/</guid><description>1. 概述 插入排序是一种相对简单的排序算法，插入排序算法在处理过程中每次处理一个待插入的元素，将它和已经排好序的子序列进行合并成新的已排好序的部</description><dc:creator>FanHe</dc:creator><category>排序算法</category></item><item><title>B树(B-tree)</title><link>https://blog.healex.xyz/posts/btree/</link><pubDate>Tue, 11 May 2021 17:06:15 +0800</pubDate><author>hzxaaron@gmail.com (FanHe)</author><atom:modified>Tue, 11 May 2021 17:06:15 +0800</atom:modified><guid>https://blog.healex.xyz/posts/btree/</guid><description>1. 简介 B树有两种分类的方式： （1）按度来定义（degree） 这种定义方法在算法导论一书中提及的， 一棵度为t的B树： 定义为：非根内节点的最少孩</description><dc:creator>FanHe</dc:creator><category>数据结构与算法</category></item><item><title>OpenWRT-19.07Luci编辑菜单方法</title><link>https://blog.healex.xyz/posts/edit_menu_openwrt19.07/</link><pubDate>Wed, 21 Apr 2021 23:19:21 +0800</pubDate><author>hzxaaron@gmail.com (FanHe)</author><atom:modified>Wed, 21 Apr 2021 23:19:21 +0800</atom:modified><guid>https://blog.healex.xyz/posts/edit_menu_openwrt19.07/</guid><description>1. 简介 OpenWRT从19.07开始逐步将网页的渲染模式从服务端移到客户端，由此带来的一个显著的变化是luci开发的Lua代码大幅减少，取而</description><dc:creator>FanHe</dc:creator></item><item><title>OpenWRT 19.07 Luci框架的改变</title><link>https://blog.healex.xyz/posts/openwrt_19.07_luci_changes/</link><pubDate>Wed, 21 Apr 2021 08:47:25 +0800</pubDate><author>hzxaaron@gmail.com (FanHe)</author><atom:modified>Wed, 21 Apr 2021 08:47:25 +0800</atom:modified><guid>https://blog.healex.xyz/posts/openwrt_19.07_luci_changes/</guid><description>1. 简介 OpenWRT19.07的一个重大的改动是将之前OpenWRT的Luci框架做了比较大的调整，最主要集中在将Luci的渲染方式从之前的</description><dc:creator>FanHe</dc:creator><category>OpenWRT开发</category></item><item><title>转圈圈</title><link>https://blog.healex.xyz/posts/my-first-post/</link><pubDate>Mon, 05 Apr 2021 21:20:55 +0800</pubDate><author>hzxaaron@gmail.com (FanHe)</author><atom:modified>Mon, 05 Apr 2021 21:20:55 +0800</atom:modified><guid>https://blog.healex.xyz/posts/my-first-post/</guid><description>辗转几次还是回到这里，开始安心写作吧！</description><dc:creator>FanHe</dc:creator><category>生活</category></item></channel></rss>