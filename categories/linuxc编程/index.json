[{"content":"1. 简介 堆排序使用到了堆（优先队列）的性质，假设一个堆是小顶堆，那么最大的元素在堆顶的位置，堆排序的步骤包括两个：\n 创建堆结构 依次移除堆顶的元素，移除的元素存放在数组中  从上面的描述我们可以大概的直到，堆排序需要一个额外的数组来存储排好序的队列，接着再把排好序的数组复制回原来的数组\n2. 预备知识 首先了解以下堆的特性，堆和二叉排序树不同，它并没有左右子树的约束关系，而仅仅是有一个树根和左右子树的约束关系（树根的元素一定的最小的，假设针对的是小顶堆），并且使用数组实现的堆有一些特别的特性。\n在讨论特性时，我们需要了解一下堆这种数据结构的实现（假设底层采用的是数组的实现），在我遇到的代码中有基于索引1开始的实现（也就是把数组索引为0的位置空出来，另作他用），也有使用索引位置为0开始的实现，它们的区别如下：\n 根节点索引为0 根节点索引为1 左孩子(数组下标) (index * 2 + 1) (index * 2) 右孩子(数组下标) (index * 2 + 2) (index*2 + 1) 父节点(数组下标) (index - 1) / 2 (index/2) 也就是说采用索引0或者1开始其实无关紧要（但是也有人争议说采用*2 /2可以通过移位快速实现，也有人反驳提到 *2 /2 的移位实现在当今的硬件上和 +1 +2几乎误差，具体见参考资料2）\n3. 实现 在堆排序实现时，需要注意2点：\n  按照之前的讨论，感觉上我们应该需要额外的一个数组空间来存储排好序的结果，但是事实上我们可以复用之前的数组，因为当数组deleteRoot之后，整个堆实际上少一个元素，我们可以把删除的元素存储在空出的数组里面，但是这样做会带来一个问题，最后得到的结果时逆序的，因此为了可以正常排序，我们需要建立的堆和我们排序的情况相反的堆，也就是当要从小到大排列的时候，我们需要创建大顶堆；当需要从大到小的情况排列时，我们需要创建小顶堆。\n  堆排序不要尝试去创建一个堆数据结构，也就是说当使用C++去实现的时候，不要创建一个堆的类，这样代码太复杂了，而仅仅是创建堆序就好了，代码比较轻量级一点。\n  3.1 自底向上的构建堆的方法 实现的伪代码如下：\n堆排序包括两个步骤（1）创建堆（2）移除堆顶元素 直至整个堆元素处理完\n HeapSort算法  heapsort(a, count) input: 长度为count乱序的数组 heapify(a, count) //首先创建堆 //在处理过程中使用变量end记录堆结束的位置（a[0:end]标识堆区域） // a[end:count-1]是已经拍好的排好序的元素数组 end = count - 1 //用 end 记录堆中排好序和属于堆的元素 while end \u0026gt; 0 do swap(a[end],a[0]) //交换end和a[0]，把最大的元素移除 end = end - 1 //end前移1，标识最大的元素被删除出堆，进入排好序的子列 siftDown(a,0,end) //a[0]根节点位置被移除，堆性质被破坏，重新整理堆 可以从上面的伪代码看出，堆排序需要两个子函数 heapify（创建堆）和 siftDown（在堆的性质破坏之后恢复堆的性质）\n 子函数 heapify  procedure heapify(a, count)\nstart = iParent(count-1) //找到最后一个元素的父节点索引号\nwhile start \u0026gt;=0 do siftDown(a, start, count-1) start = start - 1   子函数 siftDown(a, start, end)  procedure siftDown(a, start, end)\nroot = start while iLeftChild(root) \u0026lt;= end do child = iLeftChild(root) nextPos = root if a[nextPos] \u0026lt; a[child] then nextPos = child if child+1 \u0026lt;= end and a[nextPos] \u0026lt; a[child+1] then nextPos = child + 1 if nextPos = root then return else swap(a[root], a[nextPos]) root = nextPos;  以下是堆排序的C++实现代码(我个人手写的，可能还需要优化)\nint parent(int childIndex) { return (childIndex - 1) / 2; } int leftChild(int parentIndex) { return (2 * parentIndex + 1); } //从pos位置节点开始下沉直到处理到叶节点 //arr:数组指针 //pos:当前调整的节点索引号（是一个子树的根节点的索引号） //n：当前堆的元素总数 template\u0026lt;typename T\u0026gt; void siftDown(T arr[], int pos, int n) { int leftChildIndex = leftChild(pos); while (leftChildIndex \u0026lt; n) { //记录我们把根节点元素移动到的下一个位置 //下一个位置有可能是左孩子或者右孩子（如果存在右孩子的话） //如果下一个节点位置通过比较根节点和左右孩子节点的值发现不需要 //移动的话，说明我们根节点的值就应该保持原地不动，也就是说已经完成了 int nextTravsalIndex = pos; if (arr[nextTravsalIndex] \u0026lt; arr[leftChildIndex]) { nextTravsalIndex = leftChildIndex; } //如果节点有右节点,并且右节点的值大于（左节点和根节点值中的较大者） if (leftChildIndex + 1 \u0026lt; n) { if (arr[nextTravsalIndex] \u0026lt; arr[leftChildIndex + 1]) { nextTravsalIndex = leftChildIndex + 1; } } //我们把根节点上的元素往下沉，但是判断左右孩子都不大于这个根节点的数， //说明当前根节点的元素位置是符合堆性质的 if (nextTravsalIndex == pos) return; std::swap(arr[nextTravsalIndex], arr[pos]); pos = nextTravsalIndex; leftChildIndex = leftChild(nextTravsalIndex); } } template\u0026lt;typename T\u0026gt; void heapify(T arr[], int n) { if (n \u0026lt;= 1) return; //从最后一个节点的父节点开始，依次减少到根节点，将每一棵子树都调整为大顶堆 for (int i = parent(n-1); i \u0026gt;= 0; i--) { siftDown(arr, i, n - 1); } } template\u0026lt;typename T\u0026gt; void heapSort(T arr[], int n) { if (n \u0026lt;= 0) return; heapify(arr, n); while (n \u0026gt; 0) { std::swap(arr[0], arr[n - 1]); n--; siftDown(arr, 0, n); } } 3.1.2 补充：递归构造下沉 在下沉的时候，可以使用迭代亦可使用递归的做法，上文中给出的是迭代的代码，此处补充一下递归下沉的代码：\n/* recursive version of siftDown 具体见参考资料4 */ template\u0026lt;typename T\u0026gt; void siftDown_recursive(T arr[], int pos, int n) { //递归退出的出口 if (pos \u0026gt; n) return; int leftChildIndex = leftChild(pos); int rightChildIndex = leftChildIndex + 1; T leftValue = arr[leftChildIndex]; int maxValueIndex = pos; if (leftChildIndex \u0026lt; n \u0026amp;\u0026amp; arr[pos] \u0026lt; arr[leftChildIndex]) maxValueIndex = leftChildIndex; if (rightChildIndex \u0026lt; n \u0026amp;\u0026amp; arr[maxValueIndex] \u0026lt; arr[rightChildIndex]) maxValueIndex = rightChildIndex; if (maxValueIndex == pos) { return; } else { std::swap(arr[pos], arr[maxValueIndex]); siftDown(arr,maxValueIndex,n); } } 3.1.3 补充：延伸阅读：见参考资料1，里面有提及一种叫”heapsort with bounce“的优化方式，我暂时没看明白，不理解它的优化点在何处，后续继续研究 3.2 自顶向下构造堆的方法 在上述的3.1中介绍的方法，创建堆的方法是从最后一个节点的父节点开始，依次往上去构造堆的方法进行的，这种做法有些tricky，可能第一时间不太容易想到，比较直观的一种做法是直接从乱序的数组第一个元素开始构造堆，这种方式应该最容易想到的做法，我们来尝试一下。\n伪代码如下：\nprocedure heapify(a, count) end = 1 //end从第一个左孩子开始（根的左孩子，根的索引是0） while end \u0026lt; count siftUp(a,0,end) end = end + 1 procedure siftUp(a, start, end) child = end while child \u0026gt; start parent = iParent(child) //计算parent的索引号 if a[parent] \u0026lt; a[child] then swap(a[parent], a[child]) child = parent else return siftUp实现的堆不能像siftDown那样，在交换元素之后可以进行“堆的修复”，** siftUp这种方式实现的堆必须每次移除元素后都重建整个堆 **\nprocedure heapsort(a, count) heapify(a,count) end = count - 1 while end \u0026gt; 0 do swap(a[end],a[0]) heapify(a,end) end = end - 1 这种方式实现的C++代码如下所示：（我手写的代码，大量使用了递归）\ntemplate\u0026lt;typename T\u0026gt; void siftUp(T arr[], int index, int n) { int parentIndex = parent(index); if (parentIndex \u0026gt;= 0 \u0026amp;\u0026amp; arr[index] \u0026gt; arr[parentIndex]) { std::swap(arr[index], arr[parentIndex]); siftUp(arr,parentIndex,n); } } template\u0026lt;typename T\u0026gt; void heapify(T arr[], int n) { for (int i = 1; i \u0026lt; n; i++) { siftUp(arr, i, n); } } template\u0026lt;typename T\u0026gt; void heapSort(T arr[], int n) { if (n \u0026lt;= 1) return; heapify(arr, n); std::swap(arr[0], arr[n - 1]); heapSort(arr, n-1); } 3.3 两种思路的比较和算法复杂度分析 3.1 的思路有点类似于从最底下的非叶节点开始，逐步向根移动，并且每次都“修补”好堆的结构\n3.2 的思路是从空的堆开始，逐步构建一个完整的堆，它是从最上面的根的子节点开始的\n需要根据算法中描述的具体操作步骤才能分析清楚这两者的特点：\n3.1 具体来说是一种“ bottom up scan , and perform a sift-down” 也就是从整体来说是 “从下往上”，但是局部确是“从上往下”\n3.2 具体来说是一种“ top down scan, and perform a sift-up\u0026quot;，从整体来说是”从上往下“，但是局部确实”从下往上“\nHeapify的时间复杂度：\n3.1 这种方式时间复杂度是O(N)\n3.2 这种方式时间复杂度是O(NlogN)\n但是两者实现的HeapSort的时间复杂度都是O(NlogN)，一般来说大家普遍实现的堆排序的算法是3.1中这种方式\n在通过数组构建堆的时候，从数组的第一个位置开始依次向后，a[0]\u0026ndash;\u0026gt;a[n-1] 这种方式称之为 sift-up的方式（从外在形式上看其实是Top-Down的方式，但是这里的sift-up指的是插入的每一步操作的方式，是将节点依次往上浮），从0开始创建一个堆；\n在通过数组构建堆的时候，从数组的最后一个位置开始依次向前，a[n-1]\u0026ndash;\u0026gt;a[0] 这种方式称之为 sift-down的方式（从外在形式上看其实是Bottom-Up的方式，但是sift-bottom指的是每一次操作一个元素采用的方式，是把节点往下沉），类似于修补一个损坏的堆\n可以通过下面的事实了解到一些复杂度区别的本质：\n 往上浮的代价是节点距离根节点的距离 往下沉的代价是节点距离叶子节点的距离  很明显由于堆是完全二叉树，叶节点的节点数量明显比非叶节点多不少，于是从感性上就可以认识到往上浮肯定没有往下沉好。因为往上浮叶节点的操作代价最高，而有大量的叶节点，而往下沉根节点的代价最高，但是根节点只有一个而已。\n另外这两种思路最后获得的堆结构可能是不同的，但是最终都能得到正确的排序结果。\n更多的内容见参考资料部分\n5. 参考资料 1. Wiki: Heapsort\n2. Why in a heap implemented by array the index 0 is left unused?\n3. Weiss :Data Structures and Algorithm Analysis in C++ (Fourth Edition) Chapter 7.5 Heap Sort\n4. 堆排序(Heapsort)\n5.siftUp and siftDown operation in heap for heapifying an array\n6.How can building a heap be O(n) time complexity?\n","description":"","id":0,"section":"posts","tags":null,"title":"","uri":"https://blog.healex.xyz/posts/heap_sort/"},{"content":"1. 简介 希尔排序是希尔(Donald Shell)于1959年提出的一种排序算法，它是插入排序的一种改进算法，在插入排序中，我们每一次比较的是待插入数和已排好序的子数组。这样在插入的时候每一次进行相邻间元素的一次交换，希尔排序则不一样，它每次排序以一个固定的间隔进行（这个间隔被称为gap），并且最后一次的gap一定是1（也就是最后一次的排序是一次普通的插入排序）\n为什么要如此设计呢？我们考虑这样一个情形，比如下述的待排序数组\n[5,3,7,4,8,9,6,2,1]\n当我们插入排序的时候，在最后两个元素2和1进行排序的时候，我们会发现需要大量的移动操作才能把2和1放到它们应有的位置（也就是数组的开头），这样就会萌生一个想法，能不能尽快的使得2和1这样的数迅速的移动到前面呢？而不用每次一个一个数的比较前移。Shell排序就是这种想法，它用非1的间隔来进行比较，假设我们用4的间隔进行比较，在第一趟中元素4和2比较，发现2在后面，会把2移到元素4的位置，这样元素2一下子就能往前走好多步。并且当我们缩小间隔gap的时候，之前比较大间隔拍好的序列不会白费（也就是之后减少间隔的排序还是会保留之前排序的成功，相当于前人做的努力没有白费，成果一直保留在那儿），直到gap是1的最后一次排序操作，最后一次的gap为1的排序一定能保证整个数组排好序（因为它就是一次简单的插入排序嘛），而可以预期最后一次的排序需要移动的元素一定不会太多。\n另外参考资料2中给出了一个解释（也是数据结构与算法分析这本书提及的），我们把数组中逆序的数对找出来，比如上面我们举例的数组中逆序的数对包括（5，3）（5，4）（5，2）（5，1）（3，2）（3，1）\u0026hellip; 这些数对期望的对数是 $$ \\frac {n(n-1)} 4 $$ ，如果我们采取的是逐个比较相邻两个数，通过相邻两个数来决定调整相邻两个数之间的位置，这样我们一次操作最多能纠正一对逆序的数对，也就是说像插入排序、冒泡排序、选择排序这种每次只通过比较相邻的元素而进行交换的排序算法，它们的时间复杂度一定是 $$ O(n^2) $$，那么怎样提高这个排序效率呢？\n关键点就是我们不能一直比较相邻的数，而应该比较相距较远的数，这样有可能在一次交换之后能够期望达到纠正超过一个逆序对的效果，可是有人又会问：如果一次相聚较远的数，那会不会导致交换的数对中增加了额外的逆序数呢？下面我们来证明通过交换间隔较远的数对不会造成逆序数的增加。\n假设有位置i和j，i \u0026lt; j，但是a[i] \u0026gt; a[j]，我们假设数组排好序之后是从小到大排列，很显然（i，j）是一个逆序对，我们想知道交换i，j会不会造成逆序对的增加，因为i和j的交换会影响到i和j之间的数（i和j之前和之后的数和i、j的相对关系不变，因此不会影响），考虑到i和j之间的任意一个数，假设是k（i \u0026lt; k \u0026lt; j)，我们讨论下列几种情况：\n a[k] \u0026gt; a[i] a[k] \u0026lt; a[j] a[i] \u0026lt; a[k] \u0026lt; a[j]  也就是说a[k]的值小于最小的，位于最小和最大之间以及大于最大的，这样就完全覆盖了a[k]的取值情况，这样我们来分析它们交换之后的效果：（我们用1，2，3来标识a[i] a[k] a[j]这样的值）\n 情况1：初始是 2 3 1 ，交换i和j之后变为 1 3 2，逆序对从2变为1 情况2：初始是 3 1 2 ，交换i和j之后变为 2 1 3，逆序对从2变为1 情况3：初始是 3 2 1，交换i和j之后变为 1 2 3，逆序对从3变为0  于是我们可以说当使用间隔较大的数对交换时，一定是会减少逆序数的，有可能减少一对，也有可能减少多对，这样就至少比每次减少一对的算法要好，虽然我们不知道好的上限是好到多少，但是至少不比插入、冒泡、选择这些排序效果要差。\n事实上希尔排序的时间复杂度的证明相当的复杂，需要使用数论等非常高级的数学理论来证明，我个人还没有这个能力提供这些证明，看懂也暂时不可能，记住这个思想和为什么比普通的二次排序要好对于非理论研究的开发者来说要应该是足矣。\n2. 实现 希尔排序的实现不是特别的复杂，以下的实现包括我个人初次学习写下的一些代码\n2.1 我个人的代码 template\u0026lt;typename T\u0026gt; void shellSort(T arr[], int n) { for (int gap = n / 2; gap \u0026gt;= 1; gap /= 2) { for (int i = 0; i \u0026lt; n; i++) { for (int j = i+gap; j \u0026lt; n; j += gap) { int k = j; T tmp = arr[k]; for (; k \u0026gt;= gap \u0026amp;\u0026amp; arr[k] \u0026lt; arr[k - gap]; k -= gap) { arr[k] = arr[k - gap]; } arr[k] = tmp; } } } } 我给出的程序也是可以正确得到排序结果的，但是通过和其他标准Shell写法的程序相对比，发现了我给出来的程序会做一些额外无用的操作，从代码一眼就能看出来我写的代码有多层的循环，事实上我在阅读Shell排序的说明之后，第一时间写出来的就是上面的代码，我写的代码中第3层的循环 for(int j=i+gap; j\u0026lt;n; j+=gap) 想法是把所有间隔为gap的所有元素都找出来，然后进行一次常规的插入排序，从思路上来说是没错，但是确有点冗余，比如下面的数列\n[3,7,2,8,1,9,6,5,4] 当遍历到1时，代码会找出来子序列 [3,1,4]，然后用插入排序把所有的数排好，下次遍历到1时，还是会找出来[1,4]又再排一次，这样很明显是有重复操作的。\n问题的关键在于：shell排序是会每次比较子序列，但却不是向我这样生硬的把所有子序列都找出来排一遍。而是逐个元素遍历，找到一个元素之后和之前的相隔gap的元素进行比较，在一次最外层循环之后，每个内层的循环把新的数添加到以前遍历的都是相隔gap位置的子序列中，最终完成排序。\n2.1 Shell给出的实现 希尔最早给出的实现是选取gap的值为 $$ \\lfloor \\frac {N} {2^k} \\rfloor $$ ,实现的伪码如下：\n# Start with the largest gap and work down to a gap of 1 foreach (gap in gaps) { # Do a gapped insertion sort for this gap size. # The first gap elements a[0..gap-1] are already in gapped order # keep adding one more element until the entire array is gap sorted for (i = gap; i \u0026lt; n; i += 1) { # add a[i] to the elements that have been gap sorted # save a[i] in temp and make a hole at position i temp = a[i] # shift earlier gap-sorted elements up until the correct location for a[i] is found for (j = i; j \u0026gt;= gap and a[j - gap] \u0026gt; temp; j -= gap) { a[j] = a[j - gap] } # put temp (the original a[i]) in its correct location a[j] = temp } } C++代码实现如下：\ntemplate\u0026lt;typename T\u0026gt; void shellSort(T arr[], int n) { for (int gap = n / 2; gap \u0026gt;= 1; gap /= 2) { for (int i = gap; i \u0026lt; n; i++) { T tmp = arr[i]; int j = i; for (; j \u0026gt;= gap \u0026amp;\u0026amp; tmp \u0026lt; arr[j - gap]; j -= gap) { arr[j] = arr[j - gap]; } arr[j] = tmp; } } } 3. 时间复杂度分析 Shell排序的时间复杂度非常的繁琐，需要大量的高等数学的知识，我暂时还没能力读懂这些证明（毕竟不是数学相关专业，也对这些内容不感兴趣），因此贴一张别人论证的结论在此\n图中也给出了一些相对表现较好的gap的取值（如果gap是递增方式的，那么我们在编码时只需要找到一个比数组长度小的最大的数，逆序直到1，作为我们的gap序列即可）\n4. 参考资料 1. WiKi:Shellsort\n2.希尔排序为什么会那么牛那么快，能够证明吗？\n3.Mark Allen Weiss:Data Structures and Algorithm Analysis in C++ (Fourth Edition) 7.4 ShellSort\n","description":"","id":1,"section":"posts","tags":null,"title":"排序算法之希尔排序(ShellSort)","uri":"https://blog.healex.xyz/posts/shell_sort/"},{"content":"1. 概述 插入排序是一种相对简单的排序算法，插入排序算法在处理过程中每次处理一个待插入的元素，将它和已经排好序的子序列进行合并成新的已排好序的部分，逐渐增长直到整个数组排序完成。\n插入排序的主要优点包括：\n 实现相对简单（相比较快速排序，堆排序，归并排序来说它的代码相对较少） 对元素不太多的序列有比较好的性能 相比较其他 $ O(n^2) $ 的算法来说更加高效 算法是排序稳定的（值相等的元素位置顺序保持不变） In-place算法，只需要固定的内存空间占用（基本上只需要原先数组的空间即可） Online算法，可以来一个元素处理一个  2. 实现方式 插入排序的算法虽然简单，但是还是有一些细节需要注意，以下列举一些实现\n2.1 我最初的实现 以下是我自己在阅读插入排序描述之后给出的代码：(C++代码)\n 版本1  template\u0026lt;typename T\u0026gt; void insertionSort(T array[], int n) { for (int i = 1; i \u0026lt; n; i++) { int insertPos = 0; T tmp = array[i]; for (int j = 0; j \u0026lt; i; j++) { if (array[j] \u0026lt; tmp) { insertPos++; } } for (int k = i; k \u0026gt; insertPos; --k) { array[k] = array[k - 1]; } array[insertPos] = tmp; } }  版本2  template\u0026lt;typename T\u0026gt; void insertionSort(T array[], int n) { for (int i = 1; i \u0026lt; n; i++) { int insertPos = 0; T tmp = array[i]; for (int j = 0; j \u0026lt;= i; j++) { if (array[j] \u0026lt; tmp) { insertPos++; } } for (int k = i; k \u0026gt; insertPos; --k) { array[k] = array[k - 1]; } array[insertPos] = tmp; } } 以上给出的两个版本的代码，我自己通过测试程序进行测试，测试程序如下：\nint main() { int arr[] = { 1,9,2,6,4,3,8,7,5 }; insertionSort(arr, sizeof(arr) / sizeof(arr[0])); for (auto i : arr) { std::cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; std::endl; } } 分析我个人写的代码，发现有一些需要改进的点：\n  算法2实际上是有问题的\n使用测试程序是看不出来的，最后给出的结果都是1-9的顺序输出，但是算法2会造成算法的不稳定（也就是会把相等的元素的先后顺序改变）\n  算法1是正确的，但是先找位置，再移动元素可以改进一下，可以从排好序的子序列的最后位置开始往前找，而不是像我写的代码这样从前往后找。因为从后往前有一个好处是交换操作可以边找边做，而从前往后找，再找到位置之后也需要移动元素，何不一边找一边移动呢？其实这也是标准的插入排序的算法实现\n  2.2 常见的插入排序算法实现 以下是一种插入排序的算法伪码实现\ni ← 1 while i \u0026lt; length(A) j ← i while j \u0026gt; 0 and A[j-1] \u0026gt; A[j] swap A[j] and A[j-1] j ← j - 1 end while i ← i + 1 end while 这个算法有几个细节需要注意：\n  while j \u0026gt; 0 and A[j-1] \u0026gt; A[j] 的And 操作必须是一个短路的and操作（类似于C/C++中的 \u0026amp;\u0026amp;，当第一个条件失效时，不会计算第二个条件）\n  这个算法插入的时候，从插入点开始每次都进行了元素的交换\n  进行元素的交换有一个好处是完全不需要额外的空间排序，也就是说算法整个运行过程中仅仅需要算法原始元素的存储空间。不过过多的交换或许并不是很合适，可以通过记录我们当前即将要插入的元素，通过额外的一个元素的空间，来换取一直进行的交换操作。\n以上伪代码的C++实现如下\n#include \u0026lt;algorithm\u0026gt; template\u0026lt;typename T\u0026gt; void insertionSort(T arr[], int n) { for (int i = 1; i \u0026lt; n; i++) { for (int j = i; j \u0026gt; 0 \u0026amp;\u0026amp; arr[j - 1] \u0026gt; arr[j]; j--) { std::swap(arr[j - 1], arr[j]); } } } 2.3 略微改进的插入排序算法 上面在2.2节中讨论到可以通过额外的一个临时变量存储当前待插入的元素，从而减少一直进行的交换操作，伪码如下：\ni ← 1 while i \u0026lt; length(A) x ← A[i] j ← i - 1 while j \u0026gt;= 0 and A[j] \u0026gt; x A[j+1] ← A[j] j ← j - 1 end while A[j+1] ← x i ← i + 1 end while 注意算法的几个细节：\n  使用临时变量保存了即将插入的元素A[i]的值，在内层循环中一直向后移动元素，直到找到A[i]归属的那个位置\n  内层代码中赋值使用的是A[j+1] = A[j]，和2.2节中略有不同，这些是实现中边界条件的一些细节，在实际编码中需要格外注意（最好是手写一个简单的数组来模拟）\n  以上伪码的C++实现如下：\ntemplate\u0026lt;typename T\u0026gt; void insertionSort(T arr[], int n) { for (int i = 1; i \u0026lt; n; i++) { T tmp = std::move(arr[i]); int j = i-1; for (; j \u0026gt;= 0 \u0026amp;\u0026amp; arr[j] \u0026gt; tmp; j--) { arr[j + 1] = std::move(arr[j]); } arr[j+1] = std::move(tmp); } } 以上代码在设置 int j = i - 1，写起来特别别扭，建议还是用 int j = i的方式，赋值使用 arr[j] = arr[j-1]的方式，更加自然一点。\n另外代码中使用了C++的移动函数，如果数组的元素是特别大的对象，那么这样处理减少了拷贝对象的过程\n2.4 递归的实现 插入排序可以采用递归的方式来实现，插入排序采用递归的方式没有任何优势可言，不过可以考察对于递归和插入排序的理解，递归的思路如下：\n 基本情形(Base): 如果数组长度为1，排序完成 递归的处理最开始的n-1个元素 插入最后一个元素到已经排好序的子数列中  实现代码如下：\ntemplate\u0026lt;typename T\u0026gt; void insertionSort(T arr[], int n) { if (n \u0026lt;= 1) return; insertionSort(arr, n - 1); T last = arr[n - 1]; int j = n - 1; while (j \u0026gt; 0 \u0026amp;\u0026amp; arr[j-1] \u0026gt; last) { arr[j] = arr[j-1]; j--; } arr[j] = last; } 也就是在已经排好序的数组中再新增一个元素\n3. 算法的复杂度分析 最好情况：\n当数组已经是排好序的情况下，内层的循环只需要进行一次，时间复杂度是O(n)\n最坏的情况：\n当数组完全是逆序的时候，整个循环需要依次比较 1+2+3+\u0026hellip;+n-1次，于是时间复杂度是 $ O(n^2) $\n平均情况：\n平均的时间复杂度也是 $ O(n^2) $\n4. 参考资料 1.Insertion sort\n2.Insertion Sort\n3.Recursive Insertion Sort\n4.Insertion Sort by swapping???\n5.Introduction To Algorithms(chapter 2.1)\n","description":"","id":2,"section":"posts","tags":null,"title":"排序算法之插入排序","uri":"https://blog.healex.xyz/posts/insertion_sort/"},{"content":"1. 简介 B树有两种分类的方式：\n（1）按度来定义（degree）\n这种定义方法在算法导论一书中提及的，\n一棵度为t的B树：\n定义为：非根内节点的最少孩子数是t，并且强制非根内节点的最大孩子数是2t\n（2）按阶来定义（order）\n这种定义方法是在The Art of Computer Programming 一书中定义的，\n一棵m阶的B树：\n定义为：非根内节点的最大孩子数量是m，非根内节点的最小孩子数量是 m/2 向上取整\n这两种方式定义下的最简单B数就有所差异了，按度定义的话最小的B树是2-3-4树，按阶的方式定义最小的B树是2-3树\n参考资料 1. B-tree\n2.stackoverflow: What is the difference btw “Order” and “Degree” in terms of Tree data structure\n","description":"","id":3,"section":"posts","tags":null,"title":"B树(B-tree)","uri":"https://blog.healex.xyz/posts/btree/"},{"content":"1. 一句话总结 介绍C语言中的动态内存的分配、使用和释放\n2. 课程内容 3. 动手写代码 4. 课堂笔记 动态内存管理\nmalloc ralloc realloc free\n原则：谁申请谁释放（尽量在同一个函数中做到申请和释放，如果不行那么最好能在同一个模块中做到）\ntypedef：为已有的变量类型定义一个新的名字\n5. 参考资料 ","description":"","id":4,"section":"backup","tags":null,"title":"LinuxC编程随笔（动态内存管理-14）","uri":"https://blog.healex.xyz/backup/linux_c_14/"},{"content":"1. 一句话总结 介绍C语言中的结构体、共用体和枚举类型\n2. 课程内容 3. 动手写代码 4. 课堂笔记 结构体\n  产生及意义\n  类型描述\nstruct 结构提名\n{\n数据类型 成员1；\n数据类型 成员2；\n\u0026hellip;\n};\n（备注：最后的分号不能省略）\n  嵌套定义\n  定义变量（变量，数组，指针），初始化及成员引用\n成员引用：\n（1）变量名.成员名\n（2）指针-\u0026gt;成员名\n（3）(*指针).成员名\n  结构体占用内存空间大小\n对齐的概念\nattribute((packed)) //设置不要对齐：所占用的空间大小就是各成员占用空间的和\n  结构体作为函数参数\n结构体传参建议使用指针的方式进行，使用结构体类型的方式传递，会导致隐式的声明一个临时的结构体并且逐个成员的拷贝\n  共用体\n  产生及意义\n  类型描述\nunion 共用体名\n{\n数据类型 成员名1；\n数据类型 成员名2；\n\u0026hellip;\n};\n(备注：分号不能省略)\n共用体只有一个变量是有效的；\n  嵌套定义\n一般是指结构体嵌套共用体或者共用体嵌套结构体定义\n  定义变量（变量，数组，指针）初始化及成员引用\n成员引用方式：\n（1）变量名.成员名\n（2）变量名-\u0026gt;成员名\n  占用内存大小\n多个成员中最大的那个成员的大小就是整个共用体的大小\n  函数传参（值，地址）\n  位域（实际开发使用情况极少）\n  枚举\nenum 标识符\n{\n成员1，\n成员2，\n\u0026hellip;\n};\n5. 参考资料 ","description":"","id":5,"section":"backup","tags":null,"title":"LinuxC编程随笔（C语言中的构造类型-13）","uri":"https://blog.healex.xyz/backup/linux_c_13/"},{"content":"1. 一句话总结 介绍C语言中的函数\n2. 课程内容 3. 动手写代码 4. 课堂笔记 七 函数\n  函数的定义\n数据类型 函数名（【形式参数说明表：数据类型 形参名, \u0026hellip;】）\n  函数的传参\n值传参\n地址传递\n全局变量\n  函数的调用\n嵌套调用\n递归\n  函数与数组\n  函数与指针\n指针函数\n返回值是指针的函数，形如： 返回值* 函数名(形参)\n函数指针\n类型 (*指针名)(形参);\n如: int (*p)(int);\n函数指针数组\n类型 （*数组名【下标】）（形参）\n如：int (*arr[N])(int);\n指向指针函数的函数指针数组\nint *(*funcp[N])(int);\n  5. 参考资料 ","description":"","id":6,"section":"backup","tags":null,"title":"LinuxC编程随笔（函数-12）","uri":"https://blog.healex.xyz/backup/linux_c_12/"},{"content":"1. 一句话总结 2. 课程内容 3. 动手写代码 4. 课堂笔记 六、指针\n  变量与地址\n  指针与指针变量\n  直接访问与间接访问\n  空指针与野指针\n  空类型\n  定义与初始化的写法规则\n  指针运算\n  指针与数组\n指针与一维数组\n指针与二维数组\n指针与字符数组\n  const与指针\n指针常量；\n常量指针\n  指针数组与数组指针\n【存储类型】 数据类型 (*指针名)【下标】 = 值\n如： int (*p)[3];\n  多级指针\n  5. 参考资料 ","description":"","id":7,"section":"backup","tags":null,"title":"LinuxC编程随笔（指针-11）","uri":"https://blog.healex.xyz/backup/linux_c_11/"},{"content":"1. 一句话总结 介绍数组，包括一维数组、二维数组、字符数组\n2. 课程内容 3. 动手写代码 3.1 删除法求1000以内的质数 思路1：\n（1）申请一个1000大小为1000的数组，然后依次删除每一个数2开始的倍数（如3N，4N）（到1000），剩下的数就是质数\n（2）怎么记录删除呢？可以把数组中的数设置成一个不可达的数（比如-1）\n也可以用数组的下标记录数组的数值，初始化的时候是0，一旦不为0说明数被删除了，但是这样做需要数组的下标和数是匹配的（也就是说2存储在下标是[2]的位置，3\n存储在下标是[3]的位置。\n教程中就是采用的第二种删除方式，这里实现一下\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main() { int num[1001] = {0}; for(int i = 2; i \u0026lt; 1000; i++) { for(int j = 2*i; j \u0026lt; 1000; j += i) num[j] = -1; } for(int i = 2; i \u0026lt; 1000; i++) if (!num[i]) printf(\u0026quot;%d \u0026quot;, i); printf(\u0026quot;\\n\u0026quot;); exit(0); } 其他习题较简单，略\n4. 课堂笔记 数组\n一维数组\n  定义\n【存储类型】 数据类型 标识符 【下标】(下标C99之前要求是编译器的常量)\n  初始化\n（1）（默认不会初始化，里面是乱值）\n（2） 可以使用列表初始化 int arr[3] = {1,2,3};\n(3) 可以使用部分列表初始化 int arr[3] = {1}; 得到的是 1，0，0\n(4) static数组默认会把所有元素初始化为0值\n  元素引用\n下表从0开始到最大值减一\n  数组名\n数组名就是数组类型，而不是指针（见参考资料1）\n  数组越界\n数组获取值的过程实际上是计算指针解引用 arr[i] = *(\u0026amp;arr[0]+i)\n  二维数组\n  定义，初始化\n【存储类型】 数组类型 标识符【行下标】【列下标】\n  元素引用\n数组名【行标】【列标】\n  存储形式\n行主序的方式线性存储\n  深入理解二维数组\n二维数组是元素是数组的一个数组，a[2][3]表示的是一个数组a[2]，有两个元素，每一个元素都是一个大小为[3]的数组，于是a+1，移动的大小是3个元素的大小\n  字符数组\n  定义，初始化，存储特点\n【存储类型】数据类型 标识符【下标】 \u0026hellip;\n初始化方式：\n（1）单个字符初始化 char str[] = {\u0026lsquo;a\u0026rsquo;, \u0026lsquo;b\u0026rsquo;, \u0026lsquo;c\u0026rsquo;};\n（2）字符串常量初始化 char str[] = \u0026ldquo;abc\u0026rdquo;\n  输入输出\n  常用函数\n位于头文件\u0026lt;string.h\u0026gt;中：\nstrlen(以尾0为结束计算数据大小)\nstrcpy\nstrcat\nstrcmp\n  多维数组\n分拆成多级来分析  5. 参考资料 1. Is an array name a pointer?\n","description":"","id":8,"section":"backup","tags":null,"title":"LinuxC编程随笔（C语言中的数组-10）","uri":"https://blog.healex.xyz/backup/linux_c_10/"},{"content":"1. 一句话总结 介绍C语言中的顺序、选择、循环流程控制相关内容\n2. 课程内容 2.1 goto使用注意事项 goto语句会造成程序的跳转混乱，如果确实goto可以带来代码的简洁（比如多重循环需要跳出时，使用goto直接从最内侧跳出是一个不错的使用方式）那么可以去用。但是其他场景最好不要用。\ngoto使用时不能够跳过变量的定义，比如下面的代码：\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main(){ goto Label; int j = 7; Label:\tprintf(\u0026quot;%d\\n\u0026quot;,j); } Label跳转语句掠过了j和k的定义，应该是有问题的。\n不过上述代码我在测试的时候发现在GCC中把文件名后缀改成.c编译不会报错，但是改成.cpp使用g++编译时会报错\n基本的控制语句，内容比较简单，略\n3. 动手写代码 4. 课堂笔记 流程控制\n顺序、选择、循环\nNS图，流程图（工具Dia）\n简单结构与复杂结构：自然流程\n顺序：语句逐句执行\n选择：出现了一种以上的情况\n循环：重复执行某个动作（在某个条件成立的情况下）\n关键字：\n选择： if\u0026hellip;else if..elseif..else switch-case\n循环： while, do\u0026hellip;while for if-goto\n辅助控制： continue, break\n如果写if\u0026hellip;else， else与最近的if进行匹配\n超过多条语句的if或者else需要用花括号括起来\nif\u0026hellip;goto 可以构成循环（慎用：goto实现的是无条件的跳转，且不能跨函数跳转）\n死循环：\nwhile(1);\nfor(;;);\nctrl+c杀死死循环\n5. 参考资料 ","description":"","id":9,"section":"backup","tags":null,"title":"LinuxC编程随笔（C语言流程控制-9）","uri":"https://blog.healex.xyz/backup/linux_c_9/"},{"content":"1. 一句话总结 介绍LinuxC中的标准IO函数\nC语言中的输入输出\n2. 课程内容 2.1 printf函数 printf的语法格式如下：\nint printf ( const char * format, ... ); 这个原型中的format的内容包括以下几部分：\n%[flags][width][.precision][length]specifier  specifier是格式字符，包括 %d %s %c %f %g 等 flags标识左右对齐，添加+(-)前缀，补0对齐等 width：设置输出宽度，如果输出内容小于width，用空格补充，大于width，无作用 .precision（注意是点+精度位数），浮点数输出小数点位数；字符串输出字符个数  2.2 输出中添加换行符对printf打印调试大法的影响 某些情况下在不方便调试时，printf打印调试信息大法是比较好用的一种除错方法，但是有一些细节需要注意，比如下面的程序\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main() { printf(\u0026quot;[%s:%d] before while().\u0026quot;, __func__, __LINE__); while(1); printf(\u0026quot;[%s:%d] after while().\u0026quot;, __func__, __LINE__); exit(0); } 在运行过程中，程序会卡住什么也输出不了。原因在于printf是行缓冲模式，遇到换行符或者缓冲区满才会输出，而这里的缓冲区并未满，因此就会输出不了任何内容，导致调试无效\n2.3 scanf函数在循环内需要小心处理 scanf在循环内时，如果用户给的输入不合法会造成一些问题，导致循环无法结束，因为此时输入的流已经被破坏了。因此为了避免这种情况，需要小心的检查scanf的函数返回值，确保程序确实匹配到用户成功的输入项，比如：\nwhile(1) { ret = scanf(\u0026quot;%d\u0026quot;, \u0026amp;i); if (ret != 1) //判断用户输入真的是一个整数（scanf函数返回值是成功匹配的项数） { break; } } 2.4 scanf输入中使用抑制符* *可以只接受数据但是不给任何赋值，比如下面的代码\nint i; char ch; scanf(\u0026quot;%d\u0026quot;, \u0026amp;i); scanf(\u0026quot;%c\u0026quot;, \u0026amp;ch); 如果在输入时，用户先输入 24-\u0026gt;回车-\u0026gt;a，结果不正确，ch取到回车的值，而不是a\n修改为：\nint i; char ch; scanf(\u0026quot;%d\u0026quot;, \u0026amp;i); scanf(\u0026quot;%*c%c\u0026quot;, \u0026amp;ch); 让回车字符被接收，但是直接丢弃，这样可以得到正确的i=24，ch=\u0026lsquo;a\u0026rsquo;\n另外一种处理方式是使用getchar()\nint i; char ch; scanf(\u0026quot;%d\u0026quot;, \u0026amp;i); getchar(); scanf(\u0026quot;%c\u0026quot;, \u0026amp;ch); 3. 动手写代码 习题一 一个水分子的质量大约为 $$3.0*10^{-23}$$克，1夸脱水大约有950克，编写程序要求从终端输入水的夸脱数，然后显示这么多夸脱水中包含有大约多少水分子？\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #define WEIGHT 3.0e-23 #define KQ 950 int main() { float num; float sum; printf(\u0026quot;Please input water num:\u0026quot;); scanf(\u0026quot;%f\u0026quot;,\u0026amp;num); sum = num * KQ / WEIGHT; printf(\u0026quot;total kq is %e\\n\u0026quot;, sum); exit(0); } 其他习题比较简单（略）\n4. 课堂笔记 三、输入输出专题\ninput \u0026amp; output -\u0026gt; I/O (标准IO，文件IO)\n  格式化输入/输出 函数： scanf，printf\nint printf(const char *format, \u0026hellip;);\nformat: \u0026ldquo;% [修饰符] 格式字符\u0026rdquo;\nint scanf(const char format, \u0026hellip;);\nformat:抑制符\n%s的使用是比较危险的，因为不知道存储空间大小\nscanf放在循环结构中要注意能否接收到正常有效的内容\n  字符输入/输出 函数： getchar, putchar\n  字符串输入/输出 函数： gets(!), puts\ngets:十分危险的函数，可以用fgets，getline（Linux GNU的dialect）来替代\n  5. 参考资料 1. printf\n","description":"","id":10,"section":"backup","tags":null,"title":"LinuxC编程随笔（输入输出专题-8）","uri":"https://blog.healex.xyz/backup/linux_c_8/"},{"content":"1. 一句话总结 介绍C语言中的各种运算符\n2. 课程内容 2.1 自增/减的前后缀表达式 i++ ：变量在前，先取变量值使用，再进行计算\n++i：运算符在前，先进行计算，再取变量值使用\n备注：个人不是很建议写一些tricky的代码，比如 i++ + ++j 这样的代码，这样写是不好的代码，虽然可以分析出来是什么意义，但是可读性极差。不便于团队开发 2.2 逻辑运算符的短路特性 逻辑运算符包括 或(||) 与(\u0026amp;\u0026amp;) 非(!)\n对于 || 和 \u0026amp;\u0026amp; 操作符的结果如下\na || b\n1 || 0 = 1\n0 || 1 = 1\n0 || 0 = 0\n1 || 1 = 1\na \u0026amp;\u0026amp; b\n1 \u0026amp;\u0026amp; 0 = 0\n0 \u0026amp;\u0026amp; 1 = 0\n1 \u0026amp;\u0026amp; 1 = 1\n0 \u0026amp;\u0026amp; 0 = 0\n再逻辑运算中，如果一旦可以通过第一个操作数决定值，那么就不往下再计算了，比如\na || b，一旦计算得到a是true，那么b（如果是一个表达式），那么b表达式是不会进行计算的\n3. 动手写代码 暂无\n4. 课堂笔记 运算符和表达式  表达式与语句的区别\n运算符部分：\n1）每个运算符所需要的参与运算的操作数个数\n2）结合性\n3）优先级\n4）运算符的特殊用法\n%（取余）运算符两侧必须是整型数\n= 和 == （一个是赋值运算符、一个是判断相等的关系运算符）\n逻辑运算符（\u0026amp;\u0026amp;和||）的短路特性\n5）位运算的重要意义\n将操作数中第n位位置为1， 其他位不变 num = num | (1 \u0026laquo; n)\n将操作数中第n位清零，其他位不变 num = num \u0026amp; ~(1 \u0026laquo; n)\n测试指定第n位： if (num \u0026amp; (1 \u0026laquo; n))\n从一个指定宽度的数中取出其中的某几位？\n5. 参考资料 ","description":"","id":11,"section":"backup","tags":null,"title":"LinuxC编程随笔（C语言运算符-7）","uri":"https://blog.healex.xyz/backup/linux_c_7/"},{"content":"1. 一句话总结 介绍C语言中的变量\n2. 课程内容 2.1 C语言的编译模块 C语言中的编译是以.c文件作为单独模块进行编译的，一个.c文件会被编译成一个独立的模块，在链接阶段会把所有的模块链接成最终的可执行文件。\n在某一个模块中使用的全局变量如果想要被其他模块引用，其他模块可以用 extern进行声明，表示这个全局变量来自于其他模块，本模块只是想使用它的值而已。\n如果一个变量或者函数被声明为 static 类型的，那么其他模块就无法引用这个变量和模块了，因为这个static声明会把变量或者函数设定为模块自用的（自己内部使用，概不外借）\n如果其他模块确实是要用本模块的static函数，那么可以在本模块中写一个非static函数，并在这个非static函数中调用本模块的static函数，相当于封装一层\n3. 动手写代码 无\n4. 课堂笔记 变量：用来保存一些特定内容，并且在程序执行过程中值随时会发生变化的量\n定义： [存储类型] 数据类型 标识符 = 值\nType name = value;\n标识符：由字母、数字、下划线组成的不能以数字开头的标识序列 写标识符尽量做到见名生义 数据类型：基本数据类型 + 构造类型 值：注意匹配 存储类型：auto static register extern（说明型） auto：默认，自动分配空间，自动回收空间； register：（建议型）寄存器类型， 只能定义局部变量，不能定义全局变量，大小有限制，只能定义32位大小的数据类型，如double就不可以，寄存器没有地址，所以一个寄存器类型的变量无法打印处地址查看或使用 static：静态变量，自动将变量初始化为0值或者空值，并且这种类型变量的值有继承性 static：可以用来修饰一个变量或者函数 extern：说明型，意味着不能改变被说明的变量的值和类型 变量的生命周期和作用范围 1）全局变量和局部变量 2）局部变量  5. 参考资料 ","description":"","id":12,"section":"backup","tags":null,"title":"LinuxC编程随笔（C语言中的变量-6）","uri":"https://blog.healex.xyz/backup/linux_c_6/"},{"content":"1. 一句话总结 介绍C语言中各种类型的常量值\n2. 课程内容 2.1 数组名是一个常量 面试提醒：以下哪些是非法的常量： '\\012' '\\345' '\\138` 结论是 '\\138'，因为8进制不包含8这个数，三位8进制的数加上反斜杠用来转义得到一个字符常量，因此是错误的 2.2 宏替换带来的一些问题 观察以下程序的输出\n#include \u0026lt;stdio.h\u0026gt; #define PI 3.14 #define MAX(a,b) ((a) \u0026gt; (b) ? (a) : (b)) int main() { int i = 5; int j = 3; printf(\u0026quot;i=%d\\tj=%d\\n\u0026quot;, i,j); printf(\u0026quot;Max: %d\\n\u0026quot;, MAX(i++, j++)); printf(\u0026quot;i=%d\\tj=%d\\n\u0026quot;,i,j); return 0; } 程序输出的结果\ni=5\tj=3 Max: 6 i=7\tj=4 在替换MAX(i++,j++)后，表达式变成了\n printf(\u0026quot;Max: %d\\n\u0026quot;, ((i++) \u0026gt; (j++) ? (i++) : (j++))); 较大的那个数一定会自增2次，这个可能并不是我们想要的结果。因此在使用宏替换时要特别小心\n解决方式，标准C没有办法解决这样的情形，使用GCC的扩展\n#define MAX(a,b) ({typeof(a) A=a,B=b; ((A)\u0026gt;(B) ? (A):(B));}) 下面这段代码在GCC中没有问题，可以正常编译通过\n#include \u0026lt;stdio.h\u0026gt; #define PI 3.14 //#define MAX(a,b) ((a) \u0026gt; (b) ? (a) : (b)) #define MAX(a,b) ({int A=a,B=b; ((A)\u0026gt;(B) ? (A):(B));}) int main() { int i = 5; int j = 3; printf(\u0026quot;i=%d\\tj=%d\\n\u0026quot;, i,j); printf(\u0026quot;Max: %d\\n\u0026quot;, MAX(i++, j++)); printf(\u0026quot;i=%d\\tj=%d\\n\u0026quot;,i,j); return 0; } 但是在Visual Studio 2019 中却报语法错误\n3. 动手写代码 无\n4. 课堂笔记 常量与变量  常量：在程序执行过程中值不会发生变化的量\n常量分类：\n 整型常量： 1， 33， 1234 实型常量： 3.134， 23.23，9.0 字符常量：由单引号引起来的单个的字符或转移字符（\u0026lsquo;a\u0026rsquo;, \u0026lsquo;\\n\u0026rsquo;, \u0026lsquo;\\1\u0026rsquo;，'\\012', \u0026lsquo;\\x7f\u0026rsquo;） 字符串常量：有双引号引起来的一个或多个字符组成的序列，如 \u0026ldquo;af3es\u0026rdquo;, \u0026quot;\u0026quot; 标识常量: #define (只做替换，不会进行类型检查),处理在程序的预处理阶段，占用编译时间，一改全改  5. 参考资料 ","description":"","id":13,"section":"backup","tags":null,"title":"LinuxC编程随笔（C语言中的常量-5）","uri":"https://blog.healex.xyz/backup/linux_c_5/"},{"content":"1. 一句话总结 基本数据类型和存储方式\n2. 课程内容 2.1 整型数在内存中存储方式 整型数在内存中使用补码的形式存储：\n 正数的补码是它二进制本身 负数的补码是它绝对值二进制取反加一  2.2 十进制转换到其他进制 可以采用短除法，把得到的余数倒序排列得到结果\n2.3 浮点类型在内存中的存储方法 2.4 字符类型在内存中的存储方式 使用的就是整型的存储方式，但是字符表示的内容需要查询ASCII表\nchar类型在C语言中是没有明确定义它是 signed char 还是 unsigned char的\n2.5 浮点数判断相等 可以使用 fabs(a-b) \u0026lt; 1e-6 来判别\n3. 动手写代码 4. 课堂笔记 二、数据类型，运算符和表达式\n 数据类型：（基本数据类型）  1）所占字节数\n2）存储区别\n3）不同类型的数据之间的转换（隐式、显式\u0026ndash;\u0026gt;强制类型转换）\n4）特殊性：\n（1）布尔类型bool\n（2）float类型\n（3）char型是否有符号\n（4）不同形式的0值：0, \u0026lsquo;0\u0026rsquo;, \u0026ldquo;0\u0026rdquo;, \u0026lsquo;\\0\u0026rsquo;\n(5) 数据类型与后续代码中所使用的输入输出要相匹配（防止自相矛盾）\n5. 参考资料  Data Types In C : Learn C Data Type with Examples  ","description":"","id":14,"section":"backup","tags":null,"title":"LinuxC编程随笔（C语言基本数据类型和存储方式-4）","uri":"https://blog.healex.xyz/backup/linux_c_4/"},{"content":"1. 一句话总结 编码中的一些小建议\n2. 课程内容 2.1 引入函数时一定要包含头文件 在C语言中有一个叫做 \u0026ldquo;implicit function declaration\u0026rdquo;（隐式函数声明）的特性（或者说时缺陷），在C89中是这样处理的，但是在C99中已经明确移除了这个缺陷，但是GCC在编译的时候即使加上C99的标识仍然不报错1\n基本的描述是：\n** 当编译器发现一个没有声明的函数调用时，它会假设这个函数返回 int 类型的返回值 **\n在实际编码中，最好是不要使用隐式的函数声明，在使用一个函数时明确引入包含它的头文件（在GCC中默认会给出警告，可以通过设置 -Werror=implicit-function-declaration 参数让GCC遇到隐式函数声明时报错）\n2.2 main函数没有显式给出返回值 视频中的讲解在未给出返回值时，提及返回的是printf的返回值，但是与我个人的验证并不相同。\n我的环境：Ubuntu 18.06使用GCC的版本 gcc (Ubuntu 8.4.0-1ubuntu1~18.04) 8.4.0\n在编写下面的代码时：\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main() { printf(\u0026quot;hello,world\\n\u0026quot;); //\treturn 0; } 生成可执行程序，执行可执行程序后，通过在Bash上打印出$? 结果仍然是 0.\n安装参考资料中的提示，这个应该后续的C标准有做更改，在此写出我的验证。\n2.3 注释编写方式 （1）短注释可以用双斜线 //\n（2）文件最前面的解释，可以用 /* */\n（3）大段的注释建议用\n#if 0\n#endif\n3. 动手写代码 3.1 由于未引入头文件造成段错误例子\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt;\t//#include \u0026lt;string.h\u0026gt; #include \u0026lt;errno.h\u0026gt; int main(void) { FILE *fp; fp = fopen(\u0026quot;tmp\u0026quot;,\u0026quot;r\u0026quot;); if (fp == NULL) { fprintf(stderr,\u0026quot;fopen error: %s\\n\u0026quot;, strerror(errno)); exit(-1); } return 0;\t}\t4. 课堂笔记 一、基本概念\n 以helloworld为例对写程序的思路提出如下要求：  （1）头文件正确包含的重要性\n（2）以函数未单位来进行进程程序编写\n（3）声明部分+实现部分【先声明后使用】（新的C版本反倒建议随时定义随时使用，类似于C++，选择一种风格保持一致即可）\n（4）main 函数记得return\n（5）多用空格和空行，增强代码可读性\n（6）添加适量的注释，未来某个时候你会感谢当时的你\n 算法：解决问题的方法（流程图、NS图、有限状态机(FSM)）\n  程序：用某种语言实现算法\n  进程：\n  防止写越界、防止内存泄漏、谁打开谁关闭，谁申请谁释放\n  5. 参考资料  关于gcc内置函数和c隐式函数声明的认识以及一些推测 C语言隐式声明与GCC内建函数 c语言中，如果main函数的末尾没有return语句将会有什么影响?   stackoverflow: Implicit function declarations in C.)\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","description":"","id":15,"section":"backup","tags":null,"title":"LinuxC编程随笔（编码建议-3）","uri":"https://blog.healex.xyz/backup/linux_c_3/"},{"content":"1. 简介  OpenWRT从19.07开始逐步将网页的渲染模式从服务端移到客户端，由此带来的一个显著的变化是luci开发的Lua代码大幅减少，取而代之的是JavaScript代码的增加。今后在处理界面的逻辑上基本上都是使用JavaScript来处理了。OpenWRT 19.07系列应该是一个逐步转型的版本，在这个版本中可以支持两种模式的luci-app开发，包括：\n 使用传统的Lua方式编写网页界面（主要是 Call、Template、CBI这三种方式） 使用新式的JS+css+html的方式来编写界面   在OpenWRT 19.07中由于有大量的app尚未迁移到新的模式，为了兼容老的luci-app，可以安装luci-app-compat这个工具包来实现运行老的luci-app\n本文主要说明当前luci-app如何去编辑网页的菜单栏，把我们编写的程序放在对应的菜单栏下（菜单栏这个说法可能不准确，这个是我个人的称呼，指的是下图的内容）\n 在本文写作时，最新的19.07版本是19.07.7，在安装这个版本后，我发现当前的luci-app主要有三种形态：\n 完全没有迁移的app，还是使用18.06方式编写的界面 部分迁移的app，使用兼容模式运行 完全使用JavaScript改写的app  以一个对应的luci-app来说明每一种模式\n2. 未迁移的luci-app  在OpenWRT19.07.7的版本中，可以去opkg安装 luci-app-https-dns-proxy 这个luci-app，它就是尚未迁移的一个app，在安装之后，主要添加的文件包括：\n /usr/lib/lua/luci/controller/https-dns-proxy.lua  这个在菜单栏上的Services目录下添加了 DNS HTTPS Proxy这一项，查看文档中的内容：\nmodule(\u0026quot;luci.controller.https-dns-proxy\u0026quot;, package.seeall) function index() if nixio.fs.access(\u0026quot;/etc/config/https-dns-proxy\u0026quot;) then entry({\u0026quot;admin\u0026quot;, \u0026quot;services\u0026quot;, \u0026quot;https-dns-proxy\u0026quot;}, cbi(\u0026quot;https-dns-proxy\u0026quot;), _(\u0026quot;DNS HTTPS Proxy\u0026quot;)).acl_depends = { \u0026quot;luci-app-https-dns-proxy\u0026quot; } entry({\u0026quot;admin\u0026quot;, \u0026quot;services\u0026quot;, \u0026quot;https-dns-proxy\u0026quot;, \u0026quot;action\u0026quot;}, call(\u0026quot;https_dns_proxy_action\u0026quot;), nil).leaf = true end end function https_dns_proxy_action(name) local packageName = \u0026quot;https-dns-proxy\u0026quot; local http = require \u0026quot;luci.http\u0026quot; local sys = require \u0026quot;luci.sys\u0026quot; local util = require \u0026quot;luci.util\u0026quot; if name == \u0026quot;start\u0026quot; then sys.init.start(packageName) elseif name == \u0026quot;action\u0026quot; then util.exec(\u0026quot;/etc/init.d/\u0026quot; .. packageName .. \u0026quot; reload \u0026gt;/dev/null 2\u0026gt;\u0026amp;1\u0026quot;) elseif name == \u0026quot;stop\u0026quot; then sys.init.stop(packageName) elseif name == \u0026quot;enable\u0026quot; then sys.init.enable(packageName) elseif name == \u0026quot;disable\u0026quot; then sys.init.disable(packageName) end http.prepare_content(\u0026quot;text/plain\u0026quot;) http.write(\u0026quot;0\u0026quot;) end 在传统的luci-app开发过程中，对于一个菜单的响应有3种方式：分别是执行指定方法（Action）、访问指定页面（Views）以及调用CBI Module。\n第一种可以直接调用指定的函数，比如点击菜单项就直接重启路由器等等，比如写为“call(\u0026quot;function_name\u0026quot;)”，然后在lua文件下编写名为function_name的函数就可以调用了。 第二种可以访问指定的页面，比如写为“template(\u0026quot;myapp/mymodule\u0026quot;)”就可以调用/usr/lib/lua/luci/view/myapp/mymodule.htm文件了。 第三种方法无非是最方便的，比如写为“cbi(\u0026quot;myapp/mymodule\u0026quot;)”就可以调用/usr/lib/lua/luci/model/cbi/myapp/mymodule.lua文件了。 可以看到响应菜单的方式是通过调用cbi和call的方式进行的，cbi的model文件位置在 /usr/lib/lua/luci/model/cbi/https-dns-proxy.lua\n以上就是传统的luci-app开发方式，主要使用lua语言进行操作的交互响应。\n3. 部分迁移的luci-app  部分迁移的luci-app主要是将菜单的响应部分迁移到 javascript中（/www/luci-static/resources)，在19.07.7下的 luci-app-adblock 就是一个部分迁移的例子\n在 luci-app-adblock 中，配置菜单栏上的菜单项也是在controller目录中的adblock.lua文件中进行的，这个文件内容如下：\n-- stub lua controller for 19.07 backward compatibility module(\u0026quot;luci.controller.adblock\u0026quot;, package.seeall) function index() entry({\u0026quot;admin\u0026quot;, \u0026quot;services\u0026quot;, \u0026quot;adblock\u0026quot;}, firstchild(), _(\u0026quot;Adblock\u0026quot;), 60) entry({\u0026quot;admin\u0026quot;, \u0026quot;services\u0026quot;, \u0026quot;adblock\u0026quot;, \u0026quot;overview\u0026quot;}, view(\u0026quot;adblock/overview\u0026quot;), _(\u0026quot;Overview\u0026quot;), 10) entry({\u0026quot;admin\u0026quot;, \u0026quot;services\u0026quot;, \u0026quot;adblock\u0026quot;, \u0026quot;dnsreport\u0026quot;}, view(\u0026quot;adblock/dnsreport\u0026quot;), _(\u0026quot;DNS Report\u0026quot;), 20) entry({\u0026quot;admin\u0026quot;, \u0026quot;services\u0026quot;, \u0026quot;adblock\u0026quot;, \u0026quot;blacklist\u0026quot;}, view(\u0026quot;adblock/blacklist\u0026quot;), _(\u0026quot;Edit Blacklist\u0026quot;), 30) entry({\u0026quot;admin\u0026quot;, \u0026quot;services\u0026quot;, \u0026quot;adblock\u0026quot;, \u0026quot;whitelist\u0026quot;}, view(\u0026quot;adblock/whitelist\u0026quot;), _(\u0026quot;Edit Whitelist\u0026quot;), 40) entry({\u0026quot;admin\u0026quot;, \u0026quot;services\u0026quot;, \u0026quot;adblock\u0026quot;, \u0026quot;logread\u0026quot;}, view(\u0026quot;adblock/logread\u0026quot;), _(\u0026quot;Log View\u0026quot;), 50) end 可以看到它的调用方式不是传统luci-app方式那3种方式中的任何一种，而是一种全新的使用JavaScript进行响应的方式，这里面的view(adblock/*)对应的是/www/luci-static/resources/view 目录下的js文件\n也就是说在这种过渡方案模式下，有以下特点：\n 菜单栏的配置还是使用传统的luci-app方式进行的，仍然是在 controller 目录中配置 对于菜单栏的响应设置在新的JavaScript脚本中进行  4. 完全迁移的luci-app 上面提到了过渡模式下菜单栏和对菜单栏响应方式的变化，最新的OpenWRT的实现中，菜单栏和对菜单栏的响应都不在传统的 /usr/lib/lua/luci 目录下进行了，而是采用下面这种处理方式\n 菜单栏的配置修改到 /usr/share/luci/menu.d 目录中，并且配置文件使用.json文件 对菜单栏的响应修改到 /www/luci-static/resources 目录中，并且响应的脚本都是.js文件  我们查看这个menu.d目录中的 luci-base.json 文件，可以看到文件中列举出所有标题栏上显示的内容\n{ \u0026quot;admin\u0026quot;: { \u0026quot;title\u0026quot;: \u0026quot;Administration\u0026quot;, \u0026quot;order\u0026quot;: 10, \u0026quot;action\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;firstchild\u0026quot;, \u0026quot;recurse\u0026quot;: true }, \u0026quot;auth\u0026quot;: { \u0026quot;methods\u0026quot;: [ \u0026quot;cookie:sysauth\u0026quot; ], \u0026quot;login\u0026quot;: true } }, \u0026quot;admin/status\u0026quot;: { \u0026quot;title\u0026quot;: \u0026quot;Status\u0026quot;, \u0026quot;order\u0026quot;: 10, \u0026quot;action\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;firstchild\u0026quot;, \u0026quot;preferred\u0026quot;: \u0026quot;overview\u0026quot;, \u0026quot;recurse\u0026quot;: true } }, \u0026quot;admin/system\u0026quot;: { \u0026quot;title\u0026quot;: \u0026quot;System\u0026quot;, \u0026quot;order\u0026quot;: 20, \u0026quot;action\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;firstchild\u0026quot;, \u0026quot;preferred\u0026quot;: \u0026quot;system\u0026quot;, \u0026quot;recurse\u0026quot;: true } }, \u0026quot;admin/vpn\u0026quot;: { \u0026quot;title\u0026quot;: \u0026quot;VPN\u0026quot;, \u0026quot;order\u0026quot;: 30, \u0026quot;action\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;firstchild\u0026quot;, \u0026quot;recurse\u0026quot;: true } }, \u0026quot;admin/services\u0026quot;: { \u0026quot;title\u0026quot;: \u0026quot;Services\u0026quot;, \u0026quot;order\u0026quot;: 40, \u0026quot;action\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;firstchild\u0026quot;, \u0026quot;recurse\u0026quot;: true } }, ... //省略其他配置 }  如果我们想要添加自己的顶层菜单，是可以直接编辑这个文件的。但是并不推荐这么做，因为如果每一个组织或个人开发的程序都要添加自己的顶层菜单，那么会造成这个文件修改的混乱，更好的办法是自己创建一个.json的文件，并采用类似luci-base.js 的写法，比如我想创建一个名称是\u0026quot;HZX\u0026quot;的顶层菜单，那么可以添加一个文件\nluci-hzxtopmenu.js文件，文件内容如下：\n{ \u0026quot;admin/hzxtopmenu\u0026quot;: { //菜单对应在网页url中的地址后缀 \u0026quot;title\u0026quot;: \u0026quot;HZX\u0026quot;, //菜单栏上显示的名称 \u0026quot;order\u0026quot;: 80, //菜单栏的显示顺序（越大越在后面） \u0026quot;action\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;firstchild\u0026quot;, \u0026quot;recurse\u0026quot;: true } } } 只添加这一个文件并不能在菜单栏上显示 \u0026ldquo;HZX\u0026rdquo; ，我们需要在 \u0026ldquo;HZX\u0026rdquo; 下面添加一个子菜单选项，添加方式也是模仿已有app的写法，比如我们创建一个luci-app-goshadowsock2.json的文件，文件内容如下：\n{ \u0026quot;admin/hzxtopmenu/goshadowsocks2\u0026quot;: { \u0026quot;title\u0026quot;: \u0026quot;GoShadowsocks2\u0026quot;, \u0026quot;order\u0026quot;: 10, \u0026quot;action\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;view\u0026quot;, \u0026quot;path\u0026quot;: \u0026quot;goshadowsocks2/overview\u0026quot; } } } 这样就可以在HZX菜单项的下面添加一个叫GoShadowsocks2的子菜单项，并且点击它之后的响应转到 /www/luci-static/resources/view/goshadowsocks2/overview.js 文件中去处理，后续要做的事情就是使用JavaScript脚本完善用户点击的响应。\n下图是添加这些文件后的效果\n","description":"","id":16,"section":"posts","tags":null,"title":"OpenWRT-19.07Luci编辑菜单方法","uri":"https://blog.healex.xyz/posts/edit_menu_openwrt19.07/"},{"content":"1. 简介 OpenWRT19.07的一个重大的改动是将之前OpenWRT的Luci框架做了比较大的调整，最主要集中在将Luci的渲染方式从之前的服务端渲染模式调整到客户端的渲染模式。据OpenWRT官方说这种改动可以提升默写老旧设备的性能，将渲染网页的工作从路由器转移到用户的客户端设备。\n由于OpenWRT中luci-app非常众多，在本文写作时（最新版本是19.07.7）官方feeds中的luci-application仍然只改写了一小部分，后续估计官方会持续推进。鉴于目前19.07版本处于一种新旧方式过渡的阶段，大量老的使用lua编写的app尚未完全移植，因此如果发现老的app在19.07上运行异常（大部分都是由于cbi.lua造成的），官方给出了一些建议，包括：\n 安装luci-compat包（提供老代码的兼容方式运行） 如果页面加载缓慢，可以考虑安装 uhttpd-mod-ubus 页面加载缓慢或修改设置之后，建议重新打开浏览器标签页（或者重启浏览器）  以下我们对 19.07前后两种不同方式的luci-app开发作一个比较，挑选18.06（19.07的上一个稳定发行版）和19.07进行对比分析\n2. 18.06的luci-app风格 2.1 luci-app开发的主要方式 主要是使用openwrt提供的框架，使用lua语言进行开发，采用MVC的架构方式，在 /usr/lib/lua/luci 目录中提供有 model、controller和view几个目录，在controller目录中通过编写lua文件，生成网页上的界面菜单并且指定如何处理点击菜单之后的响应。\n响应主要通过3种方式提供：\n（1）直接调用函数的方式，比如下面的示例展示了如何调用函数响应\nmodule(\u0026quot;luci.controller.myapp.mymodule\u0026quot;, package.seeall) function index() entry({\u0026quot;click\u0026quot;, \u0026quot;here\u0026quot;, \u0026quot;now\u0026quot;}, call(\u0026quot;action_tryme\u0026quot;), \u0026quot;Click here\u0026quot;, 10).dependent=false end function action_tryme() luci.http.prepare_content(\u0026quot;text/plain\u0026quot;) luci.http.write(\u0026quot;Haha, rebooting now...\u0026quot;) luci.sys.reboot() end 再我们点击某个菜单项时，这个菜单会调用action_tryme函数\n（2）通过调用一个html页面来响应\nentry({\u0026quot;my\u0026quot;, \u0026quot;new\u0026quot;, \u0026quot;template\u0026quot;}, template(\u0026quot;myapp-mymodule/helloworld\u0026quot;), \u0026quot;Hello world\u0026quot;, 20).dependent=false 代码会调用 /usr/lib/lua/luci/view/myapp-mymodule/helloworld.htm这个页面来响应用户的点击\n（3）通过CBI的方式来响应\n这种方式也是用的比较多的一种方式，它通过编写一个lua文件来生成一个网页（包含大量的网页中控件），这些控件对应着lua中的一些类型，并且这些类型直接和uci的配置文件绑定，示例如下：\nm = Map(\u0026quot;network\u0026quot;, \u0026quot;Network\u0026quot;) -- 对应着一个配置文件 /etc/config/network s = m:section(TypedSection, \u0026quot;interface\u0026quot;, \u0026quot;Interfaces\u0026quot;) -- s对应着network这个文件中的某一个配置块 s.addremove = true -- Allow the user to create and remove the interfaces function s:filter(value) return value ~= \u0026quot;loopback\u0026quot; and value -- Don't touch loopback end s:depends(\u0026quot;proto\u0026quot;, \u0026quot;static\u0026quot;) -- Only show those with \u0026quot;static\u0026quot; s:depends(\u0026quot;proto\u0026quot;, \u0026quot;dhcp\u0026quot;) -- or \u0026quot;dhcp\u0026quot; as protocol and leave PPPoE and PPTP alone ... gw = s:option(Value, \u0026quot;gateway\u0026quot;, \u0026quot;Gateway\u0026quot;) gw:depends(\u0026quot;proto\u0026quot;, \u0026quot;static\u0026quot;) gw.rmempty = true -- Remove entry if it is empty return m -- 返回配置 当用户进行操作之后，它会把用户的操作对应到uci文件中的具体选项中，在保存的时候写入到配置文件中\n2.1 lua-app安装包的目录结构 老版本的luci-app的目录结构如下图所示：\n/ ├── etc/ │ ├── config/ │ │ └── shadowsocks // UCI 配置文件 │ │── init.d/ │ │ └── shadowsocks // init 脚本 │ └── uci-defaults/ │ └── luci-shadowsocks // uci-defaults 脚本 └── usr/ ├── bin/ │ └── ss-rules // 生成代理转发规则的脚本 └── lib/ └── lua/ └── luci/ // LuCI 部分 ├── controller/ │ └── shadowsocks.lua // LuCI 菜单配置 ├── i18n/ // LuCI 语言文件目录 │ └── shadowsocks.zh-cn.lmo └── model/ └── cbi/ └── shadowsocks/ ├── general.lua // LuCI 基本设置 ├── servers.lua // LuCI 服务器列表 ├── servers-details.lua // LuCI 服务器编辑 └── access-control.lua // LuCI 访问控制 这是一个luci-app ipk包内的文件结构，这些文件会被拷贝到OpenWRT系统中对应的位置，可以看到主题的交互文件就是在/usr/lib/lua/luci的model、controller目录中。除此之外还需要搭配一些配置文件、应用程序的启动初始化脚本、翻译文件，构成整个应用程序。\n3. 19.07的luci-app风格 新的luci-app把之前的模式进行了非常多的修改，首先一个最主要的改动就是减少了大量的lua代码，新的luci-app采用的是Javascript进行开发，并且页面基本上都是使用网页的方式来呈现（也就是直接编写html的文档，有点类似于18.06响应模式的第2种）\n新的luci-app包的文件结构如下：\nopenwrt ┕feeds ┕luci ┕applications ┕luci-app-name #界面程序的主目录 ┕htdocs ┊ ┕luci-static ┊ ┕resources ┊ ┕view ┊ ┕name.js # JavaScript 脚本界面文件。 ┕po ┊ ┕zh_Hans # 此目录名称对应简体中文。 ┊ ┕name.po # 界面语言翻译文件。 ┕root ┊ ┕etc ┊ ┊ ┕uci-defaults ┊ ┊ ┕luci-app-name # 软件安装完毕后默认执行的脚本（一次性脚本），可选。 ┊ ┕usr ┊ ┕share ┊ ┕luci ┊ ┊ ┕menu.d ┊ ┊ ┕luci-app-name.json # 界面菜单，在系统菜单中的名称、顺序等。 ┊ ┕rpcd ┊ ┕acl.d ┊ ┕luci-app-name.json # 权限控制文件，管控界面能执行的各类操作。 ┕Makefile # 编译文件。 下面这个链接给出了一个移植到新版本的luci-app程序相对于老版本的修改内容：\n luci-app-minidlna的改动  https://github.com/openwrt/luci/commit/9ae591b38fedf16c3e5c97350b7182c5e28ed71f#diff-27855472049b664538cca7ef50c43df8\n4. 参考资料 1.OpenWrt 19.07.0 - First Stable Release - 6 January 2020\n2. OpenWrt达人教程之开发人员入门指南\n3. OpenWRT18.06 IPK的目录结构\n","description":"","id":17,"section":"posts","tags":null,"title":"OpenWRT 19.07 Luci框架的改变","uri":"https://blog.healex.xyz/posts/openwrt_19.07_luci_changes/"},{"content":"1. 一句话总结 主要介绍GCC编译工具和Vim编辑器的基本用法\n2. 课程内容 2.1 vim使用技巧 vim编辑器的配置文件在/etc/vim/vimrc中（环境：Ubuntu18.06下配置文件），这个文件是一个全局的配置，建议在自己的家目录中配置自己使用的vim环境脚本，配置文件 .vimrc文件（注意文件名以点开头）\n基本的vim使用方式参考vim官方手册，可以尝试安装一些vim的插件来扩展vim功能，比如\n2.2 GCC使用参数 GCC是GNU提供的一系列编译器的集合，可以支持多种编程语言的编译，其中最常用的是C/C++的编译。\nGCC的命令行和参数众多，GCC官网提供的GCC手册有上千页，想要全部了解清楚难度较大，一般来说我们只需要了解GCC基本的用法即可1\n -o 参数指定生成文件  当不指定任何参数时，默认生成 a.out 文件\n# 将main.c编译生成hello可执行文件 gcc main.c -o hello  -Wall 打开所有警告\n  -E 输出预处理文件\n在C/C++中通过 #include 语句会引入很多其他文件，通过 #ifdef 等预处理命令可以实现启用或者禁用一些代码。在使用 -E 参数时，可以让编译器为我们生成预编译之后的文件，在某些情况下便于我们观察出错的原因。\n  默认 -E 输出到控制台，可以通过重定向命令写入到文件中\n$ gcc -E main.c \u0026gt; main.i -S 输出汇编代码  $ gcc -S main.c \u0026gt; main.s -C 产生编译后的.o文件和可执行文件  # 输出main.o和a.out两个文件 $ gcc -C main.c 当使用 -c（小写字母c）时，只产生main.o文件\n-l参数链接共享库  -l参数是一个常用的链接外部库的命令\n$ gcc main.c -o main -lCPPfile 代码会链接 libCPPfile库\n使用-D参数可以使用编译时的宏  $ gcc -DMY_MACRO main.c -o main 这个命令可以激活源代码中定义的 MY_MACRO宏\n使用参数-I指定头文件的文件夹  $ gcc -I/home/code/include main.c 2.3 打印额外信息 在C语言编程过程中，可以利用一些预定义的宏打印出一些有用的信息，帮助我们更好的调试程序，比如以下几个宏\n __func__ 函数名 __FILE__ 文件名 __DATE__ 日期 __TIME__ 时间 __LINE__ 行号 使用方式如下：\n// main.c 文件 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main() { printf(\u0026quot;__func__:%s\\n\u0026quot;, __func__); printf(\u0026quot;__FILE__:%s\\n\u0026quot;, __FILE__); printf(\u0026quot;__DATE__:%s\\n\u0026quot;, __DATE__); printf(\u0026quot;__TIME__:%s\\n\u0026quot;, __TIME__); printf(\u0026quot;__LINE__:%d\\n\u0026quot;, __LINE__); return 0; } 输入内容\n__func__:main __FILE__:main.c __DATE__:Apr 27 2021 __TIME__:06:59:25 __LINE__:10 3. 动手写代码 略\n4. 课堂笔记 hello.c\n编译器gcc C源文件 --\u0026gt; 预处理 --\u0026gt; 编译 --\u0026gt; 汇编 --\u0026gt; 链接 --\u0026gt; 可执行文件  编辑器vim vim /etc/vimrc cp /etc/vimrc ~/.vimrc vim ~/.vimrc vim配置脚本以及常用快捷方式  5. 参考资料  GCC编译的全部参数 Vim 配置入门 vim插件管理器：Vundle的介绍及安装（很全）   15个最常用的GCC编译器参数\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","description":"","id":18,"section":"backup","tags":null,"title":"LinuxC编程随笔（GCC和Vim的基本用法-2）","uri":"https://blog.healex.xyz/backup/linux_c_2/"},{"content":"1. 一句话总结 本课主要介绍C语言的发展史以及C语言学习的内容大纲\n2. 课程相关扩展 2.1 C语言的可移植性 C语言的可移植性并不是类似与Java那种在可执行层面的可移植性，更多的是体现在源代码级别的可移植性。而Java的可移植性更多的是指Java可执行文件的移植性。\n比如我们可以在Windows平台上有Java编写的一个可执行程序，在Linux或者MacOS X上也可以直接运行这个编译好的程序（前提是在Linux和MacOS X上有安装Java虚拟机），而C程序更多的是指用它编写的源代码，可以把在Windows上用C编写的源代码放到Linux和Mac OS X上去编译\n2.2 课程学习开发环境 老师提到课程中她使用的是CentOS 6 (64位)，我个人使用的测试环境是 VMWare Station 上安装的CentOS 7.4.1708 以及Ubuntu 18.04.5 虚拟机（都是amd64位版本）\n3. 动手写代码 （略）\n4. 本课摘要 C语言发展史 1960 原型A语言 -\u0026gt; ALGOL语言 1963 CPL语言 1967 BCPL语言 1970 B语言 1973 C语言  C语言特点 1. 基础性语言 2. 语法简介，紧凑，方便，灵活 3. 运算符，数据结构丰富 4. 结构化，模块化编程 5. 移植性好，执行效率高 6. **允许直接对硬件操作** （FPGA DSP）  C语言学习建议 1. 概念的正确性 2. 动手能力 3. 阅读优秀的程序段 4. 大量练习，面试题  C课程讲解思路 1. 基本概念 2. 数据类型，运算符和表达式 3. 输入输出专题（标准库IO） 4. 流程控制（顺序、分支、循环） 5. 数组 6. 指针 7. 函数 8. 构造类型（结构struct、Union） 9. 动态内存管理 10. 调试工具和调试技巧（gdb，make） 11. 常用库函数  平台介绍 64位的redhat6，vim，gcc(make)  5. 参考资料  1. C programming language 2. C语言  ","description":"","id":19,"section":"backup","tags":null,"title":"LinuxC编程随笔（C语言学习大纲-1）","uri":"https://blog.healex.xyz/backup/linux_c_1/"},{"content":"一直以来Linux比较感兴趣，离职后打算系统学习Linux开发，提到Linux开发就离不开LinuxC编程，偶然间在网络上找到一套还不错的教程，为了便于日后查阅，把学习过程中的点滴记录于此，方便自己和他人。\n记录中难免会有错误和疏漏，希望读者给予指正，我会保持对内容的更新。\n附：教程的地址 史上最强最细腻的C语言学习教程【李慧琴老师】\n","description":"","id":20,"section":"backup","tags":null,"title":"LinuxC编程随笔（前言-0）","uri":"https://blog.healex.xyz/backup/linux_c_preface_0/"},{"content":"辗转几次还是回到这里，开始安心写作吧！\n","description":"","id":21,"section":"posts","tags":null,"title":"转圈圈","uri":"https://blog.healex.xyz/posts/my-first-post/"}]