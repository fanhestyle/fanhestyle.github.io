[{"content":"1. 简介  OpenWRT从19.07开始逐步将网页的渲染模式从服务端移到客户端，由此带来的一个显著的变化是luci开发的Lua代码大幅减少，取而代之的是JavaScript代码的增加。今后在处理界面的逻辑上基本上都是使用JavaScript来处理了。OpenWRT 19.07系列应该是一个逐步转型的版本，在这个版本中可以支持两种模式的luci-app开发，包括：\n 使用传统的Lua方式编写网页界面（主要是 Call、Template、CBI这三种方式） 使用新式的JS+css+html的方式来编写界面   在OpenWRT 19.07中由于有大量的app尚未迁移到新的模式，为了兼容老的luci-app，可以安装luci-app-compat这个工具包来实现运行老的luci-app\n本文主要说明当前luci-app如何去编辑网页的菜单栏，把我们编写的程序放在对应的菜单栏下（菜单栏这个说法可能不准确，这个是我个人的称呼，指的是下图的内容）\n 在本文写作时，最新的19.07版本是19.07.7，在安装这个版本后，我发现当前的luci-app主要有三种形态：\n 完全没有迁移的app，还是使用18.06方式编写的界面 部分迁移的app，使用兼容模式运行 完全使用JavaScript改写的app  以一个对应的luci-app来说明每一种模式\n2. 未迁移的luci-app  在OpenWRT19.07.7的版本中，可以去opkg安装 luci-app-https-dns-proxy 这个luci-app，它就是尚未迁移的一个app，在安装之后，主要添加的文件包括：\n /usr/lib/lua/luci/controller/https-dns-proxy.lua  这个在菜单栏上的Services目录下添加了 DNS HTTPS Proxy这一项，查看文档中的内容：\nmodule(\u0026quot;luci.controller.https-dns-proxy\u0026quot;, package.seeall) function index() if nixio.fs.access(\u0026quot;/etc/config/https-dns-proxy\u0026quot;) then entry({\u0026quot;admin\u0026quot;, \u0026quot;services\u0026quot;, \u0026quot;https-dns-proxy\u0026quot;}, cbi(\u0026quot;https-dns-proxy\u0026quot;), _(\u0026quot;DNS HTTPS Proxy\u0026quot;)).acl_depends = { \u0026quot;luci-app-https-dns-proxy\u0026quot; } entry({\u0026quot;admin\u0026quot;, \u0026quot;services\u0026quot;, \u0026quot;https-dns-proxy\u0026quot;, \u0026quot;action\u0026quot;}, call(\u0026quot;https_dns_proxy_action\u0026quot;), nil).leaf = true end end function https_dns_proxy_action(name) local packageName = \u0026quot;https-dns-proxy\u0026quot; local http = require \u0026quot;luci.http\u0026quot; local sys = require \u0026quot;luci.sys\u0026quot; local util = require \u0026quot;luci.util\u0026quot; if name == \u0026quot;start\u0026quot; then sys.init.start(packageName) elseif name == \u0026quot;action\u0026quot; then util.exec(\u0026quot;/etc/init.d/\u0026quot; .. packageName .. \u0026quot; reload \u0026gt;/dev/null 2\u0026gt;\u0026amp;1\u0026quot;) elseif name == \u0026quot;stop\u0026quot; then sys.init.stop(packageName) elseif name == \u0026quot;enable\u0026quot; then sys.init.enable(packageName) elseif name == \u0026quot;disable\u0026quot; then sys.init.disable(packageName) end http.prepare_content(\u0026quot;text/plain\u0026quot;) http.write(\u0026quot;0\u0026quot;) end 在传统的luci-app开发过程中，对于一个菜单的响应有3种方式：分别是执行指定方法（Action）、访问指定页面（Views）以及调用CBI Module。\n第一种可以直接调用指定的函数，比如点击菜单项就直接重启路由器等等，比如写为“call(\u0026quot;function_name\u0026quot;)”，然后在lua文件下编写名为function_name的函数就可以调用了。 第二种可以访问指定的页面，比如写为“template(\u0026quot;myapp/mymodule\u0026quot;)”就可以调用/usr/lib/lua/luci/view/myapp/mymodule.htm文件了。 第三种方法无非是最方便的，比如写为“cbi(\u0026quot;myapp/mymodule\u0026quot;)”就可以调用/usr/lib/lua/luci/model/cbi/myapp/mymodule.lua文件了。 可以看到响应菜单的方式是通过调用cbi和call的方式进行的，cbi的model文件位置在 /usr/lib/lua/luci/model/cbi/https-dns-proxy.lua\n以上就是传统的luci-app开发方式，主要使用lua语言进行操作的交互响应。\n3. 部分迁移的luci-app  部分迁移的luci-app主要是将菜单的响应部分迁移到 javascript中（/www/luci-static/resources)，在19.07.7下的 luci-app-adblock 就是一个部分迁移的例子\n在 luci-app-adblock 中，配置菜单栏上的菜单项也是在controller目录中的adblock.lua文件中进行的，这个文件内容如下：\n-- stub lua controller for 19.07 backward compatibility module(\u0026quot;luci.controller.adblock\u0026quot;, package.seeall) function index() entry({\u0026quot;admin\u0026quot;, \u0026quot;services\u0026quot;, \u0026quot;adblock\u0026quot;}, firstchild(), _(\u0026quot;Adblock\u0026quot;), 60) entry({\u0026quot;admin\u0026quot;, \u0026quot;services\u0026quot;, \u0026quot;adblock\u0026quot;, \u0026quot;overview\u0026quot;}, view(\u0026quot;adblock/overview\u0026quot;), _(\u0026quot;Overview\u0026quot;), 10) entry({\u0026quot;admin\u0026quot;, \u0026quot;services\u0026quot;, \u0026quot;adblock\u0026quot;, \u0026quot;dnsreport\u0026quot;}, view(\u0026quot;adblock/dnsreport\u0026quot;), _(\u0026quot;DNS Report\u0026quot;), 20) entry({\u0026quot;admin\u0026quot;, \u0026quot;services\u0026quot;, \u0026quot;adblock\u0026quot;, \u0026quot;blacklist\u0026quot;}, view(\u0026quot;adblock/blacklist\u0026quot;), _(\u0026quot;Edit Blacklist\u0026quot;), 30) entry({\u0026quot;admin\u0026quot;, \u0026quot;services\u0026quot;, \u0026quot;adblock\u0026quot;, \u0026quot;whitelist\u0026quot;}, view(\u0026quot;adblock/whitelist\u0026quot;), _(\u0026quot;Edit Whitelist\u0026quot;), 40) entry({\u0026quot;admin\u0026quot;, \u0026quot;services\u0026quot;, \u0026quot;adblock\u0026quot;, \u0026quot;logread\u0026quot;}, view(\u0026quot;adblock/logread\u0026quot;), _(\u0026quot;Log View\u0026quot;), 50) end 可以看到它的调用方式不是传统luci-app方式那3种方式中的任何一种，而是一种全新的使用JavaScript进行响应的方式，这里面的view(adblock/*)对应的是/www/luci-static/resources/view 目录下的js文件\n也就是说在这种过渡方案模式下，有以下特点：\n 菜单栏的配置还是使用传统的luci-app方式进行的，仍然是在 controller 目录中配置 对于菜单栏的响应设置在新的JavaScript脚本中进行  4. 完全迁移的luci-app 上面提到了过渡模式下菜单栏和对菜单栏响应方式的变化，最新的OpenWRT的实现中，菜单栏和对菜单栏的响应都不在传统的 /usr/lib/lua/luci 目录下进行了，而是采用下面这种处理方式\n 菜单栏的配置修改到 /usr/share/luci/menu.d 目录中，并且配置文件使用.json文件 对菜单栏的响应修改到 /www/luci-static/resources 目录中，并且响应的脚本都是.js文件  我们查看这个menu.d目录中的 luci-base.json 文件，可以看到文件中列举出所有标题栏上显示的内容\n{ \u0026quot;admin\u0026quot;: { \u0026quot;title\u0026quot;: \u0026quot;Administration\u0026quot;, \u0026quot;order\u0026quot;: 10, \u0026quot;action\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;firstchild\u0026quot;, \u0026quot;recurse\u0026quot;: true }, \u0026quot;auth\u0026quot;: { \u0026quot;methods\u0026quot;: [ \u0026quot;cookie:sysauth\u0026quot; ], \u0026quot;login\u0026quot;: true } }, \u0026quot;admin/status\u0026quot;: { \u0026quot;title\u0026quot;: \u0026quot;Status\u0026quot;, \u0026quot;order\u0026quot;: 10, \u0026quot;action\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;firstchild\u0026quot;, \u0026quot;preferred\u0026quot;: \u0026quot;overview\u0026quot;, \u0026quot;recurse\u0026quot;: true } }, \u0026quot;admin/system\u0026quot;: { \u0026quot;title\u0026quot;: \u0026quot;System\u0026quot;, \u0026quot;order\u0026quot;: 20, \u0026quot;action\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;firstchild\u0026quot;, \u0026quot;preferred\u0026quot;: \u0026quot;system\u0026quot;, \u0026quot;recurse\u0026quot;: true } }, \u0026quot;admin/vpn\u0026quot;: { \u0026quot;title\u0026quot;: \u0026quot;VPN\u0026quot;, \u0026quot;order\u0026quot;: 30, \u0026quot;action\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;firstchild\u0026quot;, \u0026quot;recurse\u0026quot;: true } }, \u0026quot;admin/services\u0026quot;: { \u0026quot;title\u0026quot;: \u0026quot;Services\u0026quot;, \u0026quot;order\u0026quot;: 40, \u0026quot;action\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;firstchild\u0026quot;, \u0026quot;recurse\u0026quot;: true } }, ... //省略其他配置 }  如果我们想要添加自己的顶层菜单，是可以直接编辑这个文件的。但是并不推荐这么做，因为如果每一个组织或个人开发的程序都要添加自己的顶层菜单，那么会造成这个文件修改的混乱，更好的办法是自己创建一个.json的文件，并采用类似luci-base.js 的写法，比如我想创建一个名称是\u0026quot;HZX\u0026quot;的顶层菜单，那么可以添加一个文件\nluci-hzxtopmenu.js文件，文件内容如下：\n{ \u0026quot;admin/hzxtopmenu\u0026quot;: { //菜单对应在网页url中的地址后缀 \u0026quot;title\u0026quot;: \u0026quot;HZX\u0026quot;, //菜单栏上显示的名称 \u0026quot;order\u0026quot;: 80, //菜单栏的显示顺序（越大越在后面） \u0026quot;action\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;firstchild\u0026quot;, \u0026quot;recurse\u0026quot;: true } } } 只添加这一个文件并不能在菜单栏上显示 \u0026ldquo;HZX\u0026rdquo; ，我们需要在 \u0026ldquo;HZX\u0026rdquo; 下面添加一个子菜单选项，添加方式也是模仿已有app的写法，比如我们创建一个luci-app-goshadowsock2.json的文件，文件内容如下：\n{ \u0026quot;admin/hzxtopmenu/goshadowsocks2\u0026quot;: { \u0026quot;title\u0026quot;: \u0026quot;GoShadowsocks2\u0026quot;, \u0026quot;order\u0026quot;: 10, \u0026quot;action\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;view\u0026quot;, \u0026quot;path\u0026quot;: \u0026quot;goshadowsocks2/overview\u0026quot; } } } 这样就可以在HZX菜单项的下面添加一个叫GoShadowsocks2的子菜单项，并且点击它之后的响应转到 /www/luci-static/resources/view/goshadowsocks2/overview.js 文件中去处理，后续要做的事情就是使用JavaScript脚本完善用户点击的响应。\n下图是添加这些文件后的效果\n","description":"","id":0,"section":"posts","tags":null,"title":"OpenWRT-19.07Luci编辑菜单方法","uri":"https://blog.healex.xyz/posts/edit_menu_openwrt19.07/"},{"content":"1. 简介 OpenWRT19.07的一个重大的改动是将之前OpenWRT的Luci框架做了比较大的调整，最主要集中在将Luci的渲染方式从之前的服务端渲染模式调整到客户端的渲染模式。据OpenWRT官方说这种改动可以提升默写老旧设备的性能，将渲染网页的工作从路由器转移到用户的客户端设备。\n由于OpenWRT中luci-app非常众多，在本文写作时（最新版本是19.07.7）官方feeds中的luci-application仍然只改写了一小部分，后续估计官方会持续推进。鉴于目前19.07版本处于一种新旧方式过渡的阶段，大量老的使用lua编写的app尚未完全移植，因此如果发现老的app在19.07上运行异常（大部分都是由于cbi.lua造成的），官方给出了一些建议，包括：\n 安装luci-compat包（提供老代码的兼容方式运行） 如果页面加载缓慢，可以考虑安装 uhttpd-mod-ubus 页面加载缓慢或修改设置之后，建议重新打开浏览器标签页（或者重启浏览器）  以下我们对 19.07前后两种不同方式的luci-app开发作一个比较，挑选18.06（19.07的上一个稳定发行版）和19.07进行对比分析\n2. 18.06的luci-app风格 2.1 luci-app开发的主要方式 主要是使用openwrt提供的框架，使用lua语言进行开发，采用MVC的架构方式，在 /usr/lib/lua/luci 目录中提供有 model、controller和view几个目录，在controller目录中通过编写lua文件，生成网页上的界面菜单并且指定如何处理点击菜单之后的响应。\n响应主要通过3种方式提供：\n（1）直接调用函数的方式，比如下面的示例展示了如何调用函数响应\nmodule(\u0026quot;luci.controller.myapp.mymodule\u0026quot;, package.seeall) function index() entry({\u0026quot;click\u0026quot;, \u0026quot;here\u0026quot;, \u0026quot;now\u0026quot;}, call(\u0026quot;action_tryme\u0026quot;), \u0026quot;Click here\u0026quot;, 10).dependent=false end function action_tryme() luci.http.prepare_content(\u0026quot;text/plain\u0026quot;) luci.http.write(\u0026quot;Haha, rebooting now...\u0026quot;) luci.sys.reboot() end 再我们点击某个菜单项时，这个菜单会调用action_tryme函数\n（2）通过调用一个html页面来响应\nentry({\u0026quot;my\u0026quot;, \u0026quot;new\u0026quot;, \u0026quot;template\u0026quot;}, template(\u0026quot;myapp-mymodule/helloworld\u0026quot;), \u0026quot;Hello world\u0026quot;, 20).dependent=false 代码会调用 /usr/lib/lua/luci/view/myapp-mymodule/helloworld.htm这个页面来响应用户的点击\n（3）通过CBI的方式来响应\n这种方式也是用的比较多的一种方式，它通过编写一个lua文件来生成一个网页（包含大量的网页中控件），这些控件对应着lua中的一些类型，并且这些类型直接和uci的配置文件绑定，示例如下：\nm = Map(\u0026quot;network\u0026quot;, \u0026quot;Network\u0026quot;) -- 对应着一个配置文件 /etc/config/network s = m:section(TypedSection, \u0026quot;interface\u0026quot;, \u0026quot;Interfaces\u0026quot;) -- s对应着network这个文件中的某一个配置块 s.addremove = true -- Allow the user to create and remove the interfaces function s:filter(value) return value ~= \u0026quot;loopback\u0026quot; and value -- Don't touch loopback end s:depends(\u0026quot;proto\u0026quot;, \u0026quot;static\u0026quot;) -- Only show those with \u0026quot;static\u0026quot; s:depends(\u0026quot;proto\u0026quot;, \u0026quot;dhcp\u0026quot;) -- or \u0026quot;dhcp\u0026quot; as protocol and leave PPPoE and PPTP alone ... gw = s:option(Value, \u0026quot;gateway\u0026quot;, \u0026quot;Gateway\u0026quot;) gw:depends(\u0026quot;proto\u0026quot;, \u0026quot;static\u0026quot;) gw.rmempty = true -- Remove entry if it is empty return m -- 返回配置 当用户进行操作之后，它会把用户的操作对应到uci文件中的具体选项中，在保存的时候写入到配置文件中\n2.1 lua-app安装包的目录结构 老版本的luci-app的目录结构如下图所示：\n/ ├── etc/ │ ├── config/ │ │ └── shadowsocks // UCI 配置文件 │ │── init.d/ │ │ └── shadowsocks // init 脚本 │ └── uci-defaults/ │ └── luci-shadowsocks // uci-defaults 脚本 └── usr/ ├── bin/ │ └── ss-rules // 生成代理转发规则的脚本 └── lib/ └── lua/ └── luci/ // LuCI 部分 ├── controller/ │ └── shadowsocks.lua // LuCI 菜单配置 ├── i18n/ // LuCI 语言文件目录 │ └── shadowsocks.zh-cn.lmo └── model/ └── cbi/ └── shadowsocks/ ├── general.lua // LuCI 基本设置 ├── servers.lua // LuCI 服务器列表 ├── servers-details.lua // LuCI 服务器编辑 └── access-control.lua // LuCI 访问控制 这是一个luci-app ipk包内的文件结构，这些文件会被拷贝到OpenWRT系统中对应的位置，可以看到主题的交互文件就是在/usr/lib/lua/luci的model、controller目录中。除此之外还需要搭配一些配置文件、应用程序的启动初始化脚本、翻译文件，构成整个应用程序。\n3. 19.07的luci-app风格 新的luci-app把之前的模式进行了非常多的修改，首先一个最主要的改动就是减少了大量的lua代码，新的luci-app采用的是Javascript进行开发，并且页面基本上都是使用网页的方式来呈现（也就是直接编写html的文档，有点类似于18.06响应模式的第2种）\n新的luci-app包的文件结构如下：\nopenwrt ┕feeds ┕luci ┕applications ┕luci-app-name #界面程序的主目录 ┕htdocs ┊ ┕luci-static ┊ ┕resources ┊ ┕view ┊ ┕name.js # JavaScript 脚本界面文件。 ┕po ┊ ┕zh_Hans # 此目录名称对应简体中文。 ┊ ┕name.po # 界面语言翻译文件。 ┕root ┊ ┕etc ┊ ┊ ┕uci-defaults ┊ ┊ ┕luci-app-name # 软件安装完毕后默认执行的脚本（一次性脚本），可选。 ┊ ┕usr ┊ ┕share ┊ ┕luci ┊ ┊ ┕menu.d ┊ ┊ ┕luci-app-name.json # 界面菜单，在系统菜单中的名称、顺序等。 ┊ ┕rpcd ┊ ┕acl.d ┊ ┕luci-app-name.json # 权限控制文件，管控界面能执行的各类操作。 ┕Makefile # 编译文件。 下面这个链接给出了一个移植到新版本的luci-app程序相对于老版本的修改内容：\n luci-app-minidlna的改动  https://github.com/openwrt/luci/commit/9ae591b38fedf16c3e5c97350b7182c5e28ed71f#diff-27855472049b664538cca7ef50c43df8\n4. 参考资料 1.OpenWrt 19.07.0 - First Stable Release - 6 January 2020\n2. OpenWrt达人教程之开发人员入门指南\n3. OpenWRT18.06 IPK的目录结构\n","description":"","id":1,"section":"posts","tags":null,"title":"OpenWRT 19.07 Luci框架的改变","uri":"https://blog.healex.xyz/posts/openwrt_19.07_luci_changes/"},{"content":"1. 一句话总结 本课主要介绍C语言的发展史以及C语言学习的内容大纲\n2. 课程相关扩展 2.1 C语言的可移植性 C语言的可移植性并不是类似与Java那种在可执行层面的可移植性，更多的是体现在源代码级别的可移植性。而Java的可移植性更多的是指Java可执行文件的移植性。\n比如我们可以在Windows平台上有Java编写的一个可执行程序，在Linux或者MacOS X上也可以直接运行这个编译好的程序（前提是在Linux和MacOS X上有安装Java虚拟机），而C程序更多的是指用它编写的源代码，可以把在Windows上用C编写的源代码放到Linux和Mac OS X上去编译\n2.2 课程学习开发环境 老师提到课程中她使用的是CentOS 6 (64位)，我个人使用的测试环境是 VMWare Station 上安装的CentOS 7.4.1708 以及Ubuntu 18.04.5 虚拟机（都是amd64位版本）\n3. 动手写代码 （略）\n4. 本课摘要 C语言发展史 1960 原型A语言 -\u0026gt; ALGOL语言 1963 CPL语言 1967 BCPL语言 1970 B语言 1973 C语言  C语言特点 1. 基础性语言 2. 语法简介，紧凑，方便，灵活 3. 运算符，数据结构丰富 4. 结构化，模块化编程 5. 移植性好，执行效率高 6. **允许直接对硬件操作** （FPGA DSP）  C语言学习建议 1. 概念的正确性 2. 动手能力 3. 阅读优秀的程序段 4. 大量练习，面试题  C课程讲解思路 1. 基本概念 2. 数据类型，运算符和表达式 3. 输入输出专题（标准库IO） 4. 流程控制（顺序、分支、循环） 5. 数组 6. 指针 7. 函数 8. 构造类型（结构struct、Union） 9. 动态内存管理 10. 调试工具和调试技巧（gdb，make） 11. 常用库函数  平台介绍 64位的redhat6，vim，gcc(make)  5. 参考资料  1. C programming language 2. C语言  ","description":"","id":2,"section":"posts","tags":null,"title":"LinuxC编程随笔（C语言学习大纲-1）","uri":"https://blog.healex.xyz/posts/linux_c_1/"},{"content":"一直以来Linux比较感兴趣，离职后打算系统学习Linux开发，提到Linux开发就离不开LinuxC编程，偶然间在网络上找到一套还不错的教程，为了便于日后查阅，把学习过程中的点滴记录于此，方便自己和他人。\n记录中难免会有错误和疏漏，希望读者给予指正，我会保持对内容的更新。\n附：教程的地址 史上最强最细腻的C语言学习教程【李慧琴老师】\n","description":"","id":3,"section":"posts","tags":null,"title":"LinuxC编程随笔（前言-0）","uri":"https://blog.healex.xyz/posts/linux_c_preface_0/"},{"content":"辗转几次还是回到这里，开始安心写作吧！\n","description":"","id":4,"section":"posts","tags":null,"title":"转圈圈","uri":"https://blog.healex.xyz/posts/my-first-post/"}]