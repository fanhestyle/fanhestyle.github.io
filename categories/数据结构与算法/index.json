[{"content":"1. 概述 插入排序是一种相对简单的排序算法，插入排序算法在处理过程中每次处理一个待插入的元素，将它和已经排好序的子序列进行合并成新的已排好序的部分，逐渐增长直到整个数组排序完成。\n插入排序的主要优点包括：\n 实现相对简单（相比较快速排序，堆排序，归并排序来说它的代码相对较少） 对元素不太多的序列有比较好的性能 相比较其他 $ O(n^2) $ 的算法来说更加高效 算法是排序稳定的（值相等的元素位置顺序保持不变） In-place算法，只需要固定的内存空间占用（基本上只需要原先数组的空间即可） Online算法，可以来一个元素处理一个  2. 实现方式 插入排序的算法虽然简单，但是还是有一些细节需要注意，以下列举一些实现\n2.1 我最初的实现 以下是我自己在阅读插入排序描述之后给出的代码：(C++代码)\n 版本1  template\u0026lt;typename T\u0026gt; void insertionSort(T array[], int n) { for (int i = 1; i \u0026lt; n; i++) { int insertPos = 0; T tmp = array[i]; for (int j = 0; j \u0026lt; i; j++) { if (array[j] \u0026lt; tmp) { insertPos++; } } for (int k = i; k \u0026gt; insertPos; --k) { array[k] = array[k - 1]; } array[insertPos] = tmp; } }  版本2  template\u0026lt;typename T\u0026gt; void insertionSort(T array[], int n) { for (int i = 1; i \u0026lt; n; i++) { int insertPos = 0; T tmp = array[i]; for (int j = 0; j \u0026lt;= i; j++) { if (array[j] \u0026lt; tmp) { insertPos++; } } for (int k = i; k \u0026gt; insertPos; --k) { array[k] = array[k - 1]; } array[insertPos] = tmp; } } 以上给出的两个版本的代码，我自己通过测试程序进行测试，测试程序如下：\nint main() { int arr[] = { 1,9,2,6,4,3,8,7,5 }; insertionSort(arr, sizeof(arr) / sizeof(arr[0])); for (auto i : arr) { std::cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; std::endl; } } 分析我个人写的代码，发现有一些需要改进的点：\n  算法2实际上是有问题的\n使用测试程序是看不出来的，最后给出的结果都是1-9的顺序输出，但是算法2会造成算法的不稳定（也就是会把相等的元素的先后顺序改变）\n  算法1是正确的，但是先找位置，再移动元素可以改进一下，可以从排好序的子序列的最后位置开始往前找，而不是像我写的代码这样从前往后找。因为从后往前有一个好处是交换操作可以边找边做，而从前往后找，再找到位置之后也需要移动元素，何不一边找一边移动呢？其实这也是标准的插入排序的算法实现\n  2.2 常见的插入排序算法实现 以下是一种插入排序的算法伪码实现\ni ← 1 while i \u0026lt; length(A) j ← i while j \u0026gt; 0 and A[j-1] \u0026gt; A[j] swap A[j] and A[j-1] j ← j - 1 end while i ← i + 1 end while 这个算法有几个细节需要注意：\n  while j \u0026gt; 0 and A[j-1] \u0026gt; A[j] 的And 操作必须是一个短路的and操作（类似于C/C++中的 \u0026amp;\u0026amp;，当第一个条件失效时，不会计算第二个条件）\n  这个算法插入的时候，从插入点开始每次都进行了元素的交换\n  进行元素的交换有一个好处是完全不需要额外的空间排序，也就是说算法整个运行过程中仅仅需要算法原始元素的存储空间。不过过多的交换或许并不是很合适，可以通过记录我们当前即将要插入的元素，通过额外的一个元素的空间，来换取一直进行的交换操作。\n以上伪代码的C++实现如下\n#include \u0026lt;algorithm\u0026gt; template\u0026lt;typename T\u0026gt; void insertionSort(T arr[], int n) { for (int i = 1; i \u0026lt; n; i++) { for (int j = i; j \u0026gt; 0 \u0026amp;\u0026amp; arr[j - 1] \u0026gt; arr[j]; j--) { std::swap(arr[j - 1], arr[j]); } } } 2.3 略微改进的插入排序算法 上面在2.2节中讨论到可以通过额外的一个临时变量存储当前待插入的元素，从而减少一直进行的交换操作，伪码如下：\ni ← 1 while i \u0026lt; length(A) x ← A[i] j ← i - 1 while j \u0026gt;= 0 and A[j] \u0026gt; x A[j+1] ← A[j] j ← j - 1 end while A[j+1] ← x i ← i + 1 end while 注意算法的几个细节：\n  使用临时变量保存了即将插入的元素A[i]的值，在内层循环中一直向后移动元素，直到找到A[i]归属的那个位置\n  内层代码中赋值使用的是A[j+1] = A[j]，和2.2节中略有不同，这些是实现中边界条件的一些细节，在实际编码中需要格外注意（最好是手写一个简单的数组来模拟）\n  以上伪码的C++实现如下：\ntemplate\u0026lt;typename T\u0026gt; void insertionSort(T arr[], int n) { for (int i = 1; i \u0026lt; n; i++) { T tmp = std::move(arr[i]); int j = i-1; for (; j \u0026gt;= 0 \u0026amp;\u0026amp; arr[j] \u0026gt; tmp; j--) { arr[j + 1] = std::move(arr[j]); } arr[j+1] = std::move(tmp); } } 以上代码在设置 int j = i - 1，写起来特别别扭，建议还是用 int j = i的方式，赋值使用 arr[j] = arr[j-1]的方式，更加自然一点。\n另外代码中使用了C++的移动函数，如果数组的元素是特别大的对象，那么这样处理减少了拷贝对象的过程\n2.4 递归的实现 插入排序可以采用递归的方式来实现，插入排序采用递归的方式没有任何优势可言，不过可以考察对于递归和插入排序的理解，递归的思路如下：\n 基本情形(Base): 如果数组长度为1，排序完成 递归的处理最开始的n-1个元素 插入最后一个元素到已经排好序的子数列中  实现代码如下：\ntemplate\u0026lt;typename T\u0026gt; void insertionSort(T arr[], int n) { if (n \u0026lt;= 1) return; insertionSort(arr, n - 1); T last = arr[n - 1]; int j = n - 1; while (j \u0026gt; 0 \u0026amp;\u0026amp; arr[j-1] \u0026gt; last) { arr[j] = arr[j-1]; j--; } arr[j] = last; } 也就是在已经排好序的数组中再新增一个元素\n3. 算法的复杂度分析 最好情况：\n当数组已经是排好序的情况下，内层的循环只需要进行一次，时间复杂度是O(n)\n最坏的情况：\n当数组完全是逆序的时候，整个循环需要依次比较 1+2+3+\u0026hellip;+n-1次，于是时间复杂度是 $ O(n^2) $\n平均情况：\n平均的时间复杂度也是 $ O(n^2) $\n4. 参考资料 1.Insertion sort\n2.Insertion Sort\n3.Recursive Insertion Sort\n4.Insertion Sort by swapping???\n5.Introduction To Algorithms(chapter 2.1)\n","description":"","id":0,"section":"posts","tags":null,"title":"排序算法之插入排序","uri":"https://blog.healex.xyz/posts/insertion_sort/"},{"content":"1. 简介 B树有两种分类的方式：\n（1）按度来定义（degree）\n这种定义方法在算法导论一书中提及的，\n一棵度为t的B树：\n定义为：非根内节点的最少孩子数是t，并且强制非根内节点的最大孩子数是2t\n（2）按阶来定义（order）\n这种定义方法是在The Art of Computer Programming 一书中定义的，\n一棵m阶的B树：\n定义为：非根内节点的最大孩子数量是m，非根内节点的最小孩子数量是 m/2 向上取整\n这两种方式定义下的最简单B数就有所差异了，按度定义的话最小的B树是2-3-4树，按阶的方式定义最小的B树是2-3树\n参考资料 1. B-tree\n2.stackoverflow: What is the difference btw “Order” and “Degree” in terms of Tree data structure\n","description":"","id":1,"section":"posts","tags":null,"title":"B树(B-tree)","uri":"https://blog.healex.xyz/posts/btree/"},{"content":"1. 一句话总结 介绍C语言中的动态内存的分配、使用和释放\n2. 课程内容 3. 动手写代码 4. 课堂笔记 动态内存管理\nmalloc ralloc realloc free\n原则：谁申请谁释放（尽量在同一个函数中做到申请和释放，如果不行那么最好能在同一个模块中做到）\ntypedef：为已有的变量类型定义一个新的名字\n5. 参考资料 ","description":"","id":2,"section":"backup","tags":null,"title":"LinuxC编程随笔（动态内存管理-14）","uri":"https://blog.healex.xyz/backup/linux_c_14/"},{"content":"1. 一句话总结 介绍C语言中的结构体、共用体和枚举类型\n2. 课程内容 3. 动手写代码 4. 课堂笔记 结构体\n  产生及意义\n  类型描述\nstruct 结构提名\n{\n数据类型 成员1；\n数据类型 成员2；\n\u0026hellip;\n};\n（备注：最后的分号不能省略）\n  嵌套定义\n  定义变量（变量，数组，指针），初始化及成员引用\n成员引用：\n（1）变量名.成员名\n（2）指针-\u0026gt;成员名\n（3）(*指针).成员名\n  结构体占用内存空间大小\n对齐的概念\nattribute((packed)) //设置不要对齐：所占用的空间大小就是各成员占用空间的和\n  结构体作为函数参数\n结构体传参建议使用指针的方式进行，使用结构体类型的方式传递，会导致隐式的声明一个临时的结构体并且逐个成员的拷贝\n  共用体\n  产生及意义\n  类型描述\nunion 共用体名\n{\n数据类型 成员名1；\n数据类型 成员名2；\n\u0026hellip;\n};\n(备注：分号不能省略)\n共用体只有一个变量是有效的；\n  嵌套定义\n一般是指结构体嵌套共用体或者共用体嵌套结构体定义\n  定义变量（变量，数组，指针）初始化及成员引用\n成员引用方式：\n（1）变量名.成员名\n（2）变量名-\u0026gt;成员名\n  占用内存大小\n多个成员中最大的那个成员的大小就是整个共用体的大小\n  函数传参（值，地址）\n  位域（实际开发使用情况极少）\n  枚举\nenum 标识符\n{\n成员1，\n成员2，\n\u0026hellip;\n};\n5. 参考资料 ","description":"","id":3,"section":"backup","tags":null,"title":"LinuxC编程随笔（C语言中的构造类型-13）","uri":"https://blog.healex.xyz/backup/linux_c_13/"},{"content":"1. 一句话总结 介绍C语言中的函数\n2. 课程内容 3. 动手写代码 4. 课堂笔记 七 函数\n  函数的定义\n数据类型 函数名（【形式参数说明表：数据类型 形参名, \u0026hellip;】）\n  函数的传参\n值传参\n地址传递\n全局变量\n  函数的调用\n嵌套调用\n递归\n  函数与数组\n  函数与指针\n指针函数\n返回值是指针的函数，形如： 返回值* 函数名(形参)\n函数指针\n类型 (*指针名)(形参);\n如: int (*p)(int);\n函数指针数组\n类型 （*数组名【下标】）（形参）\n如：int (*arr[N])(int);\n指向指针函数的函数指针数组\nint *(*funcp[N])(int);\n  5. 参考资料 ","description":"","id":4,"section":"backup","tags":null,"title":"LinuxC编程随笔（函数-12）","uri":"https://blog.healex.xyz/backup/linux_c_12/"},{"content":"1. 一句话总结 2. 课程内容 3. 动手写代码 4. 课堂笔记 六、指针\n  变量与地址\n  指针与指针变量\n  直接访问与间接访问\n  空指针与野指针\n  空类型\n  定义与初始化的写法规则\n  指针运算\n  指针与数组\n指针与一维数组\n指针与二维数组\n指针与字符数组\n  const与指针\n指针常量；\n常量指针\n  指针数组与数组指针\n【存储类型】 数据类型 (*指针名)【下标】 = 值\n如： int (*p)[3];\n  多级指针\n  5. 参考资料 ","description":"","id":5,"section":"backup","tags":null,"title":"LinuxC编程随笔（指针-11）","uri":"https://blog.healex.xyz/backup/linux_c_11/"},{"content":"1. 一句话总结 介绍数组，包括一维数组、二维数组、字符数组\n2. 课程内容 3. 动手写代码 3.1 删除法求1000以内的质数 思路1：\n（1）申请一个1000大小为1000的数组，然后依次删除每一个数2开始的倍数（如3N，4N）（到1000），剩下的数就是质数\n（2）怎么记录删除呢？可以把数组中的数设置成一个不可达的数（比如-1）\n也可以用数组的下标记录数组的数值，初始化的时候是0，一旦不为0说明数被删除了，但是这样做需要数组的下标和数是匹配的（也就是说2存储在下标是[2]的位置，3\n存储在下标是[3]的位置。\n教程中就是采用的第二种删除方式，这里实现一下\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main() { int num[1001] = {0}; for(int i = 2; i \u0026lt; 1000; i++) { for(int j = 2*i; j \u0026lt; 1000; j += i) num[j] = -1; } for(int i = 2; i \u0026lt; 1000; i++) if (!num[i]) printf(\u0026quot;%d \u0026quot;, i); printf(\u0026quot;\\n\u0026quot;); exit(0); } 其他习题较简单，略\n4. 课堂笔记 数组\n一维数组\n  定义\n【存储类型】 数据类型 标识符 【下标】(下标C99之前要求是编译器的常量)\n  初始化\n（1）（默认不会初始化，里面是乱值）\n（2） 可以使用列表初始化 int arr[3] = {1,2,3};\n(3) 可以使用部分列表初始化 int arr[3] = {1}; 得到的是 1，0，0\n(4) static数组默认会把所有元素初始化为0值\n  元素引用\n下表从0开始到最大值减一\n  数组名\n数组名就是数组类型，而不是指针（见参考资料1）\n  数组越界\n数组获取值的过程实际上是计算指针解引用 arr[i] = *(\u0026amp;arr[0]+i)\n  二维数组\n  定义，初始化\n【存储类型】 数组类型 标识符【行下标】【列下标】\n  元素引用\n数组名【行标】【列标】\n  存储形式\n行主序的方式线性存储\n  深入理解二维数组\n二维数组是元素是数组的一个数组，a[2][3]表示的是一个数组a[2]，有两个元素，每一个元素都是一个大小为[3]的数组，于是a+1，移动的大小是3个元素的大小\n  字符数组\n  定义，初始化，存储特点\n【存储类型】数据类型 标识符【下标】 \u0026hellip;\n初始化方式：\n（1）单个字符初始化 char str[] = {\u0026lsquo;a\u0026rsquo;, \u0026lsquo;b\u0026rsquo;, \u0026lsquo;c\u0026rsquo;};\n（2）字符串常量初始化 char str[] = \u0026ldquo;abc\u0026rdquo;\n  输入输出\n  常用函数\n位于头文件\u0026lt;string.h\u0026gt;中：\nstrlen(以尾0为结束计算数据大小)\nstrcpy\nstrcat\nstrcmp\n  多维数组\n分拆成多级来分析  5. 参考资料 1. Is an array name a pointer?\n","description":"","id":6,"section":"backup","tags":null,"title":"LinuxC编程随笔（C语言中的数组-10）","uri":"https://blog.healex.xyz/backup/linux_c_10/"},{"content":"1. 一句话总结 介绍C语言中的顺序、选择、循环流程控制相关内容\n2. 课程内容 2.1 goto使用注意事项 goto语句会造成程序的跳转混乱，如果确实goto可以带来代码的简洁（比如多重循环需要跳出时，使用goto直接从最内侧跳出是一个不错的使用方式）那么可以去用。但是其他场景最好不要用。\ngoto使用时不能够跳过变量的定义，比如下面的代码：\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main(){ goto Label; int j = 7; Label:\tprintf(\u0026quot;%d\\n\u0026quot;,j); } Label跳转语句掠过了j和k的定义，应该是有问题的。\n不过上述代码我在测试的时候发现在GCC中把文件名后缀改成.c编译不会报错，但是改成.cpp使用g++编译时会报错\n基本的控制语句，内容比较简单，略\n3. 动手写代码 4. 课堂笔记 流程控制\n顺序、选择、循环\nNS图，流程图（工具Dia）\n简单结构与复杂结构：自然流程\n顺序：语句逐句执行\n选择：出现了一种以上的情况\n循环：重复执行某个动作（在某个条件成立的情况下）\n关键字：\n选择： if\u0026hellip;else if..elseif..else switch-case\n循环： while, do\u0026hellip;while for if-goto\n辅助控制： continue, break\n如果写if\u0026hellip;else， else与最近的if进行匹配\n超过多条语句的if或者else需要用花括号括起来\nif\u0026hellip;goto 可以构成循环（慎用：goto实现的是无条件的跳转，且不能跨函数跳转）\n死循环：\nwhile(1);\nfor(;;);\nctrl+c杀死死循环\n5. 参考资料 ","description":"","id":7,"section":"backup","tags":null,"title":"LinuxC编程随笔（C语言流程控制-9）","uri":"https://blog.healex.xyz/backup/linux_c_9/"},{"content":"1. 一句话总结 介绍LinuxC中的标准IO函数\nC语言中的输入输出\n2. 课程内容 2.1 printf函数 printf的语法格式如下：\nint printf ( const char * format, ... ); 这个原型中的format的内容包括以下几部分：\n%[flags][width][.precision][length]specifier  specifier是格式字符，包括 %d %s %c %f %g 等 flags标识左右对齐，添加+(-)前缀，补0对齐等 width：设置输出宽度，如果输出内容小于width，用空格补充，大于width，无作用 .precision（注意是点+精度位数），浮点数输出小数点位数；字符串输出字符个数  2.2 输出中添加换行符对printf打印调试大法的影响 某些情况下在不方便调试时，printf打印调试信息大法是比较好用的一种除错方法，但是有一些细节需要注意，比如下面的程序\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main() { printf(\u0026quot;[%s:%d] before while().\u0026quot;, __func__, __LINE__); while(1); printf(\u0026quot;[%s:%d] after while().\u0026quot;, __func__, __LINE__); exit(0); } 在运行过程中，程序会卡住什么也输出不了。原因在于printf是行缓冲模式，遇到换行符或者缓冲区满才会输出，而这里的缓冲区并未满，因此就会输出不了任何内容，导致调试无效\n2.3 scanf函数在循环内需要小心处理 scanf在循环内时，如果用户给的输入不合法会造成一些问题，导致循环无法结束，因为此时输入的流已经被破坏了。因此为了避免这种情况，需要小心的检查scanf的函数返回值，确保程序确实匹配到用户成功的输入项，比如：\nwhile(1) { ret = scanf(\u0026quot;%d\u0026quot;, \u0026amp;i); if (ret != 1) //判断用户输入真的是一个整数（scanf函数返回值是成功匹配的项数） { break; } } 2.4 scanf输入中使用抑制符* *可以只接受数据但是不给任何赋值，比如下面的代码\nint i; char ch; scanf(\u0026quot;%d\u0026quot;, \u0026amp;i); scanf(\u0026quot;%c\u0026quot;, \u0026amp;ch); 如果在输入时，用户先输入 24-\u0026gt;回车-\u0026gt;a，结果不正确，ch取到回车的值，而不是a\n修改为：\nint i; char ch; scanf(\u0026quot;%d\u0026quot;, \u0026amp;i); scanf(\u0026quot;%*c%c\u0026quot;, \u0026amp;ch); 让回车字符被接收，但是直接丢弃，这样可以得到正确的i=24，ch=\u0026lsquo;a\u0026rsquo;\n另外一种处理方式是使用getchar()\nint i; char ch; scanf(\u0026quot;%d\u0026quot;, \u0026amp;i); getchar(); scanf(\u0026quot;%c\u0026quot;, \u0026amp;ch); 3. 动手写代码 习题一 一个水分子的质量大约为 $$3.0*10^{-23}$$克，1夸脱水大约有950克，编写程序要求从终端输入水的夸脱数，然后显示这么多夸脱水中包含有大约多少水分子？\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #define WEIGHT 3.0e-23 #define KQ 950 int main() { float num; float sum; printf(\u0026quot;Please input water num:\u0026quot;); scanf(\u0026quot;%f\u0026quot;,\u0026amp;num); sum = num * KQ / WEIGHT; printf(\u0026quot;total kq is %e\\n\u0026quot;, sum); exit(0); } 其他习题比较简单（略）\n4. 课堂笔记 三、输入输出专题\ninput \u0026amp; output -\u0026gt; I/O (标准IO，文件IO)\n  格式化输入/输出 函数： scanf，printf\nint printf(const char *format, \u0026hellip;);\nformat: \u0026ldquo;% [修饰符] 格式字符\u0026rdquo;\nint scanf(const char format, \u0026hellip;);\nformat:抑制符\n%s的使用是比较危险的，因为不知道存储空间大小\nscanf放在循环结构中要注意能否接收到正常有效的内容\n  字符输入/输出 函数： getchar, putchar\n  字符串输入/输出 函数： gets(!), puts\ngets:十分危险的函数，可以用fgets，getline（Linux GNU的dialect）来替代\n  5. 参考资料 1. printf\n","description":"","id":8,"section":"backup","tags":null,"title":"LinuxC编程随笔（输入输出专题-8）","uri":"https://blog.healex.xyz/backup/linux_c_8/"},{"content":"1. 一句话总结 介绍C语言中的各种运算符\n2. 课程内容 2.1 自增/减的前后缀表达式 i++ ：变量在前，先取变量值使用，再进行计算\n++i：运算符在前，先进行计算，再取变量值使用\n备注：个人不是很建议写一些tricky的代码，比如 i++ + ++j 这样的代码，这样写是不好的代码，虽然可以分析出来是什么意义，但是可读性极差。不便于团队开发 2.2 逻辑运算符的短路特性 逻辑运算符包括 或(||) 与(\u0026amp;\u0026amp;) 非(!)\n对于 || 和 \u0026amp;\u0026amp; 操作符的结果如下\na || b\n1 || 0 = 1\n0 || 1 = 1\n0 || 0 = 0\n1 || 1 = 1\na \u0026amp;\u0026amp; b\n1 \u0026amp;\u0026amp; 0 = 0\n0 \u0026amp;\u0026amp; 1 = 0\n1 \u0026amp;\u0026amp; 1 = 1\n0 \u0026amp;\u0026amp; 0 = 0\n再逻辑运算中，如果一旦可以通过第一个操作数决定值，那么就不往下再计算了，比如\na || b，一旦计算得到a是true，那么b（如果是一个表达式），那么b表达式是不会进行计算的\n3. 动手写代码 暂无\n4. 课堂笔记 运算符和表达式  表达式与语句的区别\n运算符部分：\n1）每个运算符所需要的参与运算的操作数个数\n2）结合性\n3）优先级\n4）运算符的特殊用法\n%（取余）运算符两侧必须是整型数\n= 和 == （一个是赋值运算符、一个是判断相等的关系运算符）\n逻辑运算符（\u0026amp;\u0026amp;和||）的短路特性\n5）位运算的重要意义\n将操作数中第n位位置为1， 其他位不变 num = num | (1 \u0026laquo; n)\n将操作数中第n位清零，其他位不变 num = num \u0026amp; ~(1 \u0026laquo; n)\n测试指定第n位： if (num \u0026amp; (1 \u0026laquo; n))\n从一个指定宽度的数中取出其中的某几位？\n5. 参考资料 ","description":"","id":9,"section":"backup","tags":null,"title":"LinuxC编程随笔（C语言运算符-7）","uri":"https://blog.healex.xyz/backup/linux_c_7/"},{"content":"1. 一句话总结 介绍C语言中的变量\n2. 课程内容 2.1 C语言的编译模块 C语言中的编译是以.c文件作为单独模块进行编译的，一个.c文件会被编译成一个独立的模块，在链接阶段会把所有的模块链接成最终的可执行文件。\n在某一个模块中使用的全局变量如果想要被其他模块引用，其他模块可以用 extern进行声明，表示这个全局变量来自于其他模块，本模块只是想使用它的值而已。\n如果一个变量或者函数被声明为 static 类型的，那么其他模块就无法引用这个变量和模块了，因为这个static声明会把变量或者函数设定为模块自用的（自己内部使用，概不外借）\n如果其他模块确实是要用本模块的static函数，那么可以在本模块中写一个非static函数，并在这个非static函数中调用本模块的static函数，相当于封装一层\n3. 动手写代码 无\n4. 课堂笔记 变量：用来保存一些特定内容，并且在程序执行过程中值随时会发生变化的量\n定义： [存储类型] 数据类型 标识符 = 值\nType name = value;\n标识符：由字母、数字、下划线组成的不能以数字开头的标识序列 写标识符尽量做到见名生义 数据类型：基本数据类型 + 构造类型 值：注意匹配 存储类型：auto static register extern（说明型） auto：默认，自动分配空间，自动回收空间； register：（建议型）寄存器类型， 只能定义局部变量，不能定义全局变量，大小有限制，只能定义32位大小的数据类型，如double就不可以，寄存器没有地址，所以一个寄存器类型的变量无法打印处地址查看或使用 static：静态变量，自动将变量初始化为0值或者空值，并且这种类型变量的值有继承性 static：可以用来修饰一个变量或者函数 extern：说明型，意味着不能改变被说明的变量的值和类型 变量的生命周期和作用范围 1）全局变量和局部变量 2）局部变量  5. 参考资料 ","description":"","id":10,"section":"backup","tags":null,"title":"LinuxC编程随笔（C语言中的变量-6）","uri":"https://blog.healex.xyz/backup/linux_c_6/"},{"content":"1. 一句话总结 介绍C语言中各种类型的常量值\n2. 课程内容 2.1 数组名是一个常量 面试提醒：以下哪些是非法的常量： '\\012' '\\345' '\\138` 结论是 '\\138'，因为8进制不包含8这个数，三位8进制的数加上反斜杠用来转义得到一个字符常量，因此是错误的 2.2 宏替换带来的一些问题 观察以下程序的输出\n#include \u0026lt;stdio.h\u0026gt; #define PI 3.14 #define MAX(a,b) ((a) \u0026gt; (b) ? (a) : (b)) int main() { int i = 5; int j = 3; printf(\u0026quot;i=%d\\tj=%d\\n\u0026quot;, i,j); printf(\u0026quot;Max: %d\\n\u0026quot;, MAX(i++, j++)); printf(\u0026quot;i=%d\\tj=%d\\n\u0026quot;,i,j); return 0; } 程序输出的结果\ni=5\tj=3 Max: 6 i=7\tj=4 在替换MAX(i++,j++)后，表达式变成了\n printf(\u0026quot;Max: %d\\n\u0026quot;, ((i++) \u0026gt; (j++) ? (i++) : (j++))); 较大的那个数一定会自增2次，这个可能并不是我们想要的结果。因此在使用宏替换时要特别小心\n解决方式，标准C没有办法解决这样的情形，使用GCC的扩展\n#define MAX(a,b) ({typeof(a) A=a,B=b; ((A)\u0026gt;(B) ? (A):(B));}) 下面这段代码在GCC中没有问题，可以正常编译通过\n#include \u0026lt;stdio.h\u0026gt; #define PI 3.14 //#define MAX(a,b) ((a) \u0026gt; (b) ? (a) : (b)) #define MAX(a,b) ({int A=a,B=b; ((A)\u0026gt;(B) ? (A):(B));}) int main() { int i = 5; int j = 3; printf(\u0026quot;i=%d\\tj=%d\\n\u0026quot;, i,j); printf(\u0026quot;Max: %d\\n\u0026quot;, MAX(i++, j++)); printf(\u0026quot;i=%d\\tj=%d\\n\u0026quot;,i,j); return 0; } 但是在Visual Studio 2019 中却报语法错误\n3. 动手写代码 无\n4. 课堂笔记 常量与变量  常量：在程序执行过程中值不会发生变化的量\n常量分类：\n 整型常量： 1， 33， 1234 实型常量： 3.134， 23.23，9.0 字符常量：由单引号引起来的单个的字符或转移字符（\u0026lsquo;a\u0026rsquo;, \u0026lsquo;\\n\u0026rsquo;, \u0026lsquo;\\1\u0026rsquo;，'\\012', \u0026lsquo;\\x7f\u0026rsquo;） 字符串常量：有双引号引起来的一个或多个字符组成的序列，如 \u0026ldquo;af3es\u0026rdquo;, \u0026quot;\u0026quot; 标识常量: #define (只做替换，不会进行类型检查),处理在程序的预处理阶段，占用编译时间，一改全改  5. 参考资料 ","description":"","id":11,"section":"backup","tags":null,"title":"LinuxC编程随笔（C语言中的常量-5）","uri":"https://blog.healex.xyz/backup/linux_c_5/"},{"content":"1. 一句话总结 基本数据类型和存储方式\n2. 课程内容 2.1 整型数在内存中存储方式 整型数在内存中使用补码的形式存储：\n 正数的补码是它二进制本身 负数的补码是它绝对值二进制取反加一  2.2 十进制转换到其他进制 可以采用短除法，把得到的余数倒序排列得到结果\n2.3 浮点类型在内存中的存储方法 2.4 字符类型在内存中的存储方式 使用的就是整型的存储方式，但是字符表示的内容需要查询ASCII表\nchar类型在C语言中是没有明确定义它是 signed char 还是 unsigned char的\n2.5 浮点数判断相等 可以使用 fabs(a-b) \u0026lt; 1e-6 来判别\n3. 动手写代码 4. 课堂笔记 二、数据类型，运算符和表达式\n 数据类型：（基本数据类型）  1）所占字节数\n2）存储区别\n3）不同类型的数据之间的转换（隐式、显式\u0026ndash;\u0026gt;强制类型转换）\n4）特殊性：\n（1）布尔类型bool\n（2）float类型\n（3）char型是否有符号\n（4）不同形式的0值：0, \u0026lsquo;0\u0026rsquo;, \u0026ldquo;0\u0026rdquo;, \u0026lsquo;\\0\u0026rsquo;\n(5) 数据类型与后续代码中所使用的输入输出要相匹配（防止自相矛盾）\n5. 参考资料  Data Types In C : Learn C Data Type with Examples  ","description":"","id":12,"section":"backup","tags":null,"title":"LinuxC编程随笔（C语言基本数据类型和存储方式-4）","uri":"https://blog.healex.xyz/backup/linux_c_4/"},{"content":"1. 一句话总结 编码中的一些小建议\n2. 课程内容 2.1 引入函数时一定要包含头文件 在C语言中有一个叫做 \u0026ldquo;implicit function declaration\u0026rdquo;（隐式函数声明）的特性（或者说时缺陷），在C89中是这样处理的，但是在C99中已经明确移除了这个缺陷，但是GCC在编译的时候即使加上C99的标识仍然不报错1\n基本的描述是：\n** 当编译器发现一个没有声明的函数调用时，它会假设这个函数返回 int 类型的返回值 **\n在实际编码中，最好是不要使用隐式的函数声明，在使用一个函数时明确引入包含它的头文件（在GCC中默认会给出警告，可以通过设置 -Werror=implicit-function-declaration 参数让GCC遇到隐式函数声明时报错）\n2.2 main函数没有显式给出返回值 视频中的讲解在未给出返回值时，提及返回的是printf的返回值，但是与我个人的验证并不相同。\n我的环境：Ubuntu 18.06使用GCC的版本 gcc (Ubuntu 8.4.0-1ubuntu1~18.04) 8.4.0\n在编写下面的代码时：\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main() { printf(\u0026quot;hello,world\\n\u0026quot;); //\treturn 0; } 生成可执行程序，执行可执行程序后，通过在Bash上打印出$? 结果仍然是 0.\n安装参考资料中的提示，这个应该后续的C标准有做更改，在此写出我的验证。\n2.3 注释编写方式 （1）短注释可以用双斜线 //\n（2）文件最前面的解释，可以用 /* */\n（3）大段的注释建议用\n#if 0\n#endif\n3. 动手写代码 3.1 由于未引入头文件造成段错误例子\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt;\t//#include \u0026lt;string.h\u0026gt; #include \u0026lt;errno.h\u0026gt; int main(void) { FILE *fp; fp = fopen(\u0026quot;tmp\u0026quot;,\u0026quot;r\u0026quot;); if (fp == NULL) { fprintf(stderr,\u0026quot;fopen error: %s\\n\u0026quot;, strerror(errno)); exit(-1); } return 0;\t}\t4. 课堂笔记 一、基本概念\n 以helloworld为例对写程序的思路提出如下要求：  （1）头文件正确包含的重要性\n（2）以函数未单位来进行进程程序编写\n（3）声明部分+实现部分【先声明后使用】（新的C版本反倒建议随时定义随时使用，类似于C++，选择一种风格保持一致即可）\n（4）main 函数记得return\n（5）多用空格和空行，增强代码可读性\n（6）添加适量的注释，未来某个时候你会感谢当时的你\n 算法：解决问题的方法（流程图、NS图、有限状态机(FSM)）\n  程序：用某种语言实现算法\n  进程：\n  防止写越界、防止内存泄漏、谁打开谁关闭，谁申请谁释放\n  5. 参考资料  关于gcc内置函数和c隐式函数声明的认识以及一些推测 C语言隐式声明与GCC内建函数 c语言中，如果main函数的末尾没有return语句将会有什么影响?   stackoverflow: Implicit function declarations in C.)\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","description":"","id":13,"section":"backup","tags":null,"title":"LinuxC编程随笔（编码建议-3）","uri":"https://blog.healex.xyz/backup/linux_c_3/"},{"content":"1. 简介  OpenWRT从19.07开始逐步将网页的渲染模式从服务端移到客户端，由此带来的一个显著的变化是luci开发的Lua代码大幅减少，取而代之的是JavaScript代码的增加。今后在处理界面的逻辑上基本上都是使用JavaScript来处理了。OpenWRT 19.07系列应该是一个逐步转型的版本，在这个版本中可以支持两种模式的luci-app开发，包括：\n 使用传统的Lua方式编写网页界面（主要是 Call、Template、CBI这三种方式） 使用新式的JS+css+html的方式来编写界面   在OpenWRT 19.07中由于有大量的app尚未迁移到新的模式，为了兼容老的luci-app，可以安装luci-app-compat这个工具包来实现运行老的luci-app\n本文主要说明当前luci-app如何去编辑网页的菜单栏，把我们编写的程序放在对应的菜单栏下（菜单栏这个说法可能不准确，这个是我个人的称呼，指的是下图的内容）\n 在本文写作时，最新的19.07版本是19.07.7，在安装这个版本后，我发现当前的luci-app主要有三种形态：\n 完全没有迁移的app，还是使用18.06方式编写的界面 部分迁移的app，使用兼容模式运行 完全使用JavaScript改写的app  以一个对应的luci-app来说明每一种模式\n2. 未迁移的luci-app  在OpenWRT19.07.7的版本中，可以去opkg安装 luci-app-https-dns-proxy 这个luci-app，它就是尚未迁移的一个app，在安装之后，主要添加的文件包括：\n /usr/lib/lua/luci/controller/https-dns-proxy.lua  这个在菜单栏上的Services目录下添加了 DNS HTTPS Proxy这一项，查看文档中的内容：\nmodule(\u0026quot;luci.controller.https-dns-proxy\u0026quot;, package.seeall) function index() if nixio.fs.access(\u0026quot;/etc/config/https-dns-proxy\u0026quot;) then entry({\u0026quot;admin\u0026quot;, \u0026quot;services\u0026quot;, \u0026quot;https-dns-proxy\u0026quot;}, cbi(\u0026quot;https-dns-proxy\u0026quot;), _(\u0026quot;DNS HTTPS Proxy\u0026quot;)).acl_depends = { \u0026quot;luci-app-https-dns-proxy\u0026quot; } entry({\u0026quot;admin\u0026quot;, \u0026quot;services\u0026quot;, \u0026quot;https-dns-proxy\u0026quot;, \u0026quot;action\u0026quot;}, call(\u0026quot;https_dns_proxy_action\u0026quot;), nil).leaf = true end end function https_dns_proxy_action(name) local packageName = \u0026quot;https-dns-proxy\u0026quot; local http = require \u0026quot;luci.http\u0026quot; local sys = require \u0026quot;luci.sys\u0026quot; local util = require \u0026quot;luci.util\u0026quot; if name == \u0026quot;start\u0026quot; then sys.init.start(packageName) elseif name == \u0026quot;action\u0026quot; then util.exec(\u0026quot;/etc/init.d/\u0026quot; .. packageName .. \u0026quot; reload \u0026gt;/dev/null 2\u0026gt;\u0026amp;1\u0026quot;) elseif name == \u0026quot;stop\u0026quot; then sys.init.stop(packageName) elseif name == \u0026quot;enable\u0026quot; then sys.init.enable(packageName) elseif name == \u0026quot;disable\u0026quot; then sys.init.disable(packageName) end http.prepare_content(\u0026quot;text/plain\u0026quot;) http.write(\u0026quot;0\u0026quot;) end 在传统的luci-app开发过程中，对于一个菜单的响应有3种方式：分别是执行指定方法（Action）、访问指定页面（Views）以及调用CBI Module。\n第一种可以直接调用指定的函数，比如点击菜单项就直接重启路由器等等，比如写为“call(\u0026quot;function_name\u0026quot;)”，然后在lua文件下编写名为function_name的函数就可以调用了。 第二种可以访问指定的页面，比如写为“template(\u0026quot;myapp/mymodule\u0026quot;)”就可以调用/usr/lib/lua/luci/view/myapp/mymodule.htm文件了。 第三种方法无非是最方便的，比如写为“cbi(\u0026quot;myapp/mymodule\u0026quot;)”就可以调用/usr/lib/lua/luci/model/cbi/myapp/mymodule.lua文件了。 可以看到响应菜单的方式是通过调用cbi和call的方式进行的，cbi的model文件位置在 /usr/lib/lua/luci/model/cbi/https-dns-proxy.lua\n以上就是传统的luci-app开发方式，主要使用lua语言进行操作的交互响应。\n3. 部分迁移的luci-app  部分迁移的luci-app主要是将菜单的响应部分迁移到 javascript中（/www/luci-static/resources)，在19.07.7下的 luci-app-adblock 就是一个部分迁移的例子\n在 luci-app-adblock 中，配置菜单栏上的菜单项也是在controller目录中的adblock.lua文件中进行的，这个文件内容如下：\n-- stub lua controller for 19.07 backward compatibility module(\u0026quot;luci.controller.adblock\u0026quot;, package.seeall) function index() entry({\u0026quot;admin\u0026quot;, \u0026quot;services\u0026quot;, \u0026quot;adblock\u0026quot;}, firstchild(), _(\u0026quot;Adblock\u0026quot;), 60) entry({\u0026quot;admin\u0026quot;, \u0026quot;services\u0026quot;, \u0026quot;adblock\u0026quot;, \u0026quot;overview\u0026quot;}, view(\u0026quot;adblock/overview\u0026quot;), _(\u0026quot;Overview\u0026quot;), 10) entry({\u0026quot;admin\u0026quot;, \u0026quot;services\u0026quot;, \u0026quot;adblock\u0026quot;, \u0026quot;dnsreport\u0026quot;}, view(\u0026quot;adblock/dnsreport\u0026quot;), _(\u0026quot;DNS Report\u0026quot;), 20) entry({\u0026quot;admin\u0026quot;, \u0026quot;services\u0026quot;, \u0026quot;adblock\u0026quot;, \u0026quot;blacklist\u0026quot;}, view(\u0026quot;adblock/blacklist\u0026quot;), _(\u0026quot;Edit Blacklist\u0026quot;), 30) entry({\u0026quot;admin\u0026quot;, \u0026quot;services\u0026quot;, \u0026quot;adblock\u0026quot;, \u0026quot;whitelist\u0026quot;}, view(\u0026quot;adblock/whitelist\u0026quot;), _(\u0026quot;Edit Whitelist\u0026quot;), 40) entry({\u0026quot;admin\u0026quot;, \u0026quot;services\u0026quot;, \u0026quot;adblock\u0026quot;, \u0026quot;logread\u0026quot;}, view(\u0026quot;adblock/logread\u0026quot;), _(\u0026quot;Log View\u0026quot;), 50) end 可以看到它的调用方式不是传统luci-app方式那3种方式中的任何一种，而是一种全新的使用JavaScript进行响应的方式，这里面的view(adblock/*)对应的是/www/luci-static/resources/view 目录下的js文件\n也就是说在这种过渡方案模式下，有以下特点：\n 菜单栏的配置还是使用传统的luci-app方式进行的，仍然是在 controller 目录中配置 对于菜单栏的响应设置在新的JavaScript脚本中进行  4. 完全迁移的luci-app 上面提到了过渡模式下菜单栏和对菜单栏响应方式的变化，最新的OpenWRT的实现中，菜单栏和对菜单栏的响应都不在传统的 /usr/lib/lua/luci 目录下进行了，而是采用下面这种处理方式\n 菜单栏的配置修改到 /usr/share/luci/menu.d 目录中，并且配置文件使用.json文件 对菜单栏的响应修改到 /www/luci-static/resources 目录中，并且响应的脚本都是.js文件  我们查看这个menu.d目录中的 luci-base.json 文件，可以看到文件中列举出所有标题栏上显示的内容\n{ \u0026quot;admin\u0026quot;: { \u0026quot;title\u0026quot;: \u0026quot;Administration\u0026quot;, \u0026quot;order\u0026quot;: 10, \u0026quot;action\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;firstchild\u0026quot;, \u0026quot;recurse\u0026quot;: true }, \u0026quot;auth\u0026quot;: { \u0026quot;methods\u0026quot;: [ \u0026quot;cookie:sysauth\u0026quot; ], \u0026quot;login\u0026quot;: true } }, \u0026quot;admin/status\u0026quot;: { \u0026quot;title\u0026quot;: \u0026quot;Status\u0026quot;, \u0026quot;order\u0026quot;: 10, \u0026quot;action\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;firstchild\u0026quot;, \u0026quot;preferred\u0026quot;: \u0026quot;overview\u0026quot;, \u0026quot;recurse\u0026quot;: true } }, \u0026quot;admin/system\u0026quot;: { \u0026quot;title\u0026quot;: \u0026quot;System\u0026quot;, \u0026quot;order\u0026quot;: 20, \u0026quot;action\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;firstchild\u0026quot;, \u0026quot;preferred\u0026quot;: \u0026quot;system\u0026quot;, \u0026quot;recurse\u0026quot;: true } }, \u0026quot;admin/vpn\u0026quot;: { \u0026quot;title\u0026quot;: \u0026quot;VPN\u0026quot;, \u0026quot;order\u0026quot;: 30, \u0026quot;action\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;firstchild\u0026quot;, \u0026quot;recurse\u0026quot;: true } }, \u0026quot;admin/services\u0026quot;: { \u0026quot;title\u0026quot;: \u0026quot;Services\u0026quot;, \u0026quot;order\u0026quot;: 40, \u0026quot;action\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;firstchild\u0026quot;, \u0026quot;recurse\u0026quot;: true } }, ... //省略其他配置 }  如果我们想要添加自己的顶层菜单，是可以直接编辑这个文件的。但是并不推荐这么做，因为如果每一个组织或个人开发的程序都要添加自己的顶层菜单，那么会造成这个文件修改的混乱，更好的办法是自己创建一个.json的文件，并采用类似luci-base.js 的写法，比如我想创建一个名称是\u0026quot;HZX\u0026quot;的顶层菜单，那么可以添加一个文件\nluci-hzxtopmenu.js文件，文件内容如下：\n{ \u0026quot;admin/hzxtopmenu\u0026quot;: { //菜单对应在网页url中的地址后缀 \u0026quot;title\u0026quot;: \u0026quot;HZX\u0026quot;, //菜单栏上显示的名称 \u0026quot;order\u0026quot;: 80, //菜单栏的显示顺序（越大越在后面） \u0026quot;action\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;firstchild\u0026quot;, \u0026quot;recurse\u0026quot;: true } } } 只添加这一个文件并不能在菜单栏上显示 \u0026ldquo;HZX\u0026rdquo; ，我们需要在 \u0026ldquo;HZX\u0026rdquo; 下面添加一个子菜单选项，添加方式也是模仿已有app的写法，比如我们创建一个luci-app-goshadowsock2.json的文件，文件内容如下：\n{ \u0026quot;admin/hzxtopmenu/goshadowsocks2\u0026quot;: { \u0026quot;title\u0026quot;: \u0026quot;GoShadowsocks2\u0026quot;, \u0026quot;order\u0026quot;: 10, \u0026quot;action\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;view\u0026quot;, \u0026quot;path\u0026quot;: \u0026quot;goshadowsocks2/overview\u0026quot; } } } 这样就可以在HZX菜单项的下面添加一个叫GoShadowsocks2的子菜单项，并且点击它之后的响应转到 /www/luci-static/resources/view/goshadowsocks2/overview.js 文件中去处理，后续要做的事情就是使用JavaScript脚本完善用户点击的响应。\n下图是添加这些文件后的效果\n","description":"","id":14,"section":"posts","tags":null,"title":"OpenWRT-19.07Luci编辑菜单方法","uri":"https://blog.healex.xyz/posts/edit_menu_openwrt19.07/"},{"content":"1. 简介 OpenWRT19.07的一个重大的改动是将之前OpenWRT的Luci框架做了比较大的调整，最主要集中在将Luci的渲染方式从之前的服务端渲染模式调整到客户端的渲染模式。据OpenWRT官方说这种改动可以提升默写老旧设备的性能，将渲染网页的工作从路由器转移到用户的客户端设备。\n由于OpenWRT中luci-app非常众多，在本文写作时（最新版本是19.07.7）官方feeds中的luci-application仍然只改写了一小部分，后续估计官方会持续推进。鉴于目前19.07版本处于一种新旧方式过渡的阶段，大量老的使用lua编写的app尚未完全移植，因此如果发现老的app在19.07上运行异常（大部分都是由于cbi.lua造成的），官方给出了一些建议，包括：\n 安装luci-compat包（提供老代码的兼容方式运行） 如果页面加载缓慢，可以考虑安装 uhttpd-mod-ubus 页面加载缓慢或修改设置之后，建议重新打开浏览器标签页（或者重启浏览器）  以下我们对 19.07前后两种不同方式的luci-app开发作一个比较，挑选18.06（19.07的上一个稳定发行版）和19.07进行对比分析\n2. 18.06的luci-app风格 2.1 luci-app开发的主要方式 主要是使用openwrt提供的框架，使用lua语言进行开发，采用MVC的架构方式，在 /usr/lib/lua/luci 目录中提供有 model、controller和view几个目录，在controller目录中通过编写lua文件，生成网页上的界面菜单并且指定如何处理点击菜单之后的响应。\n响应主要通过3种方式提供：\n（1）直接调用函数的方式，比如下面的示例展示了如何调用函数响应\nmodule(\u0026quot;luci.controller.myapp.mymodule\u0026quot;, package.seeall) function index() entry({\u0026quot;click\u0026quot;, \u0026quot;here\u0026quot;, \u0026quot;now\u0026quot;}, call(\u0026quot;action_tryme\u0026quot;), \u0026quot;Click here\u0026quot;, 10).dependent=false end function action_tryme() luci.http.prepare_content(\u0026quot;text/plain\u0026quot;) luci.http.write(\u0026quot;Haha, rebooting now...\u0026quot;) luci.sys.reboot() end 再我们点击某个菜单项时，这个菜单会调用action_tryme函数\n（2）通过调用一个html页面来响应\nentry({\u0026quot;my\u0026quot;, \u0026quot;new\u0026quot;, \u0026quot;template\u0026quot;}, template(\u0026quot;myapp-mymodule/helloworld\u0026quot;), \u0026quot;Hello world\u0026quot;, 20).dependent=false 代码会调用 /usr/lib/lua/luci/view/myapp-mymodule/helloworld.htm这个页面来响应用户的点击\n（3）通过CBI的方式来响应\n这种方式也是用的比较多的一种方式，它通过编写一个lua文件来生成一个网页（包含大量的网页中控件），这些控件对应着lua中的一些类型，并且这些类型直接和uci的配置文件绑定，示例如下：\nm = Map(\u0026quot;network\u0026quot;, \u0026quot;Network\u0026quot;) -- 对应着一个配置文件 /etc/config/network s = m:section(TypedSection, \u0026quot;interface\u0026quot;, \u0026quot;Interfaces\u0026quot;) -- s对应着network这个文件中的某一个配置块 s.addremove = true -- Allow the user to create and remove the interfaces function s:filter(value) return value ~= \u0026quot;loopback\u0026quot; and value -- Don't touch loopback end s:depends(\u0026quot;proto\u0026quot;, \u0026quot;static\u0026quot;) -- Only show those with \u0026quot;static\u0026quot; s:depends(\u0026quot;proto\u0026quot;, \u0026quot;dhcp\u0026quot;) -- or \u0026quot;dhcp\u0026quot; as protocol and leave PPPoE and PPTP alone ... gw = s:option(Value, \u0026quot;gateway\u0026quot;, \u0026quot;Gateway\u0026quot;) gw:depends(\u0026quot;proto\u0026quot;, \u0026quot;static\u0026quot;) gw.rmempty = true -- Remove entry if it is empty return m -- 返回配置 当用户进行操作之后，它会把用户的操作对应到uci文件中的具体选项中，在保存的时候写入到配置文件中\n2.1 lua-app安装包的目录结构 老版本的luci-app的目录结构如下图所示：\n/ ├── etc/ │ ├── config/ │ │ └── shadowsocks // UCI 配置文件 │ │── init.d/ │ │ └── shadowsocks // init 脚本 │ └── uci-defaults/ │ └── luci-shadowsocks // uci-defaults 脚本 └── usr/ ├── bin/ │ └── ss-rules // 生成代理转发规则的脚本 └── lib/ └── lua/ └── luci/ // LuCI 部分 ├── controller/ │ └── shadowsocks.lua // LuCI 菜单配置 ├── i18n/ // LuCI 语言文件目录 │ └── shadowsocks.zh-cn.lmo └── model/ └── cbi/ └── shadowsocks/ ├── general.lua // LuCI 基本设置 ├── servers.lua // LuCI 服务器列表 ├── servers-details.lua // LuCI 服务器编辑 └── access-control.lua // LuCI 访问控制 这是一个luci-app ipk包内的文件结构，这些文件会被拷贝到OpenWRT系统中对应的位置，可以看到主题的交互文件就是在/usr/lib/lua/luci的model、controller目录中。除此之外还需要搭配一些配置文件、应用程序的启动初始化脚本、翻译文件，构成整个应用程序。\n3. 19.07的luci-app风格 新的luci-app把之前的模式进行了非常多的修改，首先一个最主要的改动就是减少了大量的lua代码，新的luci-app采用的是Javascript进行开发，并且页面基本上都是使用网页的方式来呈现（也就是直接编写html的文档，有点类似于18.06响应模式的第2种）\n新的luci-app包的文件结构如下：\nopenwrt ┕feeds ┕luci ┕applications ┕luci-app-name #界面程序的主目录 ┕htdocs ┊ ┕luci-static ┊ ┕resources ┊ ┕view ┊ ┕name.js # JavaScript 脚本界面文件。 ┕po ┊ ┕zh_Hans # 此目录名称对应简体中文。 ┊ ┕name.po # 界面语言翻译文件。 ┕root ┊ ┕etc ┊ ┊ ┕uci-defaults ┊ ┊ ┕luci-app-name # 软件安装完毕后默认执行的脚本（一次性脚本），可选。 ┊ ┕usr ┊ ┕share ┊ ┕luci ┊ ┊ ┕menu.d ┊ ┊ ┕luci-app-name.json # 界面菜单，在系统菜单中的名称、顺序等。 ┊ ┕rpcd ┊ ┕acl.d ┊ ┕luci-app-name.json # 权限控制文件，管控界面能执行的各类操作。 ┕Makefile # 编译文件。 下面这个链接给出了一个移植到新版本的luci-app程序相对于老版本的修改内容：\n luci-app-minidlna的改动  https://github.com/openwrt/luci/commit/9ae591b38fedf16c3e5c97350b7182c5e28ed71f#diff-27855472049b664538cca7ef50c43df8\n4. 参考资料 1.OpenWrt 19.07.0 - First Stable Release - 6 January 2020\n2. OpenWrt达人教程之开发人员入门指南\n3. OpenWRT18.06 IPK的目录结构\n","description":"","id":15,"section":"posts","tags":null,"title":"OpenWRT 19.07 Luci框架的改变","uri":"https://blog.healex.xyz/posts/openwrt_19.07_luci_changes/"},{"content":"1. 一句话总结 主要介绍GCC编译工具和Vim编辑器的基本用法\n2. 课程内容 2.1 vim使用技巧 vim编辑器的配置文件在/etc/vim/vimrc中（环境：Ubuntu18.06下配置文件），这个文件是一个全局的配置，建议在自己的家目录中配置自己使用的vim环境脚本，配置文件 .vimrc文件（注意文件名以点开头）\n基本的vim使用方式参考vim官方手册，可以尝试安装一些vim的插件来扩展vim功能，比如\n2.2 GCC使用参数 GCC是GNU提供的一系列编译器的集合，可以支持多种编程语言的编译，其中最常用的是C/C++的编译。\nGCC的命令行和参数众多，GCC官网提供的GCC手册有上千页，想要全部了解清楚难度较大，一般来说我们只需要了解GCC基本的用法即可1\n -o 参数指定生成文件  当不指定任何参数时，默认生成 a.out 文件\n# 将main.c编译生成hello可执行文件 gcc main.c -o hello  -Wall 打开所有警告\n  -E 输出预处理文件\n在C/C++中通过 #include 语句会引入很多其他文件，通过 #ifdef 等预处理命令可以实现启用或者禁用一些代码。在使用 -E 参数时，可以让编译器为我们生成预编译之后的文件，在某些情况下便于我们观察出错的原因。\n  默认 -E 输出到控制台，可以通过重定向命令写入到文件中\n$ gcc -E main.c \u0026gt; main.i -S 输出汇编代码  $ gcc -S main.c \u0026gt; main.s -C 产生编译后的.o文件和可执行文件  # 输出main.o和a.out两个文件 $ gcc -C main.c 当使用 -c（小写字母c）时，只产生main.o文件\n-l参数链接共享库  -l参数是一个常用的链接外部库的命令\n$ gcc main.c -o main -lCPPfile 代码会链接 libCPPfile库\n使用-D参数可以使用编译时的宏  $ gcc -DMY_MACRO main.c -o main 这个命令可以激活源代码中定义的 MY_MACRO宏\n使用参数-I指定头文件的文件夹  $ gcc -I/home/code/include main.c 2.3 打印额外信息 在C语言编程过程中，可以利用一些预定义的宏打印出一些有用的信息，帮助我们更好的调试程序，比如以下几个宏\n __func__ 函数名 __FILE__ 文件名 __DATE__ 日期 __TIME__ 时间 __LINE__ 行号 使用方式如下：\n// main.c 文件 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main() { printf(\u0026quot;__func__:%s\\n\u0026quot;, __func__); printf(\u0026quot;__FILE__:%s\\n\u0026quot;, __FILE__); printf(\u0026quot;__DATE__:%s\\n\u0026quot;, __DATE__); printf(\u0026quot;__TIME__:%s\\n\u0026quot;, __TIME__); printf(\u0026quot;__LINE__:%d\\n\u0026quot;, __LINE__); return 0; } 输入内容\n__func__:main __FILE__:main.c __DATE__:Apr 27 2021 __TIME__:06:59:25 __LINE__:10 3. 动手写代码 略\n4. 课堂笔记 hello.c\n编译器gcc C源文件 --\u0026gt; 预处理 --\u0026gt; 编译 --\u0026gt; 汇编 --\u0026gt; 链接 --\u0026gt; 可执行文件  编辑器vim vim /etc/vimrc cp /etc/vimrc ~/.vimrc vim ~/.vimrc vim配置脚本以及常用快捷方式  5. 参考资料  GCC编译的全部参数 Vim 配置入门 vim插件管理器：Vundle的介绍及安装（很全）   15个最常用的GCC编译器参数\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","description":"","id":16,"section":"backup","tags":null,"title":"LinuxC编程随笔（GCC和Vim的基本用法-2）","uri":"https://blog.healex.xyz/backup/linux_c_2/"},{"content":"1. 一句话总结 本课主要介绍C语言的发展史以及C语言学习的内容大纲\n2. 课程相关扩展 2.1 C语言的可移植性 C语言的可移植性并不是类似与Java那种在可执行层面的可移植性，更多的是体现在源代码级别的可移植性。而Java的可移植性更多的是指Java可执行文件的移植性。\n比如我们可以在Windows平台上有Java编写的一个可执行程序，在Linux或者MacOS X上也可以直接运行这个编译好的程序（前提是在Linux和MacOS X上有安装Java虚拟机），而C程序更多的是指用它编写的源代码，可以把在Windows上用C编写的源代码放到Linux和Mac OS X上去编译\n2.2 课程学习开发环境 老师提到课程中她使用的是CentOS 6 (64位)，我个人使用的测试环境是 VMWare Station 上安装的CentOS 7.4.1708 以及Ubuntu 18.04.5 虚拟机（都是amd64位版本）\n3. 动手写代码 （略）\n4. 本课摘要 C语言发展史 1960 原型A语言 -\u0026gt; ALGOL语言 1963 CPL语言 1967 BCPL语言 1970 B语言 1973 C语言  C语言特点 1. 基础性语言 2. 语法简介，紧凑，方便，灵活 3. 运算符，数据结构丰富 4. 结构化，模块化编程 5. 移植性好，执行效率高 6. **允许直接对硬件操作** （FPGA DSP）  C语言学习建议 1. 概念的正确性 2. 动手能力 3. 阅读优秀的程序段 4. 大量练习，面试题  C课程讲解思路 1. 基本概念 2. 数据类型，运算符和表达式 3. 输入输出专题（标准库IO） 4. 流程控制（顺序、分支、循环） 5. 数组 6. 指针 7. 函数 8. 构造类型（结构struct、Union） 9. 动态内存管理 10. 调试工具和调试技巧（gdb，make） 11. 常用库函数  平台介绍 64位的redhat6，vim，gcc(make)  5. 参考资料  1. C programming language 2. C语言  ","description":"","id":17,"section":"backup","tags":null,"title":"LinuxC编程随笔（C语言学习大纲-1）","uri":"https://blog.healex.xyz/backup/linux_c_1/"},{"content":"一直以来Linux比较感兴趣，离职后打算系统学习Linux开发，提到Linux开发就离不开LinuxC编程，偶然间在网络上找到一套还不错的教程，为了便于日后查阅，把学习过程中的点滴记录于此，方便自己和他人。\n记录中难免会有错误和疏漏，希望读者给予指正，我会保持对内容的更新。\n附：教程的地址 史上最强最细腻的C语言学习教程【李慧琴老师】\n","description":"","id":18,"section":"backup","tags":null,"title":"LinuxC编程随笔（前言-0）","uri":"https://blog.healex.xyz/backup/linux_c_preface_0/"},{"content":"辗转几次还是回到这里，开始安心写作吧！\n","description":"","id":19,"section":"posts","tags":null,"title":"转圈圈","uri":"https://blog.healex.xyz/posts/my-first-post/"}]