+++
author = "FanHe"
title = "SplayTree伸展树"
date = 2021-04-25T14:48:52+08:00
description = ""
categories = [
    "数据结构与算法"
]
draft = true

libraries = ["viz"]

+++


## 1. 简介

---

伸展树(Splay Tree)是一种二叉搜索树，相比普通的二叉搜索树，提供了平均摊还O(logN)的算法时间复杂度。伸展树会将最近访问的节点变换到根节点的位置，这一个操作一般称之为Splay，由于很多时候我们在访问一块内存区域之后，有很大的可能性会再次访问该区域，由于SplayTree的这种操作，使得下次访问的效率非常高。伸展树广泛用在各种应用和程序实现中[^1] 主要引用领域包括：缓存机制和垃圾回收算法。

SplayTree的主要优势包括：
- 平均性能表现和其他树结构（AVL、R-B树）一样高效
- 不需要在节点中存储额外的高度信息

SplayTree的缺点：
- SplayTree可能会出现一种退化成单链的情况（只有左树或右树），这种情况下虽然是短暂的。但是会带来之后的几次操作算法时间复杂度退化成O(N)，在程序中可能会出现类似于垃圾回收那种短暂停滞的卡顿
- 在任何访问操作中SplayTree都会改变树的结构（即使是读取某些节点信息，不作任何修改），这样在多线程的环境中可能会带来程序复杂性的提高



## 2. 细节

---

数据结构和算法可能之所以比较难，一个原因是由于细节非常繁琐，稍有不慎就会导致整个程序出错。许多细节在读别人代码的时候会认为是理所当然，但是一旦自己动手实现，会发现大量细节可能未完全理解透彻，导致实现起来困难重重。

本文我主要记录自己接触这些数据结构和算法过程中需要关注的内容

1. 指针和指针引用的使用
2. 自底向上和自顶向下实现的方式
3. SplayTree的实现种类

### 2.1 术语定义

以下是本文涉及的一些术语
- Splay操作/Splay：当提到Splay的时候，指的是将一个节点从指定位置通过一些列的旋转变换移动到树根节点的位置
- 左旋
- 右旋



## 3. 旋转情况

经常在树类型的数据结构中看到旋转的说法，实际上它表示的是一种从不平衡到再平衡的操作过程，比如下面的情况

```viz-dot
digraph {
    a -> b
    b -> c
}
```

### 3.1 为什么要旋转？
其实旋转有点类似于我们滑轮的情况，一侧由于太轻导致明显向上，我们需要给这一侧一个力度，让它下沉到两边大概平衡

### 3.2 和AVL树的差别
实际上SplayTree的Zig-zag以及zag-zig的情况和AVL树是一样的，都是先从子节点与父节点旋转，再父节点和祖父节点旋转得到
但是zig-zig以及zag-zag的情况就和AVL树完全不同，AVL树是一层一层的旋转，从子节点到父节点，再父节点像祖父节点一层一层旋转，也就是说AVL树是每次一层的单旋转，但是SplayTree在这种情况下是每次两层的操作（这正是这种算法的点睛之笔），也是算法作者的核心，至于为什么要这么做，是有严格证明的，但是证明比较复杂，可以参考相关的文献。但是我们理解的时候可以举一个简单的例子，比如 插入 1-2-3-4-5 这5个数，依次访问它们，如果使用单旋的方式每次一层，我们会发现全部访问完成之后，树变成另一条单链，再反向访问变回原始的样子，也就是说这种最差情况无法避免。而SplayTree设计出来的算法之间最高复杂度应该是O(N)，这显然不满足情况。但是当我们每次考虑两层的时候就发现可以得到平均摊还时间O(logN)的时间复杂度，最坏情况下是O(N)

很多时候证明比较复杂，我个人是这么理解的，算法证明比较适合于做理论研究和一些数学较好的同学。如果我们仅仅使用这种算法，我们需要的是理解它的思想以及它的引用方式，比如我通过什么转换把问题转换成这种范式，然后用这种数据结构来解决问题。如果没有兴趣可以不比去完全搞清楚证明。（以前我个人是个完美主义者，希望所有的内容都了解完全，后来发现这个是不可能的，一来是去理解这些内容太费时间，另一方面可能自己的工作可能完全不需要这些内容，我们开车不一定需要了解汽车发动机的原理，只要会使用它即可）

另外还有一种情况是当需要Splay的节点是根节点的左节点或右节点，这种情况下做一次zig或者zag即可。


## 4. 自底向上实现

自底向上的实现主要有两种方式，一种方式是通过在每个节点内保存一个指向父节点的指针，这样当对指定节点进行Splay操作时，

### 4.1 节点存储父节点字段

### 4.2 使用额外栈实现


## 5. 自顶向下的实现

另一种效率比较高的方式是自顶向下的方式，它可以在一次遍历的过程中完成查找和Splay，而不需要像自底向上那样需要两次的遍历。

思路如下...




## 参考资料



[^1]:https://en.wikipedia.org/wiki/Splay_tree