<!doctype html><html lang=cn><head><meta name=generator content="Hugo 0.82.1"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><meta property="og:title" content="OpenWRT-19.07Luci编辑菜单方法"><meta name=author content="FanHe"><meta name=keywords content="hugo,vitae,theme,static"><meta name=description content><meta property="og:title" content="OpenWRT-19.07Luci编辑菜单方法"><meta property="og:description" content="1. 简介   OpenWRT从19.07开始逐步将网页的渲染模式从服务端移到客户端，由此带来的一个显著的变化是luci开发的Lua代码大幅减少，取而代之的是JavaScript代码的增加。今后在处理界面的逻辑上基本上都是使用JavaScript来处理了。OpenWRT 19.07系列应该是一个逐步转型的版本，在这个版本中可以支持两种模式的luci-app开发，包括：
 使用传统的Lua方式编写网页界面（主要是 Call、Template、CBI这三种方式） 使用新式的JS+css+html的方式来编写界面   在OpenWRT 19.07中由于有大量的app尚未迁移到新的模式，为了兼容老的luci-app，可以安装luci-app-compat这个工具包来实现运行老的luci-app
本文主要说明当前luci-app如何去编辑网页的菜单栏，把我们编写的程序放在对应的菜单栏下（菜单栏这个说法可能不准确，这个是我个人的称呼，指的是下图的内容）
 
 在本文写作时，最新的19.07版本是19.07.7，在安装这个版本后，我发现当前的luci-app主要有三种形态：
 完全没有迁移的app，还是使用18.06方式编写的界面 部分迁移的app，使用兼容模式运行 完全使用JavaScript改写的app  以一个对应的luci-app来说明每一种模式
2. 未迁移的luci-app   在OpenWRT19.07.7的版本中，可以去opkg安装 luci-app-https-dns-proxy 这个luci-app，它就是尚未迁移的一个app，在安装之后，主要添加的文件包括：
 /usr/lib/lua/luci/controller/https-dns-proxy.lua   
这个在菜单栏上的Services目录下添加了 DNS HTTPS Proxy这一项，查看文档中的内容：
module(&#34;luci.controller.https-dns-proxy&#34;, package.seeall) function index() if nixio.fs.access(&#34;/etc/config/https-dns-proxy&#34;) then entry({&#34;admin&#34;, &#34;services&#34;, &#34;https-dns-proxy&#34;}, cbi(&#34;https-dns-proxy&#34;), _(&#34;DNS HTTPS Proxy&#34;)).acl_depends = { &#34;luci-app-https-dns-proxy&#34; } entry({&#34;admin&#34;, &#34;services&#34;, &#34;https-dns-proxy&#34;, &#34;action&#34;}, call(&#34;https_dns_proxy_action&#34;), nil).leaf = true end end function https_dns_proxy_action(name) local packageName = &#34;https-dns-proxy&#34; local http = require &#34;luci."><meta property="og:type" content="article"><meta property="og:url" content="https://blog.healex.xyz/post/edit_menu_openwrt19.07/"><meta property="article:section" content="post"><meta property="article:published_time" content="2021-04-21T23:19:21+08:00"><meta property="article:modified_time" content="2021-04-21T23:19:21+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="OpenWRT-19.07Luci编辑菜单方法"><meta name=twitter:description content="1. 简介   OpenWRT从19.07开始逐步将网页的渲染模式从服务端移到客户端，由此带来的一个显著的变化是luci开发的Lua代码大幅减少，取而代之的是JavaScript代码的增加。今后在处理界面的逻辑上基本上都是使用JavaScript来处理了。OpenWRT 19.07系列应该是一个逐步转型的版本，在这个版本中可以支持两种模式的luci-app开发，包括：
 使用传统的Lua方式编写网页界面（主要是 Call、Template、CBI这三种方式） 使用新式的JS+css+html的方式来编写界面   在OpenWRT 19.07中由于有大量的app尚未迁移到新的模式，为了兼容老的luci-app，可以安装luci-app-compat这个工具包来实现运行老的luci-app
本文主要说明当前luci-app如何去编辑网页的菜单栏，把我们编写的程序放在对应的菜单栏下（菜单栏这个说法可能不准确，这个是我个人的称呼，指的是下图的内容）
 
 在本文写作时，最新的19.07版本是19.07.7，在安装这个版本后，我发现当前的luci-app主要有三种形态：
 完全没有迁移的app，还是使用18.06方式编写的界面 部分迁移的app，使用兼容模式运行 完全使用JavaScript改写的app  以一个对应的luci-app来说明每一种模式
2. 未迁移的luci-app   在OpenWRT19.07.7的版本中，可以去opkg安装 luci-app-https-dns-proxy 这个luci-app，它就是尚未迁移的一个app，在安装之后，主要添加的文件包括：
 /usr/lib/lua/luci/controller/https-dns-proxy.lua   
这个在菜单栏上的Services目录下添加了 DNS HTTPS Proxy这一项，查看文档中的内容：
module(&#34;luci.controller.https-dns-proxy&#34;, package.seeall) function index() if nixio.fs.access(&#34;/etc/config/https-dns-proxy&#34;) then entry({&#34;admin&#34;, &#34;services&#34;, &#34;https-dns-proxy&#34;}, cbi(&#34;https-dns-proxy&#34;), _(&#34;DNS HTTPS Proxy&#34;)).acl_depends = { &#34;luci-app-https-dns-proxy&#34; } entry({&#34;admin&#34;, &#34;services&#34;, &#34;https-dns-proxy&#34;, &#34;action&#34;}, call(&#34;https_dns_proxy_action&#34;), nil).leaf = true end end function https_dns_proxy_action(name) local packageName = &#34;https-dns-proxy&#34; local http = require &#34;luci."><link rel=stylesheet type=text/css media=screen href=/css/normalize.css><link rel=stylesheet type=text/css media=screen href=/css/main.css><link rel=stylesheet type=text/css media=screen href=/css/all.css><link rel=stylesheet href=/css/katex.min.css crossorigin=anonymous><script defer src=/js/katex.min.js integrity=sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz crossorigin=anonymous></script><script defer src=/js/auto-render.min.js integrity=sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI crossorigin=anonymous onload=renderMathInElement(document.body)></script><title>OpenWRT-19.07Luci编辑菜单方法 | Fanhe博客</title></head><body><header><div id=avatar><a href=https://blog.healex.xyz><img src=/img/vitae.jpg alt=Fanhe博客></a></div><div id=titletext><h2 id=title><a href=https://blog.healex.xyz>Fanhe博客</a></h2></div><div id=title-description><p id=subtitle><pre><code>简简单单，我的空间</code></pre></p><div id=social><nav><ul><li><a href=https://github.com/fanhestyle><i title=Github class="icons fab fa-github"></i></a></li><li><a href=/index.xml><i title=RSS class="icons fas fa-rss"></i></a></li></ul></nav></div></div><div id=mainmenu><nav><ul><li><a href=/>主页</a></li><li><a href=/post>博客</a></li><li><a href=/about>关于我</a></li><li><a href=/categories>分类</a></li></ul></nav></div></header><main><div class=post><div class=author></div><div class=post-header><div class=meta><div class=date><span class=day>21</span>
<span class=rest>Apr 2021</span></div></div><div class=matter><h1 class=title>OpenWRT-19.07Luci编辑菜单方法</h1></div></div><div class=markdown><h2 id=1-简介>1. 简介</h2><hr><p> OpenWRT从19.07开始逐步将网页的渲染模式从服务端移到客户端，由此带来的一个显著的变化是luci开发的Lua代码大幅减少，取而代之的是JavaScript代码的增加。今后在处理界面的逻辑上基本上都是使用JavaScript来处理了。OpenWRT 19.07系列应该是一个逐步转型的版本，在这个版本中可以支持两种模式的luci-app开发，包括：</p><ul><li>使用传统的Lua方式编写网页界面（主要是 Call、Template、CBI这三种方式）</li><li>使用新式的JS+css+html的方式来编写界面</li></ul><p> 在OpenWRT 19.07中由于有大量的app尚未迁移到新的模式，为了兼容老的luci-app，可以安装luci-app-compat这个工具包来实现运行老的luci-app</p><p>本文主要说明当前luci-app如何去编辑网页的菜单栏，把我们编写的程序放在对应的菜单栏下（菜单栏这个说法可能不准确，这个是我个人的称呼，指的是下图的内容）</p><p><figure><img src=/img/edit_menu_openwrt19.07/menubar.png alt=标题栏></figure></p><p> 在本文写作时，最新的19.07版本是19.07.7，在安装这个版本后，我发现当前的luci-app主要有三种形态：</p><ol><li>完全没有迁移的app，还是使用18.06方式编写的界面</li><li>部分迁移的app，使用兼容模式运行</li><li>完全使用JavaScript改写的app</li></ol><p>以一个对应的luci-app来说明每一种模式</p><h2 id=2-未迁移的luci-app>2. 未迁移的luci-app</h2><hr><p> 在OpenWRT19.07.7的版本中，可以去opkg安装 luci-app-https-dns-proxy 这个luci-app，它就是尚未迁移的一个app，在安装之后，主要添加的文件包括：</p><ul><li>/usr/lib/lua/luci/controller/https-dns-proxy.lua</li></ul><p><figure><img src=/img/edit_menu_openwrt19.07/style1_1.png alt=cbi_controller></figure></p><p>这个在菜单栏上的Services目录下添加了 <code>DNS HTTPS Proxy</code>这一项，查看文档中的内容：</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback>module(&#34;luci.controller.https-dns-proxy&#34;, package.seeall)
function index()
	if nixio.fs.access(&#34;/etc/config/https-dns-proxy&#34;) then
		entry({&#34;admin&#34;, &#34;services&#34;, &#34;https-dns-proxy&#34;}, cbi(&#34;https-dns-proxy&#34;), _(&#34;DNS HTTPS Proxy&#34;)).acl_depends = { &#34;luci-app-https-dns-proxy&#34; }
		entry({&#34;admin&#34;, &#34;services&#34;, &#34;https-dns-proxy&#34;, &#34;action&#34;}, call(&#34;https_dns_proxy_action&#34;), nil).leaf = true
	end
end

function https_dns_proxy_action(name)
	local packageName = &#34;https-dns-proxy&#34;
	local http = require &#34;luci.http&#34;
	local sys = require &#34;luci.sys&#34;
	local util = require &#34;luci.util&#34;
	if name == &#34;start&#34; then
		sys.init.start(packageName)
	elseif name == &#34;action&#34; then
		util.exec(&#34;/etc/init.d/&#34; .. packageName .. &#34; reload &gt;/dev/null 2&gt;&amp;1&#34;)
	elseif name == &#34;stop&#34; then
		sys.init.stop(packageName)
	elseif name == &#34;enable&#34; then
		sys.init.enable(packageName)
	elseif name == &#34;disable&#34; then
		sys.init.disable(packageName)
	end
	http.prepare_content(&#34;text/plain&#34;)
	http.write(&#34;0&#34;)
end
</code></pre></div><p>在传统的luci-app开发过程中，对于一个菜单的响应有3种方式：分别是执行指定方法（Action）、访问指定页面（Views）以及调用CBI Module。</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback>第一种可以直接调用指定的函数，比如点击菜单项就直接重启路由器等等，比如写为“call(&#34;function_name&#34;)”，然后在lua文件下编写名为function_name的函数就可以调用了。
第二种可以访问指定的页面，比如写为“template(&#34;myapp/mymodule&#34;)”就可以调用/usr/lib/lua/luci/view/myapp/mymodule.htm文件了。
第三种方法无非是最方便的，比如写为“cbi(&#34;myapp/mymodule&#34;)”就可以调用/usr/lib/lua/luci/model/cbi/myapp/mymodule.lua文件了。
</code></pre></div><p>可以看到响应菜单的方式是通过调用cbi和call的方式进行的，cbi的model文件位置在 /usr/lib/lua/luci/model/cbi/https-dns-proxy.lua</p><p><figure><img src=/img/edit_menu_openwrt19.07/style1_cbi_model.png alt=cbi_model></figure></p><p>以上就是传统的luci-app开发方式，主要使用lua语言进行操作的交互响应。</p><h2 id=3-部分迁移的luci-app>3. 部分迁移的luci-app</h2><hr><p> 部分迁移的luci-app主要是将菜单的响应部分迁移到 javascript中（/www/luci-static/resources)，在19.07.7下的 <code>luci-app-adblock</code> 就是一个部分迁移的例子</p><p>在 <code>luci-app-adblock</code> 中，配置菜单栏上的菜单项也是在controller目录中的adblock.lua文件中进行的，这个文件内容如下：</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback>-- stub lua controller for 19.07 backward compatibility

module(&#34;luci.controller.adblock&#34;, package.seeall)

function index()
	entry({&#34;admin&#34;, &#34;services&#34;, &#34;adblock&#34;}, firstchild(), _(&#34;Adblock&#34;), 60)
	entry({&#34;admin&#34;, &#34;services&#34;, &#34;adblock&#34;, &#34;overview&#34;}, view(&#34;adblock/overview&#34;), _(&#34;Overview&#34;), 10)
	entry({&#34;admin&#34;, &#34;services&#34;, &#34;adblock&#34;, &#34;dnsreport&#34;}, view(&#34;adblock/dnsreport&#34;), _(&#34;DNS Report&#34;), 20)
	entry({&#34;admin&#34;, &#34;services&#34;, &#34;adblock&#34;, &#34;blacklist&#34;}, view(&#34;adblock/blacklist&#34;), _(&#34;Edit Blacklist&#34;), 30)
	entry({&#34;admin&#34;, &#34;services&#34;, &#34;adblock&#34;, &#34;whitelist&#34;}, view(&#34;adblock/whitelist&#34;), _(&#34;Edit Whitelist&#34;), 40)
	entry({&#34;admin&#34;, &#34;services&#34;, &#34;adblock&#34;, &#34;logread&#34;}, view(&#34;adblock/logread&#34;), _(&#34;Log View&#34;), 50)
end

</code></pre></div><p>可以看到它的调用方式不是传统luci-app方式那3种方式中的任何一种，而是一种全新的使用JavaScript进行响应的方式，这里面的view(adblock/*)对应的是/www/luci-static/resources/view 目录下的js文件</p><p><figure><img src=/img/edit_menu_openwrt19.07/adblock.png alt=cbi_model></figure></p><p>也就是说在这种过渡方案模式下，有以下特点：</p><ol><li>菜单栏的配置还是使用传统的luci-app方式进行的，仍然是在 <code>controller</code> 目录中配置</li><li>对于菜单栏的响应设置在新的JavaScript脚本中进行</li></ol><h2 id=4-完全迁移的luci-app>4. 完全迁移的luci-app</h2><hr><p>上面提到了过渡模式下菜单栏和对菜单栏响应方式的变化，最新的OpenWRT的实现中，菜单栏和对菜单栏的响应都不在传统的 /usr/lib/lua/luci 目录下进行了，而是采用下面这种处理方式</p><ul><li>菜单栏的配置修改到 /usr/share/luci/menu.d 目录中，并且配置文件使用.json文件</li><li>对菜单栏的响应修改到 /www/luci-static/resources 目录中，并且响应的脚本都是.js文件</li></ul><p>我们查看这个menu.d目录中的 luci-base.json 文件，可以看到文件中列举出所有标题栏上显示的内容</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback>{
	&#34;admin&#34;: {
		&#34;title&#34;: &#34;Administration&#34;,
		&#34;order&#34;: 10,
		&#34;action&#34;: {
			&#34;type&#34;: &#34;firstchild&#34;,
			&#34;recurse&#34;: true
		},
		&#34;auth&#34;: {
			&#34;methods&#34;: [ &#34;cookie:sysauth&#34; ],
			&#34;login&#34;: true
		}
	},

	&#34;admin/status&#34;: {
		&#34;title&#34;: &#34;Status&#34;,
		&#34;order&#34;: 10,
		&#34;action&#34;: {
			&#34;type&#34;: &#34;firstchild&#34;,
			&#34;preferred&#34;: &#34;overview&#34;,
			&#34;recurse&#34;: true
		}
	},

	&#34;admin/system&#34;: {
		&#34;title&#34;: &#34;System&#34;,
		&#34;order&#34;: 20,
		&#34;action&#34;: {
			&#34;type&#34;: &#34;firstchild&#34;,
			&#34;preferred&#34;: &#34;system&#34;,
			&#34;recurse&#34;: true
		}
	},

	&#34;admin/vpn&#34;: {
		&#34;title&#34;: &#34;VPN&#34;,
		&#34;order&#34;: 30,
		&#34;action&#34;: {
			&#34;type&#34;: &#34;firstchild&#34;,
			&#34;recurse&#34;: true
		}
	},

	&#34;admin/services&#34;: {
		&#34;title&#34;: &#34;Services&#34;,
		&#34;order&#34;: 40,
		&#34;action&#34;: {
			&#34;type&#34;: &#34;firstchild&#34;,
			&#34;recurse&#34;: true
		}
	},
   ... //省略其他配置
}
</code></pre></div><p> 如果我们想要添加自己的顶层菜单，是可以直接编辑这个文件的。但是并不推荐这么做，因为如果每一个组织或个人开发的程序都要添加自己的顶层菜单，那么会造成这个文件修改的混乱，更好的办法是自己创建一个.json的文件，并采用类似luci-base.js 的写法，比如我想创建一个名称是"HZX"的顶层菜单，那么可以添加一个文件
luci-hzxtopmenu.js文件，文件内容如下：</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback>{
	&#34;admin/hzxtopmenu&#34;: {    //菜单对应在网页url中的地址后缀
		&#34;title&#34;: &#34;HZX&#34;,      //菜单栏上显示的名称
		&#34;order&#34;: 80,         //菜单栏的显示顺序（越大越在后面）
		&#34;action&#34;: {
			&#34;type&#34;: &#34;firstchild&#34;,
			&#34;recurse&#34;: true
		}
	}
}

</code></pre></div><p>只添加这一个文件并不能在菜单栏上显示 &ldquo;HZX&rdquo; ，我们需要在 &ldquo;HZX&rdquo; 下面添加一个子菜单选项，添加方式也是模仿已有app的写法，比如我们创建一个luci-app-goshadowsock2.json的文件，文件内容如下：</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback>{
	&#34;admin/hzxtopmenu/goshadowsocks2&#34;: {
		&#34;title&#34;: &#34;GoShadowsocks2&#34;,
		&#34;order&#34;: 10,
		&#34;action&#34;: {
			&#34;type&#34;: &#34;view&#34;,
			&#34;path&#34;: &#34;goshadowsocks2/overview&#34;
		}
	}
}
</code></pre></div><p>这样就可以在HZX菜单项的下面添加一个叫GoShadowsocks2的子菜单项，并且点击它之后的响应转到 /www/luci-static/resources/view/goshadowsocks2/overview.js 文件中去处理，后续要做的事情就是使用JavaScript脚本完善用户点击的响应。</p><p>下图是添加这些文件后的效果</p><p><figure><img src=/img/edit_menu_openwrt19.07/ss2.png alt=ss2></figure></p></div><div class=tags><div class=taxosfloating_left><p>Categories</p></div><div class=termsfloating_right><p></p></div><div class=clearit></div></div></div></main><footer>© Copyright notice | <a href=https://github.com/dataCobra/hugo-vitae>Vitae</a> theme for <a href=https://gohugo.io>Hugo</a></footer></body></html>